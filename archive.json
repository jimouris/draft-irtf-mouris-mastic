{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-09-22T00:51:16.378689+00:00",
  "repo": "jimouris/draft-mouris-cfrg-mastic",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOJmRsfc5o_oMp",
      "title": "Consider using a git submodule for the upstream reference code",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/1",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The reference code makes use of code from the VDAF repository. Copy-pasting code from there will be hard to maintain long-term, as it gets updated from time to time. (We actually cut the next draft draft-irtf-cfrg-vdaf-06, which you'll need to catch up to.)\r\n\r\nOne way to solve this problem is using `git submodule`. The idea is that you can checkout code from another git repository in a folder in this repository. This would allow you to import that code directly here.",
      "createdAt": "2023-06-16T23:53:43Z",
      "updatedAt": "2023-08-09T18:36:35Z",
      "closedAt": "2023-08-09T18:36:35Z",
      "comments": [
        {
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "body": "Thanks for the comment, that's a great suggestion. Will do!",
          "createdAt": "2023-06-17T00:27:38Z",
          "updatedAt": "2023-06-17T00:27:38Z"
        },
        {
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "body": "So I've been thinking about this a bit. Should I have the whole VDAF git repo as a submodule here or can I just have the code somehow? Is there any clean way to do this?",
          "createdAt": "2023-06-21T21:57:46Z",
          "updatedAt": "2023-06-21T21:57:46Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I created a PR to close this one!",
          "createdAt": "2023-08-07T20:47:41Z",
          "updatedAt": "2023-08-07T20:47:41Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "I_kwDOJmRsfc5o_oXN",
      "title": "Update upstream reference code to the latest draft (draft-irtf-cfrg-vdaf-06)",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/2",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As mentioned in #1, we recently cut a new version of VDAF. We have also made lots of improvements to the referenced code, which would be great to have here.",
      "createdAt": "2023-06-16T23:55:07Z",
      "updatedAt": "2023-08-09T19:24:03Z",
      "closedAt": "2023-08-09T19:24:02Z",
      "comments": [
        {
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "body": "@cjpatton close this?",
          "createdAt": "2023-08-09T18:54:57Z",
          "updatedAt": "2023-08-09T18:54:57Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Yup, good call!\r\n",
          "createdAt": "2023-08-09T19:24:02Z",
          "updatedAt": "2023-08-09T19:24:02Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOJmRsfc5o_ooJ",
      "title": "Draft name",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/3",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Since this is not a CFRG RG document (yet!) you'll need to rename it to reflect that it's an individual draft. I think draft-irtf-mouris-plasma would be appropriate.\r\n\r\n(I know we discussed this in person, just filing an issue just in case it falls off my radar!)",
      "createdAt": "2023-06-16T23:57:20Z",
      "updatedAt": "2023-06-21T22:05:37Z",
      "closedAt": "2023-06-21T22:05:37Z",
      "comments": []
    },
    {
      "number": 5,
      "id": "I_kwDOJmRsfc5o_0F2",
      "title": "Consider using SHA3 instead of SHA2 for proof strings",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/5",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "For consistency with draft-irtf-cfrg-vdaf, which adopted SHA3 for its `Prg` implementations. (Except for the fixed-key AES thing, which plan to use for IDPF only.) This way implementers don't have to support both SHA2 and SHA3.",
      "createdAt": "2023-06-17T00:53:34Z",
      "updatedAt": "2023-06-21T21:56:28Z",
      "closedAt": "2023-06-21T21:56:27Z",
      "comments": []
    },
    {
      "number": 6,
      "id": "I_kwDOJmRsfc5o_0pp",
      "title": "nit: Remove white space at the end of lines",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/6",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Most linters will warn you about this: \r\n![image](https://github.com/jimouris/draft-irtf-cfrg-plasma/assets/3453007/afce3eb4-50c1-42f1-b787-0f1999a81fff)",
      "createdAt": "2023-06-17T00:56:05Z",
      "updatedAt": "2023-06-21T22:01:56Z",
      "closedAt": "2023-06-21T22:01:18Z",
      "comments": [
        {
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "body": "Oops, I thought this was enabled on my editor. Fixed it, thanks for pointing it out.",
          "createdAt": "2023-06-21T22:01:56Z",
          "updatedAt": "2023-06-21T22:01:56Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOJmRsfc5o_1JC",
      "title": "Make the VDPF \"incremental\"",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/7",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "jimouris"
      ],
      "labels": [],
      "body": "I really love how clean and simple the code is right now. I sort of wish we could leave it this way, as I have a bunch of uses cases I've thought of that would not need the \"Incremental\" part of IDPF. However to be a true replacement for Poplar1, this feature would be needed. Can you implement it, perhaps in a PR so that I can see what the differences are?",
      "createdAt": "2023-06-17T00:59:20Z",
      "updatedAt": "2023-09-01T00:16:00Z",
      "closedAt": "2023-09-01T00:16:00Z",
      "comments": [
        {
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "body": "Close by cde6001ede64ca1c43a98edbf3bb96923839ac82 (includes e4ed497dae9e27dba44ad94750f90d91cda51bbc, 82f8ef7644a4e3360b370516d509b3494fa773eb, cf3c9813797a5a9dba0ea3d108d9a60b6f43cb5f)\r\n\r\nThe next step is to add `plasma2` that uses `vidpf`",
          "createdAt": "2023-09-01T00:16:00Z",
          "updatedAt": "2023-09-01T00:16:00Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOJmRsfc5o_2H7",
      "title": "Range check on the non-zero element of VDPF output",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/8",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Playing around with the code I noticed that `Vdpf.gen` will accept any value for $\\beta$, not just $1$:\r\n\r\n```\r\ndiff --git a/poc/vdpf.sage b/poc/vdpf.sage\r\nindex 1cdfb53..48d8e47 100644\r\n--- a/poc/vdpf.sage\r\n+++ b/poc/vdpf.sage\r\n@@ -231,10 +231,10 @@ def main():\r\n     vdpf = Vdpf\r\n     vdpf.VALUE_LEN = 1\r\n     vdpf.BITS = 2\r\n-    vdpf.RING = ring.Ring(2**16)\r\n+    vdpf.RING = ring.Ring(2**32)\r\n     vdpf.BINDER = b'some nonce'\r\n\r\n-    beta = [vdpf.RING.one()] * vdpf.VALUE_LEN\r\n+    beta = [vdpf.RING.new_elm(100000)] * vdpf.VALUE_LEN\r\n     eval_points = list(range(2**vdpf.BITS)) # [0b00, 0b01, 0b10, 0b11, ...]\r\n     rand = gen_rand(vdpf.RAND_SIZE)\r\n```\r\n\r\nThe code runs just fine, but I expect the proof check to fail (the `assert` at the end of the test):\r\n```\r\n[cjpatton/fixmake][~/github.com/jimouris/draft-irtf-cfrg-plasma/poc]$ sage vdpf.sage\r\n\ufeff\ufeff[[0], [0], [0], [100000]]\r\n```\r\n\r\nIs this intended? A nice feature of `Poplar1` is that checks that each output is in the proper range. In fact, Section 3.4.2 from your paper seems to suggest that this is intended.",
      "createdAt": "2023-06-17T01:09:29Z",
      "updatedAt": "2023-06-22T00:10:13Z",
      "closedAt": "2023-06-21T21:56:14Z",
      "comments": [
        {
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "body": "Good observation :) Yeah, that's [VDPF](https://eprint.iacr.org/2021/580.pdf). It ensures that only one leaf is non zero but it doesn't guarantee that it's value is 1.\r\n\r\nWe actually solve this in PLASMA with our level-wise checks but VDPF alone does not solve this.",
          "createdAt": "2023-06-21T21:56:14Z",
          "updatedAt": "2023-06-21T21:56:14Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm going on PTO now so won't have time to discuss until week July 3. In the meantime: I think we're definitely going to need this in VDAF for PLASMA.",
          "createdAt": "2023-06-21T23:41:51Z",
          "updatedAt": "2023-06-21T23:41:51Z"
        },
        {
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "body": "Yeah, I'll add the checks on the plasma VDAF. The VIDPF primitive won't have the checks but plasma (which will make use of the primitive) will.\n\nIt's like IDPF and Poplar. IDPF doesn't guarantee it, but poplar uses the sketching technique to verify that beta is 1.",
          "createdAt": "2023-06-21T23:45:26Z",
          "updatedAt": "2023-06-21T23:45:26Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "FWIW in ia.cr/2023/130 we came up with a technique that would compose well with your VIDPF (see \"delayed-input FLP\"). The problem is that the proof strings aren't aggregable like they are in PLASMA, but the upside would be a more general range check. Could be interesting, though I don't want to scope creep.",
          "createdAt": "2023-06-21T23:47:37Z",
          "updatedAt": "2023-06-21T23:47:37Z"
        },
        {
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "body": "Thanks, I'll take a look in more detail at it! Maybe after your PTO, we can both explain our VIDPFs to each other at some point.",
          "createdAt": "2023-06-22T00:10:12Z",
          "updatedAt": "2023-06-22T00:10:12Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOJmRsfc5tsGic",
      "title": "VDPF use case: Aggregation-by-label in MPC",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/10",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Consider the following use case: [NEL (\"Network Error Logging\")](https://www.w3.org/TR/network-error-logging/) is a mechanism for web browsers to report network issues (TCP connection failure, TLS handshake failure, DNS resolution failure, ...) to origin servers. This is intended give the server insight into issues potentially affecting many users (e.g., a BGP route leak might result in loss of connectivity to an entire continent). In order to protect user privacy, we can protect the reports with [Prio3Histogram](https://www.ietf.org/archive/id/draft-irtf-cfrg-vdaf-06.html#name-prio3histogram): each client submits a \"histogram contribution\" like $[0, 0, ..., 0, 1, 0, ..., 0]$, where the position of the $1$ indicates the error that occurred.\r\n\r\nRefining the problem a bit more: a content-delivery network, like Cloudflare, terminates connections for many origin servers. In this setting it is useful to collect such a histogram _per-origin_ so that the origin's configuration (TLS parameters, etc.) can be accounted for when investigating the problem. (The more general \"heavy hitters\" version of this problem is described [on this PPM mailing list thread](https://mailarchive.ietf.org/arch/msg/ppm/6DEXt2PS3IGOGWcg5hHzgsIGYyg/).) It would also be useful to break down the data by the client's location (which country), user agent (which web browser), etc.\r\n\r\nAn alternative formulation of this problem: suppose a web browser wants to collect some metrics (how long does it take for a certain operation to complete, how much RAM does a tab take, etc.) and break it down by browser version.\r\n\r\nIn general, we'd like to take some metric and split it into buckets based on some \"label\". Prio3Histogram is easy to extend: Instead of a histogram with buckets $B_1, \\ldots, B_m$ we'd have buckets\r\n\r\n$(B_1, L_1), \\ldots, (B_1, L_m), \\ldots, (B_m, L_1), \\ldots (B_m, L_n)$ ,\r\n\r\nwhere $L_1, \\ldots, L_n$ is the list of possible values for a given label. This works fine whenever $n$ is small, but quickly blows up when the number of possible labels grows large.\r\n\r\n## Proposal\r\n\r\nDPFs provide part of the solution. In particular, we know how to secret-share a _point function_ that takes as input a label $L_i$ and outputs a vector representing a histogram contribution, or the all-zero string if the report does not have label $L_i$. This allows the Collector to _privately_ break down aggregates by any sequence of label values it wants.\r\n\r\nBut, what about _robustness_? We also want to make sure that each output is either a histogram contribution or the all-zero string. Or put another way, the concatenation of the sequence of outputs should itself be a histogram contribution (i.e., of the form $[0, \\ldots, 0, 1, 0, \\ldots, 0]$).\r\n\r\n**Question 1:** Ho do we extend VDPF for this use case? My understanding from #8 is that the base scheme, on its own, only checks that the output is \"one-hot\", i.e., of the form $[0, \\ldots, 0, x, 0, \\ldots, 0]$, where $x$ is _non-zero_, but not necessarily \"in range\" (i.e., $x\\in\\{0,1\\}$). How does PLASMA implement this range check?\r\n\r\n**Potential generalization:** This may be good enough for many use cases, but it may be possible to generalize further. In particular, each instance of Prio3 is associated with some arithmetic circuit that's used to define input validity (Count, Sum, Histogram, SumVec are all relatively simple examples.) Perhaps we can extend Prio3 to support aggregation-by-label by composing a VDPF with a [\"delayed-input FLP\"](https://eprint.iacr.org/2023/130) for the circuit.\r\n\r\nThe basic idea of delayed-input FLP is that the client generates a validity proof both for its true input (i.e., the histogram contribution) and the all-zero string. (We require the all-zero string to be a valid input to the circuit.) The verifier then checks both proofs on the _sum_ of the VDPF outputs: the sum will be equal to the client's input if the client's label is among the labels queried by the Collector; and the sum will be zero if the client's label is not in the query. Thus the sum is deemed valid iff exactly one of these proofs verifies.\r\n\r\nFrom our our analysis of [Doplar](https://eprint.iacr.org/2023/130), a composition like this should work as long as the VDPF is \"extractable\" (as defined in our paper). The main open question is how to lift a _generic_ FLP into a delayed-input FLP. Our analysis applies to a particular validity circuit.\r\n\r\n**Question 2:** What do you think about pursuing this generalization in this draft? It's not essential to the core functionality of PLASMA, which is to solve heavy hitters. We already have use cases for at least the histogram functionality, so I would like to add that feature at least; but I strongly suspect we will be able to make use of the generalization as well; see  https://github.com/ietf-wg-ppm/draft-ietf-ppm-dap/issues/489.  Note: Hannah Davis (you met at PETS) is available to help us with this, so the lift may not be too much work for you.",
      "createdAt": "2023-08-07T22:14:33Z",
      "updatedAt": "2023-10-17T01:27:14Z",
      "closedAt": "2023-10-17T01:27:14Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "**Question 1.5:** Before deciding to pursue the generalization describe above, we should see to what extend techniques from the PLASMA paper can be generalized to handle more sophisticated range checks? E.g., each $x \\in [0..2^k)$ in a vector",
          "createdAt": "2023-08-11T15:15:54Z",
          "updatedAt": "2023-08-11T15:15:54Z"
        },
        {
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "body": "**Question 1:** This is what we call \"Client Input Validation\" in PLASMA. It involves four checks in the three-server setting, but in the two-server setting, we can remove the ones that check for consistency between the three sessions.\r\n\r\n1. The servers verify that the proofs \u03c0 are the same for all three sessions. This ensures that there is at most one path in the binary tree that is non-zero.\r\n2. For the root level (i.e., $k = 0$), the servers evaluate the VIDPF keys on the empty string \u03f5 and verify it is 1.\r\n3. For the kth level, the servers need to verify that $y^{p||0}$ is either 0 or 1, without reconstructing the output (here $p$ is the parent prefix). We perform this check by observing that the output of the parent $p$ should be the sum of the outputs of $p || 0$ and $p || 1$. The servers evaluate the VIDPF keys on the parent string $p$ and sibling (of $p || 0$) string $p || 1$ to obtain secret shares of the output of $y^{p}$ and $y^{p || 1}$, respectively. The servers reconstruct $y^{p} - (y^{p || 0} + y^{p || 1})$ and verify that it is 0. This ensures that _at most_ one of $y^{p || 0}$ and $y^{p || 1}$ is non zero. The servers also verify the corresponding proofs \u03c0 generated during the VIDPF evaluation along the path, to ensure there is _at most_ one non-zero path in the entire binary tree.\r\n4. The servers also need to ensure that the client input is consistent across the three server sessions. This is ensured by computing the difference of the reconstructed outputs across the sessions and verifying that they are equal to 0 by matching their hash values.\r\n\r\n\r\n**Potential generalization:** We'll need to think about it more carefully. Now, based on how we perform the third check (from above) I do not see a trivial way to generalize it. @pratiksarkar93 this is definitely interesting to look into as it'll make PLASMA more powerful.",
          "createdAt": "2023-08-11T17:00:33Z",
          "updatedAt": "2023-08-11T17:02:17Z"
        },
        {
          "author": "pratiksarkar93",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the questions @cjpatton. I believe @jimouris answered Q1 in the above comment. \r\n\r\nLet me answer Q1.5. We can use a range check to verify that x lies in a range. \r\n\r\nProtocol Sketch: Each DPF evaluator sums up all their leaves. Then the two evaluators possess the shares of the sum (which should be x). Run a 2PC comparison on the shares that the combined value lies in the required range. Note that PLASMA performs the same task for pruning. \r\n\r\nQ2: This is an interesting question. Can you explain for which type of languages you want to compile an FLP to a delayed FLP? Also, for what kind of languages can we build a delayed FLP directly from VDPF? ",
          "createdAt": "2023-08-11T19:00:19Z",
          "updatedAt": "2023-08-11T19:00:19Z"
        },
        {
          "author": "pratiksarkar93",
          "authorAssociation": "COLLABORATOR",
          "body": "@cjpatton : I really like the question of NEL. Let me propose a solution using a DPF. The client votes on the nm possible values using a DPF. That would incur O(log(nm)) computation by the client. The communication would be klog(nm) where k is the security parameter. The servers evaluate the client DPF keys on points where they want to perform the metrics computation. Each (i, j)th point is a combination of (B_i, L_j). The server computation ranges with the number of combinations they want to consider for the data collection process. The client computation grows logarithmically with the total number of parameters (in this case 2). \r\n\r\nIf there are 3 dimensions in the histogram, say nxmxt, then the client would compute a DPF over n*m*t combinations incurring O(log(nmt)) computation. ",
          "createdAt": "2023-08-12T13:48:58Z",
          "updatedAt": "2023-08-12T13:50:32Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "**For question 2**: \r\n\"Inner\" measurement: $m' \\in M'$ (e.g., Age: [0, 99])\r\n\r\n\"Inner\" aggregation function: $f': M'^* -> O'$ (e.g., Average of age across multiple users)\r\n\r\nMeasurement: $(\\alpha, m') \\in L \\times O'$ (e.g., `(Country, Age)`)\r\n\r\nAggregation parameter: $a = (\\alpha_1, \\ldots, \\alpha_k) \\in L^*$ (e.g., (US, Mexico, ....))\r\n\r\nAggregation function: $f(a, ((\\alpha_1, m'_1), \\ldots, (\\alpha_n, m'_n)) := f'(m'_i) \\forall i \\in [1 \\ldots n]$ s.t. $\\alpha_i \\in a$\r\n",
          "createdAt": "2023-08-18T16:35:54Z",
          "updatedAt": "2023-08-18T16:44:25Z"
        },
        {
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "body": "About 1.5: @pratiksarkar93 Following up with @hannahdaviscrypto's idea. Their FLP technique allows a range check on secret shares. So, Hannah suggested that we could check that the value in the root is within range (using FLP) and then our PLASMA checks would take care of the intermediate levels (i.e., at most one leaf has a non-zero value + the value of the root is propagated down the tree correctly). Hannah correct me if I'm wrong. \r\n\r\nPratik, what do you think about this?",
          "createdAt": "2023-08-18T16:51:35Z",
          "updatedAt": "2023-08-18T16:51:35Z"
        },
        {
          "author": "pratiksarkar93",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm sorry for not getting back to you sooner. Was traveling! \r\n\r\nYes, I agree with @hannahdaviscrypto 's idea. It will suffice to check that the value of the root (in this case the age) lies in the range. I think we can also satisfy more complex predicates cause we only need to deal with the root value. The rest is taken care by the PLASMA checks. \r\n\r\n**For question 2:**\r\nIf the aggregation parameter $a$ is public, we can do this using verifiable DPFs.\r\n1. Each client computes vDPF keys on input $\\alpha_i, m_i$. The client sends the keys to the servers. The client also proves to the servers that the root value satisfies some property (the age lies in 0-99).\r\n\r\n2. The servers evaluate the DPFs on the $\\alpha_i \\in a$ strings for all the clients. The servers verify the FLP on the root value of each client + the PLASMA checks (mentioned in the previous comment). Servers reject the malformed client inputs.\r\n\r\n3. The servers aggregate the output.\r\n\r\nThe parameters can be more general like Zip codes and the aggregation parameter can be more granular, like a subset of the zipcodes. ",
          "createdAt": "2023-08-24T07:28:54Z",
          "updatedAt": "2023-08-24T07:28:54Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed by #20.",
          "createdAt": "2023-10-17T01:27:14Z",
          "updatedAt": "2023-10-17T01:27:14Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOJmRsfc5usKF6",
      "title": "IETF tooling is currently broken",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/11",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [],
      "body": "`make` currently fails with a strange error. It looks to me like the repo wasn't set up correctly. Before long we should do the set up from scratch (this may require setting up a new repository).",
      "createdAt": "2023-08-18T17:42:28Z",
      "updatedAt": "2023-10-13T18:22:27Z",
      "closedAt": "2023-10-13T18:22:27Z",
      "comments": []
    },
    {
      "number": 12,
      "id": "I_kwDOJmRsfc5v7Ibp",
      "title": "Heavy Hitters with different Thresholds",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/12",
      "state": "CLOSED",
      "author": "jimouris",
      "authorAssociation": "OWNER",
      "assignees": [
        "jimouris"
      ],
      "labels": [
        "enhancement"
      ],
      "body": "We can use different heavy hitter thresholds $T_i$ based on some pre-agreed strings `agg_param \u2208 agg_parameters` by the servers.\r\n\r\nExample from PLASMA paper: This can be beneficial for traffic avoidance since different roads may have different traffic densities. For example, highways are busier than smaller suburban roads. The servers can take that into consideration during evaluation, and use higher $T$ s for highways (since there are more vehicles), and lower thresholds for smaller roads.\r\n\r\nThe aggregation parameters can be tuples instead of single values:\r\n```\r\naggregation_params = [(0b0000, 7), (0b0001, 6), (0b0000000, _), (0b0000001, _)]\r\n```\r\nmeaning that the threshold $T$ for `aggregation_param = 0b0000` is 7, the $T$ for `0b0001` is 6, and so on. Nice to have: if an aggregation parameter does not have an explicit threshold (like `(0b0000000, _)`) it should inherit from its parent (so it'd be 7 in this case).",
      "createdAt": "2023-09-01T17:09:04Z",
      "updatedAt": "2023-10-25T20:19:03Z",
      "closedAt": "2023-10-25T20:19:03Z",
      "comments": []
    },
    {
      "number": 17,
      "id": "I_kwDOJmRsfc5z_hCp",
      "title": "poc: Use binary encoding for SHA-3 inputs rather than ascii",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/17",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-16T20:24:43Z",
      "updatedAt": "2023-12-07T22:32:26Z",
      "closedAt": "2023-12-07T22:32:26Z",
      "comments": [
        {
          "author": "divergentdave",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed, an encoding for prefixes will be needed eventually for the aggregation parameter, and we may as well use it here. Plus, using ASCII may require implementations to use a bigint library for sufficiently long inputs.",
          "createdAt": "2023-12-07T20:53:49Z",
          "updatedAt": "2023-12-07T20:53:49Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@divergentdave please give a quick look at #46.",
          "createdAt": "2023-12-07T21:04:12Z",
          "updatedAt": "2023-12-07T21:04:12Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "I_kwDOJmRsfc5z_uVF",
      "title": "vidpf: Can we reduce the size of the public share in \"non-incremental\" mode?",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/19",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As of #18, `Vidpf` has a parameter called `INCREMENTAL_MODE` indicating whether it'll be used as a VIDPF or a VDPF. This is useful for `Mastic` because it allow us to decide when to check the FLP during preparation (at level `0` in incremental mode and at level `BITS - 1` otherwise).\r\n\r\nWhy plumb this down to `Vidpf`? The hope is that we can reduce the size of the public share in non-incremental mode because we don't have to distribute correction words for levels we don't evaluate. Is this true?\r\n\r\nIf so, extend `Vidpf` with this feature. Otherwise, consider hoisting `INCREMENTAL_MODE` up to `Mastic`.",
      "createdAt": "2023-10-16T20:59:12Z",
      "updatedAt": "2023-10-20T22:57:53Z",
      "closedAt": "2023-10-20T22:57:53Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Per discussion on 2022/10/20: This optimization is not possible due to how path verifiability is implemented in VIDPF.",
          "createdAt": "2023-10-20T17:30:34Z",
          "updatedAt": "2023-10-20T17:30:34Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "I_kwDOJmRsfc50RAeA",
      "title": "Reduce encoding bytes for level if total number of levels is less than 256",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/23",
      "state": "CLOSED",
      "author": "jimouris",
      "authorAssociation": "OWNER",
      "assignees": [
        "jimouris"
      ],
      "labels": [
        "enhancement"
      ],
      "body": "We're currently using 2 bytes to encode the level:\r\n```python\r\nsha3.update(str(node).encode('ascii') + to_le_bytes(current_level, 2) + next_seed)\r\n```\r\n\r\nThis can be abstracted out as a parameter and also detect if the level is less than 256 we can use just a single byte.\r\n\r\n",
      "createdAt": "2023-10-18T20:40:31Z",
      "updatedAt": "2024-09-13T16:53:38Z",
      "closedAt": "2024-09-13T16:53:38Z",
      "comments": [
        {
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "body": "I am closing this as non-important.",
          "createdAt": "2024-09-13T16:53:36Z",
          "updatedAt": "2024-09-13T16:53:36Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "I_kwDOJmRsfc50Z_ZV",
      "title": "mastic: Change agg_param format to support fast-start and/or simultaneous level computation?",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/24",
      "state": "CLOSED",
      "author": "hannahedavis",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In a comment, @cjpatton raised the idea of a \"fast-start\" mode that allows aggregators to begin aggregating at an arbitrary level with an arbitrary set of starting prefixes. Currently Mastic does not support this feature because the FLP must be verified at level zero before any further output can be validated. Since aggregators do not necessarily store information about previous rounds except when validating aggregation parameters, one suggestion was to change the aggregation parameter to include information about which level was first evaluated. The downside of this is that the aggregation parameter format would become inconsistent with Poplar, and thus introduce changes at the DAP level. \r\n\r\nAnother suggestion, with the same downside, is to change the aggregation parameter format to a tuple of the current aggregation parameter types. Mastic could then support simultaneous aggregation of multiple different levels on the same reports. The validity condition on the new aggregation parameters would be the existing condition applied to the parameters' union. \r\n\r\nThe one solution that doesn't require aggregation parameters to change is to fix the starting level as a parameter of the VDAF scheme.  ",
      "createdAt": "2023-10-19T20:02:25Z",
      "updatedAt": "2024-09-13T19:34:49Z",
      "closedAt": "2024-09-13T19:33:38Z",
      "comments": [
        {
          "author": "hannahdaviscrypto",
          "authorAssociation": "COLLABORATOR",
          "body": "Fast-start added to Mastic. The aggregation parameter now includes a boolean flag indicating whether the FLP should be verified, and a sequence of aggregation parameters is considered valid only if one of them includes an FLP verification. This does introduce inconsistencies with Poplar, but shouldn't require special handling at the DAP level outside of the current interface.",
          "createdAt": "2024-09-13T19:33:38Z",
          "updatedAt": "2024-09-13T19:34:49Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "I_kwDOJmRsfc50zj7m",
      "title": "Harmonize VIDPF with changes to IDPF in draft-irtf-cfrg-vdaf-12",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/34",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [],
      "body": "We would like these to be aligned as possible. We're still optimizing IDPF here and there, e.g., https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/303. We should decide if we're OK with these optimizations.",
      "createdAt": "2023-10-24T16:46:18Z",
      "updatedAt": "2024-09-17T13:25:44Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "We should expect a speed-up for Mastic here: https://github.com/divviup/libprio-rs/pull/859#issuecomment-1834297018",
          "createdAt": "2023-11-30T18:07:31Z",
          "updatedAt": "2023-11-30T18:07:31Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh this one is also assigned to you. Basically we took an optimization that reducees the number of AES calls per level from 3 to 2. This improved speed quite a bit, so we want this change for VIDPF as well.",
          "createdAt": "2024-01-12T17:36:39Z",
          "updatedAt": "2024-01-12T17:36:39Z"
        },
        {
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "body": "@cjpatton close this one?",
          "createdAt": "2024-09-13T16:52:02Z",
          "updatedAt": "2024-09-13T16:52:02Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Not yet, -12 is still work in progress. @divergentdave is working on some changes to IDPF that we'll want to take in VIDPF: https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/416",
          "createdAt": "2024-09-13T16:55:52Z",
          "updatedAt": "2024-09-17T13:25:44Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "I_kwDOJmRsfc50zoUc",
      "title": "Full FLP support: Pass `num_measurements` to `Flp.decode()`",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/35",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [],
      "body": "Some FLPs require knowing the number of measurements in order to [decode the aggregate result](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf#section-7.1.1-6.1), e.g., when computing the arithmetic mean.\r\n\r\n[We don't support this at the moment](https://github.com/jimouris/draft-mouris-cfrg-mastic/blob/077fb76db8a0f62f8391cb44c27c89dce05fd7ca/poc/vdaf_mastic.py#L189-L199) because we don't count how many inputs match each candidate prefix.\r\n\r\nOne way to address this to always aggregate prefix counts [the way we do for plain heavy-hitters](https://datatracker.ietf.org/doc/html/draft-mouris-cfrg-mastic#section-5.3-7).\r\n\r\n",
      "createdAt": "2023-10-24T16:56:49Z",
      "updatedAt": "2023-11-16T00:50:26Z",
      "closedAt": "2023-11-16T00:50:26Z",
      "comments": []
    },
    {
      "number": 36,
      "id": "I_kwDOJmRsfc50zosD",
      "title": "Full FLP support: Add support for circuits with joint randomness",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/36",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "hannahdaviscrypto"
      ],
      "labels": [],
      "body": "This should be fairly straightforward since the Aggregators can always compute shares of `beta`. Just do what is done in Prio3.",
      "createdAt": "2023-10-24T16:57:53Z",
      "updatedAt": "2023-11-15T17:10:37Z",
      "closedAt": "2023-11-15T17:10:37Z",
      "comments": []
    },
    {
      "number": 37,
      "id": "I_kwDOJmRsfc5010z2",
      "title": "VDAF dependency",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/37",
      "state": "CLOSED",
      "author": "jimouris",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Running `git submodule update --init --remote --recursive` works fine if we have committed the latest changes from the VDAF repository.\r\n\r\nHowever, if we have not committed the latest changes and clone the repository or pull the submodule then we end up with a modified `poc/draft-irtf-cfrg-vdaf` in the best case and broken code in the worst case.\r\n\r\nWe should fix the dependency in a certain commit and update it when we are sure it works.\r\n",
      "createdAt": "2023-10-24T23:50:55Z",
      "updatedAt": "2023-10-25T00:09:16Z",
      "closedAt": "2023-10-25T00:09:16Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "The version of the submodule that we use should be fully determined by the information in the repository.\r\n\r\nWhen I clone a fresh copy, I see that that tag `draft-irtf-cfrg-vdaf-07` is checked out:\r\n```\r\n[~]$ git clone --recurse-submodules git@github.com:jimouris/draft-mouris-cfrg-mastic.git\r\nCloning into 'draft-mouris-cfrg-mastic'...\r\nremote: Enumerating objects: 858, done.\r\nremote: Counting objects: 100% (413/413), done.\r\nremote: Compressing objects: 100% (141/141), done.\r\nremote: Total 858 (delta 290), reused 370 (delta 272), pack-reused 445\r\nReceiving objects: 100% (858/858), 333.69 KiB | 1.53 MiB/s, done.\r\nResolving deltas: 100% (565/565), done.\r\nSubmodule 'poc/draft-irtf-cfrg-vdaf' (https://github.com/cfrg/draft-irtf-cfrg-vdaf) registered for path 'poc/draft-irtf-cfrg-vdaf'\r\nCloning into '/Users/christopherpatton/draft-mouris-cfrg-mastic/poc/draft-irtf-cfrg-vdaf'...\r\nremote: Enumerating objects: 2164, done.\r\nremote: Counting objects: 100% (1089/1089), done.\r\nremote: Compressing objects: 100% (344/344), done.\r\nremote: Total 2164 (delta 878), reused 884 (delta 727), pack-reused 1075\r\nReceiving objects: 100% (2164/2164), 1.84 MiB | 10.46 MiB/s, done.\r\nResolving deltas: 100% (1472/1472), done.\r\nSubmodule path 'poc/draft-irtf-cfrg-vdaf': checked out 'ede21a4e7d56b3c1cc55f6efd2136cf26f64a724'\r\n[~]$ cd draft-mouris-cfrg-mastic/poc/draft-irtf-cfrg-vdaf\r\n[ede21a4][~/draft-mouris-cfrg-mastic/poc/draft-irtf-cfrg-vdaf]$ git log\r\n```",
          "createdAt": "2023-10-25T00:03:28Z",
          "updatedAt": "2023-10-25T00:03:28Z"
        },
        {
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "body": "Oh okay, you are right, thanks. Closing.",
          "createdAt": "2023-10-25T00:09:16Z",
          "updatedAt": "2023-10-25T00:09:16Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "I_kwDOJmRsfc51ViKA",
      "title": "Describing Other Aggregatable Functions in more details",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/39",
      "state": "OPEN",
      "author": "pratiksarkar93",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "jimouris",
        "pratiksarkar93"
      ],
      "labels": [
        "enhancement"
      ],
      "body": "I think we should explicitly mention (in Section 5.2 or Section 5.4?) how we can perform functions like Variance and Standard Deviation as it involves changing the beta value in a non-trivial way. \r\nbeta = (x, x^2) and the FLP needs to prove that the relation holds. ",
      "createdAt": "2023-10-30T14:57:48Z",
      "updatedAt": "2023-10-30T15:02:36Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "body": "I like this idea, it'd make Section 5 more readable by adding concrete examples like this. Can you lead this one? I can also help.",
          "createdAt": "2023-10-30T15:00:43Z",
          "updatedAt": "2023-10-30T15:00:43Z"
        },
        {
          "author": "pratiksarkar93",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure I can do that. ",
          "createdAt": "2023-10-30T15:02:36Z",
          "updatedAt": "2023-10-30T15:02:36Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "I_kwDOJmRsfc54YtX9",
      "title": "Joint randomness: Re-use the blind for different purposes",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/45",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As described in https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/185.",
      "createdAt": "2023-12-01T00:09:23Z",
      "updatedAt": "2023-12-07T20:11:40Z",
      "closedAt": "2023-12-07T20:11:40Z",
      "comments": []
    },
    {
      "number": 48,
      "id": "I_kwDOJmRsfc55FVS1",
      "title": "Fiat-Shamir vulnerability due to binding to wrong inputs",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/48",
      "state": "CLOSED",
      "author": "divergentdave",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "hannahdaviscrypto"
      ],
      "labels": [],
      "body": "Currently, joint randomness parts depend on each VIDPF key. This is insufficient, because it admits the following attack: An adversarial client generates VIDPF keys honestly for some input alpha, but then throws away the \"w\" part of the correction words in the public share. They can now compute the joint randomness parts, joint randomness seed, and joint randomness field elements, because they only depend on the blinds, VIDPF keys, and nonce (all chosen randomly by honest clients). Next, the dishonest client uses foreknowledge of the joint randomness values to select one of many FLP measurements that result in cancellation during the random linear combination part of the validity circuit. For example, if the circuit is Sum(8), I think they could fix the first seven measurement elements to be, say -1, and then solve to find what value of the eighth measurement element would result in a circuit output of zero. Treating the circuit as a univariate function of the eighth measurement element, it is a quadratic polynomial, known to the attacker, so they should have two zeros to choose from. Now, the attacker can program this adversarially-chosen measurement into the VIDPF by re-running VIDPF key generation, reusing the same initial seeds and alpha. Only the \"w\" parts of the correction words will change. The resulting report would pass one-hotness checks and path checks, because the core seeds/control bits of the VIDPF evaluation were not tampered with. The aggregators would extract the late-programmed adversarial measurement from their collective calls to `VIDPF.eval()` with each key and inputs `0b0` and `0b1`, and it would pass FLP verification by construction.\r\n\r\nThe straightforward fix for this is to compute `beta_share` for each aggregator, as in `Vidpf.eval()`, and replace `vidpf_init_seed[0]`/`vidpf_init_seed[1]` in joint randomness part derivation with each `beta_share`. That way, we would bind joint randomness to the FLP measurement, by binding to both measurement shares. (A less complicated but less efficient option would be to include shares of beta directly in each input share, and use those in both joint randomness derivation and FLP verification, rather than extracting shares of beta from evaluations at `0b0` and `0b1`, as is done currently.)",
      "createdAt": "2023-12-07T20:06:23Z",
      "updatedAt": "2024-01-12T22:11:39Z",
      "closedAt": "2024-01-12T22:11:39Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Quite a coincidence: we were just discussing this possibility today! Thanks for giving a concrete attack.\r\n\r\nWe're thinking of adding the VIDPF public share (including the correction words) to the binder. This was at least sufficient for Doplar (ia.cr/2023/130, Theorem 3); we suspect it's also sufficient here, but still need to do the proof.\r\n\r\nAdding `beta_share` to the binder would likely also work. I'll leave it to @hannahdaviscrypto to close this issue.",
          "createdAt": "2023-12-07T21:11:17Z",
          "updatedAt": "2023-12-07T23:01:44Z"
        }
      ]
    },
    {
      "number": 49,
      "id": "I_kwDOJmRsfc55FpJ0",
      "title": "Swap loop order in computation of path proof",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/49",
      "state": "CLOSED",
      "author": "divergentdave",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [],
      "body": "Currently, path proof computation iterates over prefixes in the outer loop, and levels in the inner loop. Switching this would improve the data locality of implementations, while still committing to all the same data. In particular, the first few iterations of an outer level loop would often hash the same field vector in consecutive iterations of the inner loop. (because, for example, at level 0, it would process node 0 several times, and then process node 1 several times) The field vector arithmetic could even be conditionally reused across inner loop iterations for a further speedup.",
      "createdAt": "2023-12-07T20:59:08Z",
      "updatedAt": "2024-09-16T22:49:39Z",
      "closedAt": "2024-09-16T22:49:39Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the implementation feedback, @divergentdave! I'll make this change and request your review when the PR is ready. It may not happen before the new year.",
          "createdAt": "2023-12-07T21:13:10Z",
          "updatedAt": "2023-12-07T21:13:10Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh is going to do the implementation of VIDPF in libprio (https://github.com/divviup/libprio-rs). Armando, we will want to resolve this issue as part of this, as this issue aligns the VIDPF spec with the current IDPF implementation.",
          "createdAt": "2024-01-12T17:33:40Z",
          "updatedAt": "2024-01-12T17:33:40Z"
        }
      ]
    },
    {
      "number": 51,
      "id": "I_kwDOJmRsfc55F8WC",
      "title": "Discourage branching on `next_ctrl`",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/51",
      "state": "CLOSED",
      "author": "divergentdave",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, the proof of concept branches on `next_ctrl.as_unsigned()` when computing `pi_proof`. This should be changed to use `correct()` or `next_ctrl.conditional_select()`, and we should add an implementation note comment, advising to avoid sidechannels, as with other uses of `next_ctrl`.",
      "createdAt": "2023-12-07T22:01:40Z",
      "updatedAt": "2024-09-12T19:46:01Z",
      "closedAt": "2024-09-12T19:46:01Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@armfazh similarly here. Please propose a change for the reference implementation of VIDPF that resolves this issue.",
          "createdAt": "2024-01-12T17:34:45Z",
          "updatedAt": "2024-01-12T17:34:45Z"
        }
      ]
    },
    {
      "number": 53,
      "id": "I_kwDOJmRsfc56DZ5n",
      "title": "Tracking issue: Use cases not covered by Poplar1",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/53",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is to track discussions in various places where Mastic fills a gap not currently covered by Poplar1.\r\n\r\n- [ ] Weighted heavy hitters: Suggested in https://eprint.iacr.org/2023/130.pdf, Section 6\r\n- [ ] Attribute-based metrics: https://github.com/ietf-wg-ppm/draft-ietf-ppm-dap/issues/489\r\n- [ ] Estimation of quantiles: https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/12 (not safe due to https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/273)\r\n- [ ] End evaluation early: The DAP draft describes a situation in which it is desirable to halt evaluation after the collector has detected that a prefix has reached a padding terminator. This is unsafe due to https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/273.",
      "createdAt": "2023-12-19T00:26:57Z",
      "updatedAt": "2024-03-14T17:27:42Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 55,
      "id": "I_kwDOJmRsfc58qUoy",
      "title": "Feature: Non-incremental mode of operation (at lower communication cost?)",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/55",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [],
      "body": "Suppose we know we were only going to use Mastic in \"non-incremental\" mode only, i.e., we only evaluate at inputs of length `BITS`. This is exactly the \"aggregate-by-label\" use case described in the draft.\r\n\r\nThe length of the public shares is linear in `BITS`. This is because we need to generate a correction word and VIDPF proof for every level of the tree. In non-incremental mode, could we tweak the construction so that the communication cost can be reduced? Perhaps not the VIDPF proofs, but maybe the correction words?\r\n\r\nThis would be useful if we wanted to use Mastic for large $\\beta$ values, e.g., a histogram with 100s-1000s of buckets.",
      "createdAt": "2024-01-19T21:47:34Z",
      "updatedAt": "2024-01-31T03:38:30Z",
      "closedAt": "2024-01-31T03:38:29Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "This doesn't work without significant changes.\r\n\r\nWe enforce the variant that each node we traverse is equal to the sum of its children. We can't enforce this invariant without computing words for intermediate nodes.\r\n\r\nOne thought is to bring back \"delayed input FLPs\" to check that either the sum of the leaves is a valid input or equal to 0.",
          "createdAt": "2024-01-31T03:38:30Z",
          "updatedAt": "2024-01-31T03:38:30Z"
        }
      ]
    },
    {
      "number": 58,
      "id": "I_kwDOJmRsfc6AvX32",
      "title": "Labels -> Attribute-Based Metrics",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/58",
      "state": "CLOSED",
      "author": "jimouris",
      "authorAssociation": "OWNER",
      "assignees": [
        "cjpatton"
      ],
      "labels": [],
      "body": "Update the draft language from `labels` to attribute-based metrics.",
      "createdAt": "2024-02-28T21:30:50Z",
      "updatedAt": "2024-02-29T01:19:53Z",
      "closedAt": "2024-02-29T01:19:53Z",
      "comments": []
    },
    {
      "number": 59,
      "id": "I_kwDOJmRsfc6AvX8N",
      "title": "Add Applications",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/59",
      "state": "CLOSED",
      "author": "jimouris",
      "authorAssociation": "OWNER",
      "assignees": [
        "jimouris"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2024-02-28T21:31:04Z",
      "updatedAt": "2024-02-29T01:58:25Z",
      "closedAt": "2024-02-29T01:58:25Z",
      "comments": []
    },
    {
      "number": 62,
      "id": "I_kwDOJmRsfc6Tng-D",
      "title": "Double the length of the joint randomness seed",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/62",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/319#issuecomment-2299836818.",
      "createdAt": "2024-08-20T22:03:47Z",
      "updatedAt": "2024-08-27T18:51:44Z",
      "closedAt": "2024-08-27T18:51:44Z",
      "comments": []
    },
    {
      "number": 71,
      "id": "I_kwDOJmRsfc6W3oJc",
      "title": "Add draft versioning",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/71",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [],
      "body": "We're currently use `VERSION` from draft-irtf-cfrg-vdaf for domain separation. Eventually we'll need to control versioning here so that we can break compatibility across drafts.",
      "createdAt": "2024-09-17T13:24:56Z",
      "updatedAt": "2024-09-18T19:07:49Z",
      "closedAt": "2024-09-18T19:07:49Z",
      "comments": [
        {
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "body": "Is this just a matter of adding a constant on the code that indicates which draft version this is or something else?",
          "createdAt": "2024-09-17T13:26:16Z",
          "updatedAt": "2024-09-17T13:26:16Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, as well as replacing calls to `format_dst()` with our own thing.",
          "createdAt": "2024-09-17T13:29:42Z",
          "updatedAt": "2024-09-17T13:29:42Z"
        }
      ]
    },
    {
      "number": 72,
      "id": "I_kwDOJmRsfc6W6FlL",
      "title": "Generate test vectors",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/72",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2024-09-17T18:21:47Z",
      "updatedAt": "2024-09-17T19:02:12Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 73,
      "id": "I_kwDOJmRsfc6W6NOm",
      "title": "Choices for `PATH_PROOF_INIT`",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/73",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "`PATH_PROOF_INIT` is used as the initial path proof, which is updated with node proof computed by each call to `eval_next()`. It appears we're free to set this to any public value:\r\n* The original [de Castro and Polychroniadou paper](https://eprint.iacr.org/2021/580) sets this to the \"correction seed\" ($\\mathsf{cs}$ in Algorithm 3).\r\n* The PLASMA paper sets this to to \"0\" (the all zero string).\r\n* We currently set it to a salt.\r\n\r\nI had the thought that we could also derive this from the VDAF verification key so that it is pseudorandom from the point of view of the adversary (i.e., the malicious client). I wonder if this could provide some benefit in terms of security.\r\n\r\n",
      "createdAt": "2024-09-17T18:40:53Z",
      "updatedAt": "2024-09-18T19:08:35Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 4,
      "id": "PR_kwDOJmRsfc5TPWdW",
      "title": "Rename vdpf.py -> vdpf.sage",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/4",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The Makefile expects a file named `vdpf.sage`. It looks like `vdpf.py` is in fact valid Sage, so rename the file to match the Makefile. ",
      "createdAt": "2023-06-17T00:40:17Z",
      "updatedAt": "2023-10-13T18:38:26Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "3b48931276f539ad951d24f992f8b4d0b3edc7e9",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/fixmake",
      "headRefOid": "bda9e9a09f86fcb997c45327f07a1f78d6d3da43",
      "closedAt": "2023-06-21T22:03:56Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "body": "Oops. I actually removed any sage code from that file but forgot to update the makefile.\n\nIt uses rings instead of fields now as you had suggested.",
          "createdAt": "2023-06-17T00:42:36Z",
          "updatedAt": "2023-06-17T00:42:36Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Ahh! Then go ahead and close this PR and make the appropriate change :)",
          "createdAt": "2023-06-17T01:10:15Z",
          "updatedAt": "2023-06-17T01:10:15Z"
        },
        {
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "body": "I fixed the `Makefile` in 7ac1522",
          "createdAt": "2023-06-21T22:03:55Z",
          "updatedAt": "2023-06-21T22:03:55Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 9,
      "id": "PR_kwDOJmRsfc5XX6Ii",
      "title": "Restructure reference code",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/9",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #1.\r\n\r\n* Remove the code copied from the draft-irtf-cfrg-vdaf repo with imports from a submodule checked out at tag `draft-irtf-cfrg-vdaf-06`.\r\n\r\n* Harmonize `Ring` API with `Field`. The class constructor should return a ring element instead of a ring element factory. To define a ring with a specific modulus, we just define a subclass for it. This was necessary in order to use `Ring` with `next_vec()` without modifying the `Prg` API.\r\n\r\n  I also took a couple liberties here that are not strictly needed:\r\n\r\n    * Reduce the encoding size for `Ring16` from 8 bytes to 2.\r\n\r\n    * Remove the `one()` and `zero()` methods\r\n\r\n    * Make `zeros()` a class method\r\n\r\n    * Add a class method `one()` for constructing a vector of 1s",
      "createdAt": "2023-08-07T20:38:26Z",
      "updatedAt": "2023-08-09T18:36:34Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "cfdac6adba6012bf5ef41eadb7aec7bcf3d8349f",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/1/cleanup-poc",
      "headRefOid": "385245830dbdd70415f41b3f8e721ecd5c6ef149",
      "closedAt": "2023-08-09T18:36:33Z",
      "mergedAt": "2023-08-09T18:36:33Z",
      "mergedBy": "jimouris",
      "mergeCommit": {
        "oid": "1e34b3c15505520f2c5e865365d856bd096663aa"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc5dl_A9",
          "commit": {
            "abbreviatedOid": "3852458"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "I left some minor comments. Everything looks good, thanks for working on this!",
          "createdAt": "2023-08-09T17:46:44Z",
          "updatedAt": "2023-08-09T17:53:40Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "These two are Python files so we can just run `python ring.py` and remove sage",
              "createdAt": "2023-08-09T17:46:44Z",
              "updatedAt": "2023-08-09T17:53:40Z"
            },
            {
              "originalPosition": 14,
              "body": "Is it possible here for the `MODULUS` to have not been initialized yet? For example, if you define a Ring class and forget to set it up. Maybe we could add an assert?",
              "createdAt": "2023-08-09T17:49:55Z",
              "updatedAt": "2023-08-09T17:53:40Z"
            },
            {
              "originalPosition": 77,
              "body": "Nice, I like this",
              "createdAt": "2023-08-09T17:50:19Z",
              "updatedAt": "2023-08-09T17:53:40Z"
            },
            {
              "originalPosition": 4,
              "body": "Is this to detect the files from the submodule? Cool, thanks for setting this up!",
              "createdAt": "2023-08-09T17:51:48Z",
              "updatedAt": "2023-08-09T17:53:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5dmMzK",
          "commit": {
            "abbreviatedOid": "3852458"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-09T18:25:28Z",
          "updatedAt": "2023-08-09T18:25:32Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I don't remember why, but there's a reason you can't do that :/ \r\n\r\nFWIW this is what we do in the VDAF draft as well: https://github.com/cfrg/draft-irtf-cfrg-vdaf/blob/main/poc/Makefile",
              "createdAt": "2023-08-09T18:25:32Z",
              "updatedAt": "2023-08-09T18:25:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5dmN7G",
          "commit": {
            "abbreviatedOid": "3852458"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-09T18:28:11Z",
          "updatedAt": "2023-08-09T18:28:11Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "if you try to construct `Ring` directly, e.g., call `Ring(23)`, you get\r\n```\r\nAttributeError: 'Ring' object has no attribute 'MODULUS'\r\n```\r\n\r\nWe could do something like `assert self.getattr(\"MODULUS\") != None`?",
              "createdAt": "2023-08-09T18:28:11Z",
              "updatedAt": "2023-08-09T18:28:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5dmOZB",
          "commit": {
            "abbreviatedOid": "3852458"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-09T18:29:30Z",
          "updatedAt": "2023-08-09T18:29:30Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I don't really understand the details, this was from StackOverflow :D\r\n\r\nPerhaps `path` is the system's `PATH` environment variable and Python can import any module it finds in `PATH`? Just guessing",
              "createdAt": "2023-08-09T18:29:30Z",
              "updatedAt": "2023-08-09T18:29:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5dmQ3_",
          "commit": {
            "abbreviatedOid": "3852458"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-09T18:36:17Z",
          "updatedAt": "2023-08-09T18:36:17Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Oh okay, that's fine then, just wanted to double-check.",
              "createdAt": "2023-08-09T18:36:17Z",
              "updatedAt": "2023-08-09T18:36:17Z"
            }
          ]
        }
      ]
    },
    {
      "number": 13,
      "id": "PR_kwDOJmRsfc5Z58ZT",
      "title": "Update outline of the draft",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/13",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-09-08T19:22:38Z",
      "updatedAt": "2023-09-15T16:53:28Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "6e471c7f40bb70daaa857b1660ccef390fff2376",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/outline",
      "headRefOid": "f427a9c761660320d017302a08fe486a57d70caa",
      "closedAt": "2023-09-15T16:53:28Z",
      "mergedAt": "2023-09-15T16:53:28Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "171849408195fdeed06570149c29a8f2d181c539"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc5gcwzO",
          "commit": {
            "abbreviatedOid": "a58ef3e"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-08T19:41:08Z",
          "updatedAt": "2023-09-08T19:41:09Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "@hannahdaviscrypto, @pratiksarkar93, @jimouris what's your take here? I'm not sure we considered this yet.",
              "createdAt": "2023-09-08T19:41:08Z",
              "updatedAt": "2023-09-08T19:41:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5gdSrz",
          "commit": {
            "abbreviatedOid": "a58ef3e"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-08T21:16:56Z",
          "updatedAt": "2023-09-08T21:16:56Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "The communication reduction would be a contribution, not a mode, right? Same for the third. I guess line 101 can be updated to solve this.",
              "createdAt": "2023-09-08T21:16:56Z",
              "updatedAt": "2023-09-08T21:16:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5gdjNN",
          "commit": {
            "abbreviatedOid": "a58ef3e"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-08T21:49:03Z",
          "updatedAt": "2023-09-08T21:49:06Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I think of this as a \"mode of operation\" because it may not always be used. There are two reasons:\r\n1. Accommodating this requires changes to the higher-level protocol: one has to implement the new \"interactive aggregation\" API. This will require changes to DAP.\r\n2. Not batching aggregation and instead checking each report individually is a lot simpler to implement because filtering reports doesn't require exploring the Merkle tree.",
              "createdAt": "2023-09-08T21:49:03Z",
              "updatedAt": "2023-09-08T21:49:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5hHlFi",
          "commit": {
            "abbreviatedOid": "a58ef3e"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-15T16:53:14Z",
          "updatedAt": "2023-09-15T16:53:15Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "We decided this proposal doesn't make sense.",
              "createdAt": "2023-09-15T16:53:14Z",
              "updatedAt": "2023-09-15T16:53:15Z"
            }
          ]
        }
      ]
    },
    {
      "number": 14,
      "id": "PR_kwDOJmRsfc5c70h9",
      "title": "poc: Clean up",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/14",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "* Remove vdpf.py\r\n* Remove ring.py and use concrete fields instead\r\n* Align import formatting with base draft",
      "createdAt": "2023-10-16T18:41:21Z",
      "updatedAt": "2023-10-16T18:56:34Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "acfc2428a61b9401286081e766db65c301229d3b",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/poc-cleanup",
      "headRefOid": "b253193217020a9b36ee752eb0509ce388c5e890",
      "closedAt": "2023-10-16T18:49:20Z",
      "mergedAt": "2023-10-16T18:49:20Z",
      "mergedBy": "jimouris",
      "mergeCommit": {
        "oid": "85c624e845e98d2bb982d8d567d41e1e428f876e"
      },
      "comments": [
        {
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "body": "Everything looks good to me except for one small comment.\r\n\r\nIs the end goal only Mastic (:= plasma2 + FLPs)? If yes, then removing the rings is fine. If we end up having both Mastic and plasma2, then we can keep the rings as fields are not needed there. But as you mentioned, for simplicity it makes more sense to just have Fields everywhere.\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2023-10-16T18:49:15Z",
          "updatedAt": "2023-10-16T18:49:15Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc5kLnn7",
          "commit": {
            "abbreviatedOid": "b253193"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "Looks good!",
          "createdAt": "2023-10-16T18:56:34Z",
          "updatedAt": "2023-10-16T18:56:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 15,
      "id": "PR_kwDOJmRsfc5c8DNS",
      "title": "Clean up the vidpf API and some internals",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/15",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-16T19:23:52Z",
      "updatedAt": "2023-12-07T18:19:10Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "85c624e845e98d2bb982d8d567d41e1e428f876e",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/vidpf",
      "headRefOid": "f0693ac38d732d729892f5dc5ec289956101b36d",
      "closedAt": "2023-10-16T19:38:51Z",
      "mergedAt": "2023-10-16T19:38:51Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "56ddf1e4d5efa00ccb68acd13f1cfa6f4ab01a86"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> What is the purpose of the binder?\r\n\r\nIt's used with the fixed-key AES mode. We pass the VDAF nonce here in order to diversify the key streams across reports.",
          "createdAt": "2023-10-16T19:32:36Z",
          "updatedAt": "2023-10-16T19:32:36Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc5kLzhJ",
          "commit": {
            "abbreviatedOid": "f0693ac"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "What is the purpose of the binder?",
          "createdAt": "2023-10-16T19:29:04Z",
          "updatedAt": "2023-10-16T19:29:04Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJmRsfc5kLztw",
          "commit": {
            "abbreviatedOid": "f0693ac"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-16T19:29:38Z",
          "updatedAt": "2023-10-16T19:29:38Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJmRsfc5kL1WO",
          "commit": {
            "abbreviatedOid": "f0693ac"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-16T19:34:29Z",
          "updatedAt": "2023-10-16T19:34:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 16,
      "id": "PR_kwDOJmRsfc5c8TKa",
      "title": "vipdf: Fix unit tests",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/16",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The unit tests seem to expect there to a beta for each level of the tree, but in fact the same beta is used for each level.",
      "createdAt": "2023-10-16T20:08:13Z",
      "updatedAt": "2023-12-07T18:19:10Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "56ddf1e4d5efa00ccb68acd13f1cfa6f4ab01a86",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/vidpf-fix-test",
      "headRefOid": "428ca6133fac1cac25a169d9424d374152830f6b",
      "closedAt": "2023-10-16T20:13:00Z",
      "mergedAt": "2023-10-16T20:13:00Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "0268e1dcc29d77980a00ca4f092920fd4319ab49"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc5kMDoE",
          "commit": {
            "abbreviatedOid": "428ca61"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-16T20:12:49Z",
          "updatedAt": "2023-10-16T20:12:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 18,
      "id": "PR_kwDOJmRsfc5c8Zix",
      "title": "vidpf: Add parameter for \"incremental mode\"",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/18",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This will be useful for Mastic, where we need to distinguish between doing heavy hitters from the root or aggregation-by-labels at the leaves. Also, I suspect we'll be able to improve communication cost in case Vidpf is used in non-incremental mode.",
      "createdAt": "2023-10-16T20:26:58Z",
      "updatedAt": "2023-12-07T18:19:11Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "0268e1dcc29d77980a00ca4f092920fd4319ab49",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/vidpf-modes",
      "headRefOid": "9c6d73e6b8e031125107eb592ddb8c24083d0ba8",
      "closedAt": "2023-10-16T21:01:17Z",
      "mergedAt": "2023-10-16T21:01:17Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "2dfe96bec07205f5253b1682994f8473efe6f6f5"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> What's the point of the incremental mode?\r\n\r\nAs described in the commit message: to distinguish between using Mastic for \"heaavy hitters\" and using Mastic for \"aggegation by labels\". In the former case, we want to check the proof when we start at the root; for the latter we want to check the proof and only evaluate the leaves.\r\n\r\nAlso, it should be possible to optimize the size of the public share if we we're not in incremental mode, right?\r\n",
          "createdAt": "2023-10-16T20:34:41Z",
          "updatedAt": "2023-10-16T20:34:41Z"
        },
        {
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "body": "Oh okay, I see. Maybe we can add it when we need it? It's never read now that's why I asked.\r\n\r\n> Also, it should be possible to optimize the size of the public share if we're not in incremental mode, right?\r\n\r\nWhat optimization do you have in mind?",
          "createdAt": "2023-10-16T20:39:59Z",
          "updatedAt": "2023-10-16T20:39:59Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> Oh okay, I see. Maybe we can add it when we need it? It's never read now that's why I asked.\r\n> \r\n> > Also, it should be possible to optimize the size of the public share if we're not in incremental mode, right?\r\n\r\nI need it for Mastic, which I'm working on now. (All of these PRs today are incremental improvements towards the big one.)\r\n\r\n\r\n> What optimization do you have in mind?\r\n\r\nIt's been a while, since I thought about this, so I could be wrong: But isn't it possible to avoid sending a correction word for every level we know we're not going to evaluate (i.e., obtain output shares for)?\r\n",
          "createdAt": "2023-10-16T20:46:51Z",
          "updatedAt": "2023-10-16T20:46:51Z"
        },
        {
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "body": "> It's been a while, since I thought about this, so I could be wrong: But isn't it possible to avoid sending a correction word for every level we know we're not going to evaluate (i.e., obtain output shares for)?\r\n\r\nHmm, let's discuss about this on Friday, I hadn't considered this case.",
          "createdAt": "2023-10-16T20:49:23Z",
          "updatedAt": "2023-10-16T20:49:23Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Added a reference to https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/19.",
          "createdAt": "2023-10-16T21:00:52Z",
          "updatedAt": "2023-10-16T21:00:52Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc5kMJje",
          "commit": {
            "abbreviatedOid": "82580ec"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "CHANGES_REQUESTED",
          "body": "What's the point of the incremental mode?",
          "createdAt": "2023-10-16T20:29:14Z",
          "updatedAt": "2023-10-16T20:29:14Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJmRsfc5kMQTS",
          "commit": {
            "abbreviatedOid": "9c6d73e"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-16T20:49:31Z",
          "updatedAt": "2023-10-16T21:00:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 20,
      "id": "PR_kwDOJmRsfc5c9T3W",
      "title": "Implement \"basic\" Mastic",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/20",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Stacked on #22.\r\n\r\nAdd a new module to `poc` that implements the Mastic VDAF. This VDAF is similar to Poplar1 except that instead of aggregating counters, Mastic can aggregate any data type that is compatible with FlpGeneric.\r\n\r\nMastic operates in one of two \"modes\", depending on how the VIDPF is configured. In \"incremental mode\", the FLP is checked when evaluating at the first level of the VIDPF tree; in non-incremental mode, the FLP is checked when evaluating the last level of the tree (all intermediate levels are disabled).\r\n\r\nWhen verifying the FLP, the encoded measurement (i.e., `beta`) is computed by evaluating the VIDPF at both child nodes of the root and summing the output shares. By one-hot verifiability, this sum is equal to value claimed by the Client; by path verifiability, checking this value is sufficient each node on the `alpha` path is guaranteed to have the same value.\r\n\r\nThe code is incomplete but is sufficient to illustrate the basic features we want. Some things to do:\r\n\r\n* Add support for circuits with joint randomness\r\n\r\n* Specify `PublicShare` and `InputShare`\r\n\r\n* Decide whether to bind the query randomness to the VIDPF mode\r\n\r\n* Implement message serialization",
      "createdAt": "2023-10-17T00:12:57Z",
      "updatedAt": "2023-12-07T18:19:13Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "b9173fdcb87245a9a7bf5774f8be6d3c42278dd5",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/poc-mastic",
      "headRefOid": "39a4a56b7c662ef7754f2ee408bfe983817e9913",
      "closedAt": "2023-10-18T20:50:02Z",
      "mergedAt": "2023-10-18T20:50:02Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "15aab2f1fefc273d50c5b7cb521b3b8ecedfc5d9"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased (on #22) and squashed.",
          "createdAt": "2023-10-17T23:41:23Z",
          "updatedAt": "2023-10-17T23:41:23Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased.",
          "createdAt": "2023-10-18T20:49:24Z",
          "updatedAt": "2023-10-18T20:49:24Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc5kM_UW",
          "commit": {
            "abbreviatedOid": "23b8ba8"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T00:13:54Z",
          "updatedAt": "2023-10-17T00:23:54Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "@jimouris please confirm that \"one-hot\" and \"path\" verifiability are properties claimed by VIDPF (and suggest alternative wording if necessary).",
              "createdAt": "2023-10-17T00:13:54Z",
              "updatedAt": "2023-10-17T00:38:29Z"
            },
            {
              "originalPosition": 133,
              "body": "@jimouris, @hannahdaviscrypto what would you like to do here? In the Overleaf version of the protocol, we evaluate the VIDPF \"at the root\" (i.e.,at the empty string $\\varepsilon$), but this doesn't seem to be possible with the current VIDPF API. (I think Hannah was working on some changes to VIDPF that would have allowed this, but it wasn't compiling and I'm not sure how far she got with it.)\r\n\r\nEvaluating at both children and then summing (as we do here) has a bit of CPU overhead. However it also has some advantages:\r\n1. It's simple to specify\r\n2. It has zero communication overhead. (If evaluating at the root, would we need to send more information in the public share so that the Aggregators can reconstruct shares of the output?)\r\n3. It involves at most one more call to `Vidpf.eval_next()` than is necessary. (If `0` is not a prefix of any string in `prefixes`, then it'll be a waste to evaluate it.)",
              "createdAt": "2023-10-17T00:23:15Z",
              "updatedAt": "2023-10-17T00:23:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kRtFw",
          "commit": {
            "abbreviatedOid": "124433b"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T13:25:39Z",
          "updatedAt": "2023-10-17T13:25:40Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Nit: Can you add a comment to describe what these three are? Also, maybe an `enum` would be cleaner?",
              "createdAt": "2023-10-17T13:25:40Z",
              "updatedAt": "2023-10-17T13:25:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kRuKN",
          "commit": {
            "abbreviatedOid": "124433b"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T13:27:26Z",
          "updatedAt": "2023-10-17T13:27:27Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "What is the last argument [] here?",
              "createdAt": "2023-10-17T13:27:27Z",
              "updatedAt": "2023-10-17T13:27:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kRu8a",
          "commit": {
            "abbreviatedOid": "124433b"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T13:28:45Z",
          "updatedAt": "2023-10-17T13:28:45Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "Rename to `INCREMENTAL_MODE`.",
              "createdAt": "2023-10-17T13:28:45Z",
              "updatedAt": "2023-10-17T13:28:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kR38V",
          "commit": {
            "abbreviatedOid": "124433b"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T13:41:19Z",
          "updatedAt": "2023-10-17T13:41:19Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "> It is sufficient to check the proof over the sum of the outputs, since the one-hot verifiability property of VIDPF ensures that exactly one of the children is equal to the encoded `beta` (and the other is equal to `0`).\r\n\r\nYeah, that's correct. Just to clarify, this holds if the proofs from both servers are equal.\r\n\r\n> It is sufficient to check the proof just once since the path verifiability property of VIDPF ensures that the same `beta` is propagated along the entire `alpha` path.\r\n\r\nThe path verifiability does not rely on the VIDPF proofs, we get this from the PLASMA parent-children checks. I'd rephrase it to:\r\n```\r\nPath Verifiability: This property ensures that the same `beta` is propagated along the entire `alpha` path. Additionally, for all other evaluations that are not `alpha` (or prefixes of it), we get zero.\r\n```\r\n\r\nI'd also add the **One-hot Verifiability:** and **Path Verifiability:** in front of each to make it clear that we rely on these properties.\r\n",
              "createdAt": "2023-10-17T13:41:19Z",
              "updatedAt": "2023-10-17T13:41:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kR5vr",
          "commit": {
            "abbreviatedOid": "124433b"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T13:44:16Z",
          "updatedAt": "2023-10-17T13:44:17Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "I prefer the latter as it's significantly cleaner. (This is also what we're doing in the Rust implementation). After we evaluate the children, we do the check, and we can also store them to have them ready for the next level. In the next iteration, we evaluate their children, and so on.\r\n\r\nFor simplicity, we can avoid the caching altogether from the draft if it makes the code more readable.",
              "createdAt": "2023-10-17T13:44:16Z",
              "updatedAt": "2023-10-17T13:44:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kR7RY",
          "commit": {
            "abbreviatedOid": "124433b"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T13:46:54Z",
          "updatedAt": "2023-10-17T13:46:54Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "How about?\r\n```python\r\nraise Exception('Path Verifiability Error: The output vector is not one-hot.')\r\n```",
              "createdAt": "2023-10-17T13:46:54Z",
              "updatedAt": "2023-10-17T13:46:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kR7pj",
          "commit": {
            "abbreviatedOid": "124433b"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T13:47:27Z",
          "updatedAt": "2023-10-17T13:47:27Z",
          "comments": [
            {
              "originalPosition": 187,
              "body": "Prio3?",
              "createdAt": "2023-10-17T13:47:27Z",
              "updatedAt": "2023-10-17T13:47:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kR-Zd",
          "commit": {
            "abbreviatedOid": "124433b"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T13:52:05Z",
          "updatedAt": "2023-10-17T13:52:05Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Who runs `is_valid()`? I'm a bit confused about what it checks.",
              "createdAt": "2023-10-17T13:52:05Z",
              "updatedAt": "2023-10-17T13:52:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kSBgU",
          "commit": {
            "abbreviatedOid": "124433b"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T13:57:12Z",
          "updatedAt": "2023-10-17T13:57:12Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "`out_share[0]` and `out_share[1]` are the left and right children, right? Then we add them into `meas_share` and check the FLP, correct? But the full evaluation happens in lines 105-112? Shouldn't we have a check like:\r\n\r\n```python\r\nif level == 0:\r\n# check FLP\r\nelse:\r\n# do parent-children checks\r\n```",
              "createdAt": "2023-10-17T13:57:12Z",
              "updatedAt": "2023-10-17T13:57:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kSCKx",
          "commit": {
            "abbreviatedOid": "124433b"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "CHANGES_REQUESTED",
          "body": "Looks good, thanks for putting it together! I added some suggestions, some questions, and some nits.",
          "createdAt": "2023-10-17T13:58:18Z",
          "updatedAt": "2023-10-17T13:58:18Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJmRsfc5kSYXQ",
          "commit": {
            "abbreviatedOid": "23b8ba8"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T14:33:37Z",
          "updatedAt": "2023-10-17T14:33:37Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "Ah, so it sounds like we still need to implement the parent-children checks for Mastic?",
              "createdAt": "2023-10-17T14:33:37Z",
              "updatedAt": "2023-10-17T14:33:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kSZQt",
          "commit": {
            "abbreviatedOid": "124433b"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T14:34:40Z",
          "updatedAt": "2023-10-17T14:34:41Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "joint randomness (currently empty)",
              "createdAt": "2023-10-17T14:34:41Z",
              "updatedAt": "2023-10-17T14:34:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kSZoq",
          "commit": {
            "abbreviatedOid": "23b8ba8"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T14:35:19Z",
          "updatedAt": "2023-10-17T14:35:20Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "can you send a PR with the necessary change to `vidpf`?",
              "createdAt": "2023-10-17T14:35:19Z",
              "updatedAt": "2023-10-17T14:35:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kSaER",
          "commit": {
            "abbreviatedOid": "124433b"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T14:36:03Z",
          "updatedAt": "2023-10-17T14:36:03Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "This isn't Path Verifiability though, right? This is One-hot Verifiability.",
              "createdAt": "2023-10-17T14:36:03Z",
              "updatedAt": "2023-10-17T14:36:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kSbJx",
          "commit": {
            "abbreviatedOid": "124433b"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T14:37:43Z",
          "updatedAt": "2023-10-17T14:37:43Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "See https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-07#section-5.3",
              "createdAt": "2023-10-17T14:37:43Z",
              "updatedAt": "2023-10-17T14:37:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kSb3z",
          "commit": {
            "abbreviatedOid": "23b8ba8"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T14:38:52Z",
          "updatedAt": "2023-10-17T14:38:52Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "Err actually what do you mean by \"latter\"? If you want to evaluate at $\\varepsilon$ (I agree this is cleaner) then I believe we need to change the API. Or am I misunderstanding something?",
              "createdAt": "2023-10-17T14:38:52Z",
              "updatedAt": "2023-10-17T14:38:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kSckG",
          "commit": {
            "abbreviatedOid": "124433b"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T14:40:04Z",
          "updatedAt": "2023-10-17T14:40:04Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "I claim that you always want to do VIDPF verification and only do FLP verification once.",
              "createdAt": "2023-10-17T14:40:04Z",
              "updatedAt": "2023-10-17T14:40:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kSwHZ",
          "commit": {
            "abbreviatedOid": "23b8ba8"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T15:11:20Z",
          "updatedAt": "2023-10-17T15:11:20Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "Correct. We only need 1 FLP to check \\epsilon (or left and right) as you did, and then we'll need the parent-children checks to check that this beta value is propagated correctly. Something like: https://github.com/jimouris/mastic/blob/main/src/collect.rs#L246 ",
              "createdAt": "2023-10-17T15:11:20Z",
              "updatedAt": "2023-10-17T15:11:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kSxM0",
          "commit": {
            "abbreviatedOid": "23b8ba8"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T15:13:17Z",
          "updatedAt": "2023-10-17T15:13:17Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "I meant that I prefer evaluating the 2 children. VIDPF won't need any changes either.",
              "createdAt": "2023-10-17T15:13:17Z",
              "updatedAt": "2023-10-17T15:13:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kSyEU",
          "commit": {
            "abbreviatedOid": "124433b"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T15:14:54Z",
          "updatedAt": "2023-10-17T15:14:54Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "Correct, I meant *One-hot* verifiability.",
              "createdAt": "2023-10-17T15:14:54Z",
              "updatedAt": "2023-10-17T15:14:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kS0ES",
          "commit": {
            "abbreviatedOid": "124433b"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T15:18:26Z",
          "updatedAt": "2023-10-17T15:18:26Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "I might misunderstood something. By VIDPF verification you mean check the proofs? Yes, we should do that at every level. Additionally, we'd need to do the parent-children checks at every level to make sure that the beta value (which we verified is valid in level 0) is propagated correctly down the tree.",
              "createdAt": "2023-10-17T15:18:26Z",
              "updatedAt": "2023-10-17T15:18:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kS7uI",
          "commit": {
            "abbreviatedOid": "124433b"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T15:29:54Z",
          "updatedAt": "2023-10-17T15:29:54Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "OHhhh hmmm I see... I need to go figure out how the parent-children checks work :) I'll take a look at the Overleaf and update this PR.\r\n\r\nJust to clarify: path verifiability is not an intrinsic property of the VIDPF proofs, but something we do on top of VIDPF evaluation?",
              "createdAt": "2023-10-17T15:29:54Z",
              "updatedAt": "2023-10-17T15:29:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kTDez",
          "commit": {
            "abbreviatedOid": "124433b"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T15:41:52Z",
          "updatedAt": "2023-10-17T15:41:52Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "Exactly. From Overleaf:\r\n\r\n> So far, with VIDPF, the servers can verify that there is at most one non-zero output at each level. However, VIDPFs alone are not sufficient to guarantee that the keys are well formed. The servers still need to verify that: a) the non-zero values of the client are\r\nacross a single path in the binary tree, and b) the value of the root node is correctly propagated down the VIDPF tree. We formalize these requirements as an additional property: Path Verifiability: blah blah blah\r\n\r\nThe idea is that we want $y^\u03b3 - (y^{\u03b3||0} + y^{\u03b3||1}) = 0$. Then the following should hold:\r\n$y_0^\u03b3 - y_0^{\u03b3||0} - y_0^{\u03b3||1} = - y_1^\u03b3 + y_1^{\u03b3||0} + y_1^{\u03b3||1}$. So each server computes their part (server 0 computes the left and server 1 computes the right) and they check if it's correct.",
              "createdAt": "2023-10-17T15:41:52Z",
              "updatedAt": "2023-10-17T15:41:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kTErE",
          "commit": {
            "abbreviatedOid": "124433b"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T15:43:46Z",
          "updatedAt": "2023-10-17T15:43:47Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "Ohhhh that's so beautifully simple. I think you already mentioned this at some point but it didn't bleed through.\r\n\r\nTo implement this, I think we need to to take @hannahdaviscrypto's changes to `vidpf`. I'll work on this.",
              "createdAt": "2023-10-17T15:43:46Z",
              "updatedAt": "2023-10-17T15:43:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kTGxc",
          "commit": {
            "abbreviatedOid": "124433b"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T15:47:36Z",
          "updatedAt": "2023-10-17T15:47:36Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "Thanks :) It might make more sense to do it on the mastic-vdaf level rather than in VIDPF. This might help as well: https://github.com/jimouris/mastic/blob/main/src/collect.rs#L246",
              "createdAt": "2023-10-17T15:47:36Z",
              "updatedAt": "2023-10-17T15:47:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kVGho",
          "commit": {
            "abbreviatedOid": "34954f4"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-17T19:56:38Z",
          "updatedAt": "2023-10-17T19:56:38Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJmRsfc5kWngg",
          "commit": {
            "abbreviatedOid": "124433b"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T23:39:58Z",
          "updatedAt": "2023-10-17T23:39:59Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "I ended up extending VIDPF (see top-comment for justification): https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/22",
              "createdAt": "2023-10-17T23:39:59Z",
              "updatedAt": "2023-10-17T23:39:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kWpqS",
          "commit": {
            "abbreviatedOid": "23b8ba8"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T23:52:29Z",
          "updatedAt": "2023-10-17T23:52:29Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "Done.",
              "createdAt": "2023-10-17T23:52:29Z",
              "updatedAt": "2023-10-17T23:52:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5ked5o",
          "commit": {
            "abbreviatedOid": "1a8e1d5"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T17:25:41Z",
          "updatedAt": "2023-10-18T17:25:55Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "Do we need both this eval call and the one in 152?",
              "createdAt": "2023-10-18T17:25:41Z",
              "updatedAt": "2023-10-18T17:25:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kfmxq",
          "commit": {
            "abbreviatedOid": "1a8e1d5"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T19:52:42Z",
          "updatedAt": "2023-10-18T19:52:42Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "We could eliminate it, but we'd need to make changes to `Vidpf`. In particular, we need to be able to compute our share of `beta`. Perhaps we could have `Vidpf` return `prefix_tree_share`?",
              "createdAt": "2023-10-18T19:52:42Z",
              "updatedAt": "2023-10-18T19:52:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kfrgT",
          "commit": {
            "abbreviatedOid": "1a8e1d5"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T19:56:46Z",
          "updatedAt": "2023-10-18T19:56:46Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "What do you mean, why? Isn't that the `out_share`?",
              "createdAt": "2023-10-18T19:56:46Z",
              "updatedAt": "2023-10-18T19:56:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kftAO",
          "commit": {
            "abbreviatedOid": "1a8e1d5"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T19:59:34Z",
          "updatedAt": "2023-10-18T19:59:34Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "To check the FLP we have to compute a share of `beta`. The way we do that here is by evaluating the VIDPF at the children of the root and adding them up.",
              "createdAt": "2023-10-18T19:59:34Z",
              "updatedAt": "2023-10-18T19:59:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kfuLq",
          "commit": {
            "abbreviatedOid": "1a8e1d5"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-18T20:00:44Z",
          "updatedAt": "2023-10-18T20:00:44Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJmRsfc5kfxcL",
          "commit": {
            "abbreviatedOid": "39a4a56"
          },
          "author": "hannahedavis",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T20:07:42Z",
          "updatedAt": "2023-10-18T21:07:17Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "Correct me if I'm wrong but this seems like we are doing the parent-child check for the entire tree in every evaluation instead of just the children at the target level. If we're intending to do something like the fast-start design then this is probably the way to go, but if we intend to run Mastic level-by-level then this will be a lot of redundant hashing. ",
              "createdAt": "2023-10-18T20:24:02Z",
              "updatedAt": "2023-10-18T21:07:17Z"
            },
            {
              "originalPosition": 160,
              "body": "I think it would be help clarity to add a comment here to make it clear that this is the value of the root node, since we're obtaining it indirectly via the new VIDPF interface. \r\n```suggestion\r\n            meas_share = vec_add(out_share[0], out_share[1])\r\n            # By the path verifiability of the VIDPF,\r\n            # meas_share contains the value of the root node in the VIDPF tree\r\n```",
              "createdAt": "2023-10-18T20:48:48Z",
              "updatedAt": "2023-10-18T21:07:17Z"
            },
            {
              "originalPosition": 191,
              "body": "```suggestion\r\n            raise Exception('output vector is not one-hot or value changes between levels')\r\n```\r\nWith the new VIDPF, I think this could indicate a violation of either one-hot or path verifiability?",
              "createdAt": "2023-10-18T20:58:07Z",
              "updatedAt": "2023-10-18T21:07:17Z"
            },
            {
              "originalPosition": 89,
              "body": "I think it might make more sense to do something like a 'fast-forward' approach rather than a fast-start. Even if we were to start at level 7 in this way, we'd still have to evaluate the entire tree and the FLP at level 0. So we could think about changing the agg_param format to a tuple of agg_params; is_valid would evaluate the same properties on the union of the tuples as it currently does. That way you could just evaluate levels 0 and 7 at once and then move on. ",
              "createdAt": "2023-10-18T21:05:50Z",
              "updatedAt": "2023-10-18T21:07:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kgOLs",
          "commit": {
            "abbreviatedOid": "39a4a56"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T21:17:41Z",
          "updatedAt": "2023-10-18T21:17:41Z",
          "comments": [
            {
              "originalPosition": 191,
              "body": "Please send a PR to fix since this got merged already!",
              "createdAt": "2023-10-18T21:17:41Z",
              "updatedAt": "2023-10-18T21:17:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kgOqi",
          "commit": {
            "abbreviatedOid": "39a4a56"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T21:19:19Z",
          "updatedAt": "2023-10-18T21:19:20Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "Sounds reasonable. At this stage I don't want to overcomplicate the spec, so I suggest documenting this idea in an issue. You might also consider updating this comment in a PR.",
              "createdAt": "2023-10-18T21:19:20Z",
              "updatedAt": "2023-10-18T21:19:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kgOyA",
          "commit": {
            "abbreviatedOid": "1a8e1d5"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T21:19:44Z",
          "updatedAt": "2023-10-18T21:19:44Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "Sounds reasonable.",
              "createdAt": "2023-10-18T21:19:44Z",
              "updatedAt": "2023-10-18T21:19:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kgPFQ",
          "commit": {
            "abbreviatedOid": "1a8e1d5"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T21:20:47Z",
          "updatedAt": "2023-10-18T21:20:47Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "Right. I attempted to address with an \"implementation note\" above. Basically you can cache the `prefix_tree_share` across calls to `eval()`. Does this ake sense?",
              "createdAt": "2023-10-18T21:20:47Z",
              "updatedAt": "2023-10-18T21:20:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kgP5B",
          "commit": {
            "abbreviatedOid": "1a8e1d5"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T21:22:34Z",
          "updatedAt": "2023-10-18T21:22:34Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "https://github.com/jimouris/draft-mouris-cfrg-mastic/blob/main/poc/vidpf.py#L109",
              "createdAt": "2023-10-18T21:22:34Z",
              "updatedAt": "2023-10-18T21:22:34Z"
            }
          ]
        }
      ]
    },
    {
      "number": 21,
      "id": "PR_kwDOJmRsfc5c9Zz7",
      "title": "vidpf: Go back to using `Field.zeros()` in tests",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/21",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-17T00:50:14Z",
      "updatedAt": "2023-12-07T18:19:12Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "2dfe96bec07205f5253b1682994f8473efe6f6f5",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/vidpf-zeros",
      "headRefOid": "d9243f3f918aec7f45eb486ef5e2767a086e8520",
      "closedAt": "2023-10-17T14:32:29Z",
      "mergedAt": "2023-10-17T14:32:29Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "fb1804dc54505534f2ac4db508e80ddc2a679542"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc5kRqpJ",
          "commit": {
            "abbreviatedOid": "d9243f3"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-17T13:22:10Z",
          "updatedAt": "2023-10-17T13:22:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 22,
      "id": "PR_kwDOJmRsfc5dEppE",
      "title": "vidpf: Add PLASMA-style path verifiability",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/22",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed here in https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/20#discussion_r1362349956, for each node in the prefix tree we wish to check that the children sum up to the same value.\r\n\r\nPreviously we had discussed handling path verifiability at a higher level, in Mastic itself. Indeed, it's possible to use the current VIDPF in a black-box manner and perform the same calculation. However, the resulting algorithm would have asymptotic runtime that is far worse than optimal. Instead, I followed @hannahdaviscrypto's suggestion to modify VIDPF so that it does the path verification itself. The resulting algorithm is as fast as we can hope for, at least asymptotically. (Concretely there is more room for optimization.)\r\n\r\nWhen specifying a complex algorithm like this, it's often useful to write down the asymptotically-optimal version. I think it makes sense to do the same thing here.\r\n\r\nThis PR also stacks some minor changes to `vidpf` that are technically separate. It may help to review commit-by-commit.",
      "createdAt": "2023-10-17T23:24:53Z",
      "updatedAt": "2023-12-07T18:19:12Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "fb1804dc54505534f2ac4db508e80ddc2a679542",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/vidpf-path-verify",
      "headRefOid": "632adf1610f0c9e9ee6eb876eeaa46d7e3f4e34c",
      "closedAt": "2023-10-18T20:48:23Z",
      "mergedAt": "2023-10-18T20:48:23Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "b9173fdcb87245a9a7bf5774f8be6d3c42278dd5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc5kWlGt",
          "commit": {
            "abbreviatedOid": "c001c2a"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T23:31:43Z",
          "updatedAt": "2023-10-17T23:31:43Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "@jimouris I think the math actually works out so that we don't need to conditionally invert here, as suggested in https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/20#discussion_r1362349956",
              "createdAt": "2023-10-17T23:31:43Z",
              "updatedAt": "2023-10-17T23:31:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kWlVy",
          "commit": {
            "abbreviatedOid": "c001c2a"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T23:33:01Z",
          "updatedAt": "2023-10-17T23:33:02Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "@jimouris I think this may be ambiguous: the node of the prefix tree is determined by `(node, current_level)`, not just `node`. Otherwise there are collisions.",
              "createdAt": "2023-10-17T23:33:01Z",
              "updatedAt": "2023-10-17T23:33:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kegnU",
          "commit": {
            "abbreviatedOid": "c001c2a"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T17:31:22Z",
          "updatedAt": "2023-10-18T17:31:23Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "Hmm, I don't see why it checks out without negating one part: \r\n\r\n$y_0^\u03b3 + y_1^\u03b3 = (y_0^{\u03b3||0} + y_0^{\u03b3||1}) + (y_1^{\u03b3||0} + y_1^{\u03b3||1}) \\iff y_0^\u03b3 - y_0^{\u03b3||0} - y_0^{\u03b3||1} = - y_1^\u03b3 + y_1^{\u03b3||0} + y_1^{\u03b3||1}$\r\n\r\n",
              "createdAt": "2023-10-18T17:31:23Z",
              "updatedAt": "2023-10-18T17:31:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kehQi",
          "commit": {
            "abbreviatedOid": "c001c2a"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T17:32:55Z",
          "updatedAt": "2023-10-18T17:32:55Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "Ambiguous to put the node you mean? What are you suggesting here instead?",
              "createdAt": "2023-10-18T17:32:55Z",
              "updatedAt": "2023-10-18T17:32:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kehtb",
          "commit": {
            "abbreviatedOid": "c001c2a"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "Looks good, need to double-check the conditional negate.",
          "createdAt": "2023-10-18T17:34:03Z",
          "updatedAt": "2023-10-18T17:34:03Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJmRsfc5kfj14",
          "commit": {
            "abbreviatedOid": "c001c2a"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T19:45:16Z",
          "updatedAt": "2023-10-18T19:45:17Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "I'm suggesting `node || current_level`.",
              "createdAt": "2023-10-18T19:45:16Z",
              "updatedAt": "2023-10-18T19:45:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kflpH",
          "commit": {
            "abbreviatedOid": "c001c2a"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T19:49:57Z",
          "updatedAt": "2023-10-18T19:49:58Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "Yeah I see what you mean. But this is consistent with how IDPF works in the Poplar paper: In order to make the output shares additive, you actually need to negate one of them, as we do here.",
              "createdAt": "2023-10-18T19:49:57Z",
              "updatedAt": "2023-10-18T19:49:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kfnBm",
          "commit": {
            "abbreviatedOid": "c001c2a"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T19:53:24Z",
          "updatedAt": "2023-10-18T19:53:24Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "But here we haven't negated, right? Or am I missing it?",
              "createdAt": "2023-10-18T19:53:24Z",
              "updatedAt": "2023-10-18T19:53:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kfrC3",
          "commit": {
            "abbreviatedOid": "c001c2a"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T19:56:29Z",
          "updatedAt": "2023-10-18T19:56:29Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "I haven't added a negation in this PR",
              "createdAt": "2023-10-18T19:56:29Z",
              "updatedAt": "2023-10-18T19:56:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kfsWa",
          "commit": {
            "abbreviatedOid": "c001c2a"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T19:58:08Z",
          "updatedAt": "2023-10-18T19:58:08Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "Sorry, II think this is what you're asking for: https://github.com/jimouris/draft-mouris-cfrg-mastic/blob/main/poc/vidpf.py#L149",
              "createdAt": "2023-10-18T19:58:08Z",
              "updatedAt": "2023-10-18T19:58:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kfu8i",
          "commit": {
            "abbreviatedOid": "c001c2a"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T20:01:49Z",
          "updatedAt": "2023-10-18T20:01:49Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "Oh nice, yup, that's the one, so we're negating but in the VIDPF instead of here. Looks good!",
              "createdAt": "2023-10-18T20:01:49Z",
              "updatedAt": "2023-10-18T20:01:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kfvCp",
          "commit": {
            "abbreviatedOid": "c001c2a"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-18T20:02:00Z",
          "updatedAt": "2023-10-18T20:02:00Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJmRsfc5kf7o9",
          "commit": {
            "abbreviatedOid": "632adf1"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-18T20:32:57Z",
          "updatedAt": "2023-10-18T20:32:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 25,
      "id": "PR_kwDOJmRsfc5dUGyq",
      "title": "Clarify and speed up mastic implementation",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/25",
      "state": "CLOSED",
      "author": "hannahdaviscrypto",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Clarifying certain comments and error messages in the Mastic implementation. The only significant change is to VIDPF.eval, which now uses the INCREMENTAL_MODE flag to determine whether to establish path-verifiability for the whole tree or a single layer. This should eliminate redundant hashing in incremental mode and slightly improve efficiency.",
      "createdAt": "2023-10-19T20:29:34Z",
      "updatedAt": "2023-10-21T04:33:20Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "cd9f72451fd0b39a930886d18dcad6afd4c8b128",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "hannahedavis/mastic",
      "headRefOid": "846a4d0452034f4dec5b47ddb4e9fe6e21d1fe47",
      "closedAt": "2023-10-21T04:33:20Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually, one substantive comment: if we're not verifying the path of the entire prefix tree, then we probably need to restrict the aggregation parameter in incremental mode such that the level monotonically increases.",
          "createdAt": "2023-10-19T23:39:26Z",
          "updatedAt": "2023-10-19T23:39:26Z"
        },
        {
          "author": "hannahdaviscrypto",
          "authorAssociation": "COLLABORATOR",
          "body": "> Actually, one substantive comment: if we're not verifying the path of the entire prefix tree, then we probably need to restrict the aggregation parameter in incremental mode such that the level monotonically increases.\r\n\r\nI think it might go further than this: monotonicity isn't sufficient; we would need that every prior level is checked because otherwise beta could change at any intermediate unchecked level. @jimouris Do we also need the one-hot proofs to be verified at every level to establish one-hotness at later levels, or is skipping some levels acceptable?\r\n\r\nEdit: closing this to restart from the new main after incremental mode was changed; I'm also wondering if we need to worry about verifying one-hot proofs for every prefix at every level--i.e., if at level 3 we test prefixes (0b010, 0b011, 0b111), at level 4 we test all children of those prefixes, and then at level 5 we add 0b10101, could we violate one-hotness or path-verifiability there? In that case, the validity check needs to be much more involved.",
          "createdAt": "2023-10-21T03:52:11Z",
          "updatedAt": "2023-10-21T04:33:09Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc5kqbTe",
          "commit": {
            "abbreviatedOid": "846a4d0"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Good idea, just a few minor comments.",
          "createdAt": "2023-10-19T23:29:31Z",
          "updatedAt": "2023-10-19T23:38:02Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\n            # thus supporting fast-start without changing the validity condition.\r\n```",
              "createdAt": "2023-10-19T23:29:32Z",
              "updatedAt": "2023-10-19T23:38:02Z"
            },
            {
              "originalPosition": 5,
              "body": "To be honest I think yours is a much better solution than mine. Feel free to take over the `TODO`.",
              "createdAt": "2023-10-19T23:29:51Z",
              "updatedAt": "2023-10-19T23:38:02Z"
            },
            {
              "originalPosition": 17,
              "body": "* Generally block comments precede the code they're commenting on.\r\n* I think we could merge this into the block comment above `eval()`.",
              "createdAt": "2023-10-19T23:30:47Z",
              "updatedAt": "2023-10-19T23:38:02Z"
            },
            {
              "originalPosition": 27,
              "body": "Otherwise this string contains a bunch of empty space\r\n```suggestion\r\n            raise Exception('output vector is not one-hot or VIDPF output is ' \\\r\n                            'inconsistent between levels')\r\n```",
              "createdAt": "2023-10-19T23:31:16Z",
              "updatedAt": "2023-10-19T23:38:02Z"
            },
            {
              "originalPosition": 7,
              "body": "Break lines at 80 characters",
              "createdAt": "2023-10-19T23:32:13Z",
              "updatedAt": "2023-10-19T23:38:02Z"
            },
            {
              "originalPosition": 12,
              "body": "Please expand on this comment here to explain what portion of the prefix tree we have path verifiability.",
              "createdAt": "2023-10-19T23:37:38Z",
              "updatedAt": "2023-10-19T23:38:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kvg4O",
          "commit": {
            "abbreviatedOid": "846a4d0"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "I agree with Chris' comments, the rest look goog to me.",
          "createdAt": "2023-10-20T14:29:58Z",
          "updatedAt": "2023-10-20T14:29:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 26,
      "id": "PR_kwDOJmRsfc5dZxPW",
      "title": "poc: Fix a typo in a comment",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/26",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-20T16:36:44Z",
      "updatedAt": "2023-12-07T18:19:14Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "15aab2f1fefc273d50c5b7cb521b3b8ecedfc5d9",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/poc-typo",
      "headRefOid": "ec3c50053cfdfa9903fcdb7e10070baf5267090b",
      "closedAt": "2023-10-20T18:14:11Z",
      "mergedAt": "2023-10-20T18:14:11Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "9f80d98a6b5d8b58ef7916e9c3ab2b0ccc503447"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc5kxeVg",
          "commit": {
            "abbreviatedOid": "ec3c500"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-20T18:12:29Z",
          "updatedAt": "2023-10-20T18:12:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 27,
      "id": "PR_kwDOJmRsfc5daHdd",
      "title": " Simplify `Mastic` and add more tests",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/27",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #19.\r\nPartially addresses #24.\r\n\r\nSimplify the spec in two ways:\r\n\r\n* During `Mastic.prep_init()`, call `Vidpf.eval()` exactly once. In\r\n  order to compute the share of `beta`, modify `Vidpf` to return the sum\r\n  of the children of the root. This is less redundant because we end up\r\n  visiting these nodes when evaluating the prefix tree. (In effect, this\r\n  some logic in `Mastic` into `Vidpf`.)\r\n\r\n* Remove the `INCREMENTAL_MODE` flag and add a `do_range_check` flag to\r\n  the aggregation parameter. If set, the Aggregators will verify the\r\n  FLP. Accordingly, modify `Mastic.is_valid()` to enforce that the FLP\r\n  is verified the first time (and only the first time) the reports are\r\n  aggregated. Also, check that the level at which the reports are\r\n  aggregated is non-decreasing.\r\n\r\nIn addition, add examples that illustrate the two main \"modes\" for\r\n`Mastic`: \"heavy hitters\" and \"labels\".",
      "createdAt": "2023-10-20T17:45:46Z",
      "updatedAt": "2023-12-07T18:19:16Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "9f80d98a6b5d8b58ef7916e9c3ab2b0ccc503447",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/one-vidpf-call",
      "headRefOid": "58ece9150ba76593a0d9f778990b258c77be0f15",
      "closedAt": "2023-10-20T22:57:52Z",
      "mergedAt": "2023-10-20T22:57:52Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "f780fc07011bf5ef37b33cc71f2504756643a6f8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc5kxYIA",
          "commit": {
            "abbreviatedOid": "7050ee6"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T17:57:30Z",
          "updatedAt": "2023-10-20T17:57:30Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Just to follow up on the issue from the call: We need to negate aggregator 1's share; I was negating 0's.",
              "createdAt": "2023-10-20T17:57:30Z",
              "updatedAt": "2023-10-20T17:57:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kxYIO",
          "commit": {
            "abbreviatedOid": "7050ee6"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-10-20T17:57:31Z",
          "updatedAt": "2023-10-20T17:57:39Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Ah, great! Just an observation/Question, in case the prefix == '', then `beta_share == out_share`, right?\r\n\r\nIn this case, would it make sense to check in mastic if level == 0 and then add the out_share[0] (left) and out_share[1] (right) to compute the beta_share? In all other cases, we don't do anything.",
              "createdAt": "2023-10-20T17:57:31Z",
              "updatedAt": "2023-10-20T17:57:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kxYXJ",
          "commit": {
            "abbreviatedOid": "7050ee6"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T17:58:13Z",
          "updatedAt": "2023-10-20T17:58:14Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Yup, saw that :)",
              "createdAt": "2023-10-20T17:58:14Z",
              "updatedAt": "2023-10-20T17:58:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kxY0f",
          "commit": {
            "abbreviatedOid": "7050ee6"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T17:59:37Z",
          "updatedAt": "2023-10-20T17:59:38Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "`level == 0` is **not** the root, but the children of the root.",
              "createdAt": "2023-10-20T17:59:37Z",
              "updatedAt": "2023-10-20T17:59:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kxaTa",
          "commit": {
            "abbreviatedOid": "7050ee6"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T18:04:26Z",
          "updatedAt": "2023-10-20T18:04:26Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Sure, but the comment is still valid. I meant that in the case that the following is true:\r\n\r\n```python\r\nif cls.do_range_check(agg_param):\r\n```\r\n\r\nthen, beta_share == out_share[0] + out_share[1]. Or not? If yes, we can skip the beta_share altogether.\r\n",
              "createdAt": "2023-10-20T18:04:26Z",
              "updatedAt": "2023-10-20T18:04:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kxgrJ",
          "commit": {
            "abbreviatedOid": "7050ee6"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T18:19:13Z",
          "updatedAt": "2023-10-20T18:19:13Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Yes, if `prefix == [0, 1]` and `level == 0` then computing `beta_share` here is redundant and we could instead compute it the way you describe. I've updated `Vidpf.eval()` accordingly.",
              "createdAt": "2023-10-20T18:19:13Z",
              "updatedAt": "2023-10-20T18:19:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kxhaA",
          "commit": {
            "abbreviatedOid": "7050ee6"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T18:21:32Z",
          "updatedAt": "2023-10-20T18:21:32Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Thanks, can we move it out of vidpf to mastic_vdaf? This way, if we put the check there we won't have to return both beta_share and out_share, only one would be sufficient.",
              "createdAt": "2023-10-20T18:21:32Z",
              "updatedAt": "2023-10-20T18:21:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kxiKz",
          "commit": {
            "abbreviatedOid": "7050ee6"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T18:22:40Z",
          "updatedAt": "2023-10-20T18:22:40Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "But then we'd have to modify `Vidpf.eval()` to conditionally compute `beta_share`, right? That seems overly complicated.",
              "createdAt": "2023-10-20T18:22:40Z",
              "updatedAt": "2023-10-20T18:22:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kxi4w",
          "commit": {
            "abbreviatedOid": "7050ee6"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T18:24:46Z",
          "updatedAt": "2023-10-20T18:24:47Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "`Vidpf.eval()` can be as we had it before and we can do the negation in mastic_vdaf. We can merge this one and I can take a stab at it later.",
              "createdAt": "2023-10-20T18:24:46Z",
              "updatedAt": "2023-10-20T18:24:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kxjiA",
          "commit": {
            "abbreviatedOid": "7050ee6"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T18:26:31Z",
          "updatedAt": "2023-10-20T18:26:31Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Hmmm, I'm not sure exactly what you're after. Maybe tack on a commit to this branch?",
              "createdAt": "2023-10-20T18:26:31Z",
              "updatedAt": "2023-10-20T18:26:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kxmPq",
          "commit": {
            "abbreviatedOid": "7050ee6"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T18:34:36Z",
          "updatedAt": "2023-10-20T18:34:36Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Take a look here: https://github.com/jimouris/draft-mouris-cfrg-mastic/commit/f5088c1b9292d602498cac8f12db3ee83cd8567e\r\n\r\nI think that's sufficient, right?",
              "createdAt": "2023-10-20T18:34:36Z",
              "updatedAt": "2023-10-20T18:34:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kxtcA",
          "commit": {
            "abbreviatedOid": "7050ee6"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T18:57:23Z",
          "updatedAt": "2023-10-20T18:57:23Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "No because `out_share[0]` is not guaranteed to be the output share for `prefix == 0`. (Similarly for `out_share[1]`.)",
              "createdAt": "2023-10-20T18:57:23Z",
              "updatedAt": "2023-10-20T18:57:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kxtl5",
          "commit": {
            "abbreviatedOid": "7050ee6"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T18:57:53Z",
          "updatedAt": "2023-10-20T18:57:53Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Suppose `prep_init()` is called on `prefixes == [0b11], level == 1`.",
              "createdAt": "2023-10-20T18:57:53Z",
              "updatedAt": "2023-10-20T18:57:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kxt11",
          "commit": {
            "abbreviatedOid": "7050ee6"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T18:58:40Z",
          "updatedAt": "2023-10-20T18:58:40Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "But then `if cls.do_range_check(agg_param):` this would be false so we don't really care.",
              "createdAt": "2023-10-20T18:58:40Z",
              "updatedAt": "2023-10-20T18:58:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kxuRX",
          "commit": {
            "abbreviatedOid": "7050ee6"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T19:00:06Z",
          "updatedAt": "2023-10-20T19:00:07Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Take a look again: What values of `prefixes` and `level` are permitted if `INCREMENTAL_MODE==False`?",
              "createdAt": "2023-10-20T19:00:07Z",
              "updatedAt": "2023-10-20T19:00:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kxuSu",
          "commit": {
            "abbreviatedOid": "7050ee6"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T19:00:11Z",
          "updatedAt": "2023-10-20T19:00:11Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Ah, no it wouldn't be because we have `level == cls.Vidpf.BITS-1`. But do we need that? Why not check just for the level there?",
              "createdAt": "2023-10-20T19:00:11Z",
              "updatedAt": "2023-10-20T19:00:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kxwuI",
          "commit": {
            "abbreviatedOid": "7050ee6"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T19:07:51Z",
          "updatedAt": "2023-10-20T19:07:51Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "What do you mean check for the level?",
              "createdAt": "2023-10-20T19:07:51Z",
              "updatedAt": "2023-10-20T19:07:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kxyWK",
          "commit": {
            "abbreviatedOid": "7050ee6"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T19:11:20Z",
          "updatedAt": "2023-10-20T19:11:20Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I meant in `do_range_check` to only check if `level == 0`. I don't see why we need the `INCREMENTAL_MODE` there or even the `level == cls.Vidpf.BITS-1` check.\r\n\r\nMaybe it's a good idea to add some tests at some point so if changes like my proposed one don't make sense the tests should catch this.\r\n\r\n",
              "createdAt": "2023-10-20T19:11:20Z",
              "updatedAt": "2023-10-20T19:11:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kxzIc",
          "commit": {
            "abbreviatedOid": "7050ee6"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T19:14:00Z",
          "updatedAt": "2023-10-20T19:14:01Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Agreed, I don't think I've been clear enough about how I'd like to use Mastic beyond heavy hitters. Let me tack on some commits that will hopefully clarify.\r\n\r\n@hannahdaviscrypto, I'm going to remove INCREMENTAL_MODE for now, which means you'll need to rework #25 a bit.",
              "createdAt": "2023-10-20T19:14:01Z",
              "updatedAt": "2023-10-20T19:14:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kxz1g",
          "commit": {
            "abbreviatedOid": "d25ce9d"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-20T19:15:45Z",
          "updatedAt": "2023-10-20T19:15:45Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJmRsfc5kx0PO",
          "commit": {
            "abbreviatedOid": "7050ee6"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T19:17:11Z",
          "updatedAt": "2023-10-20T19:17:11Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Thanks, you explained it before but I didn't fully get it. Maybe it would make sense to add it back once we have these examples/tests.",
              "createdAt": "2023-10-20T19:17:11Z",
              "updatedAt": "2023-10-20T19:17:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5kyWhk",
          "commit": {
            "abbreviatedOid": "58ece91"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-20T21:27:26Z",
          "updatedAt": "2023-10-20T21:27:26Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJmRsfc5kzVhi",
          "commit": {
            "abbreviatedOid": "58ece91"
          },
          "author": "hannahdaviscrypto",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This looks good! I have some concerns that the agg_param validity check is too broad but I'm going to attempt a fix in a separate PR, possibly in concert with the tuple idea if I have enough time. ",
          "createdAt": "2023-10-21T04:45:28Z",
          "updatedAt": "2023-10-21T04:45:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 28,
      "id": "PR_kwDOJmRsfc5dd6x9",
      "title": "poc: Harmonize naming across shard and prep",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/28",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Prefix variables having to do with FLP with \"flp_\" (likewise for VIDPF).",
      "createdAt": "2023-10-22T16:16:45Z",
      "updatedAt": "2023-12-07T18:19:17Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "971a1a86be10939decef0ca2a725282eebb2a3cb",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/poc-editorila",
      "headRefOid": "6aee97ebd832e5f5f86c6e2d3bef1315c2c207b6",
      "closedAt": "2023-10-23T14:25:15Z",
      "mergedAt": "2023-10-23T14:25:15Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "92412104989cdefd47bc4b0bad867b802694562d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc5k0nTH",
          "commit": {
            "abbreviatedOid": "6aee97e"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Neat, thanks for doing this!",
          "createdAt": "2023-10-22T23:29:03Z",
          "updatedAt": "2023-10-22T23:29:03Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJmRsfc5k1QQU",
          "commit": {
            "abbreviatedOid": "6aee97e"
          },
          "author": "hannahdaviscrypto",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I think that will clarify things a lot. Thank you!",
          "createdAt": "2023-10-23T04:15:45Z",
          "updatedAt": "2023-10-23T04:15:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 29,
      "id": "PR_kwDOJmRsfc5deCxP",
      "title": "vidpf: Align API with draft",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/29",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-22T18:18:53Z",
      "updatedAt": "2023-12-07T18:19:19Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "92412104989cdefd47bc4b0bad867b802694562d",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/poc-align-vipdf-with-draft",
      "headRefOid": "96715fe45cb7a61bc337e68ae3558caa12b0ca47",
      "closedAt": "2023-10-23T14:55:53Z",
      "mergedAt": "2023-10-23T14:55:53Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "6e72e04c456fb09f421e07d763b56881b8e272e0"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased and squahsed.",
          "createdAt": "2023-10-23T14:36:57Z",
          "updatedAt": "2023-10-23T14:36:57Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc5k0nbi",
          "commit": {
            "abbreviatedOid": "b9f5d52"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-10-22T23:32:29Z",
          "updatedAt": "2023-10-22T23:32:41Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": " The reason that I was passing the proof as an argument here is that we can take the previous proof and update it. Here we're only reading the ROOT_PROOF but we're not updating anywhere, right? Or I missed it?",
              "createdAt": "2023-10-22T23:32:29Z",
              "updatedAt": "2023-10-22T23:32:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5k1LVz",
          "commit": {
            "abbreviatedOid": "b9f5d52"
          },
          "author": "hannahdaviscrypto",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T03:38:00Z",
          "updatedAt": "2023-10-23T03:38:01Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "I believe so; the ROOT_PROOF is just a constant taking the place of the empty string in the original PLASMA design. ",
              "createdAt": "2023-10-23T03:38:01Z",
              "updatedAt": "2023-10-23T03:38:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5k1N3k",
          "commit": {
            "abbreviatedOid": "b9f5d52"
          },
          "author": "hannahdaviscrypto",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good to me!",
          "createdAt": "2023-10-23T03:59:43Z",
          "updatedAt": "2023-10-23T04:13:33Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "We don't update ROOT_PROOF, but in eval_next we do update pi_proof, which is just set to ROOT_PROOF initially here. For all subsequent prefixes and levels, this gets overwritten by whichever pi_proof is cached in prefix_tree_share. I think it's correct.",
              "createdAt": "2023-10-23T03:59:43Z",
              "updatedAt": "2023-10-23T04:13:33Z"
            },
            {
              "originalPosition": 1,
              "body": "In main() lines 278-281 and 323-326, I don't think we need to initialize proofs to contain two copies of ROOT_PROOF. Since the class now computes that for us and initializes pi_proof in eval automatically, I think we could just set proofs = [None, None]. But it's not going to hurt anything.",
              "createdAt": "2023-10-23T04:13:27Z",
              "updatedAt": "2023-10-23T04:13:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5k5NG-",
          "commit": {
            "abbreviatedOid": "b9f5d52"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-23T14:26:34Z",
          "updatedAt": "2023-10-23T14:26:34Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJmRsfc5k5QUu",
          "commit": {
            "abbreviatedOid": "b9f5d52"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T14:31:53Z",
          "updatedAt": "2023-10-23T14:31:53Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "Good catch.",
              "createdAt": "2023-10-23T14:31:53Z",
              "updatedAt": "2023-10-23T14:31:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5k5SEI",
          "commit": {
            "abbreviatedOid": "b9f5d52"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T14:34:17Z",
          "updatedAt": "2023-10-23T14:34:17Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "That's right, but for Mastic we weren't updating the proof either, so I expect this to be a non-breaking change.\r\n\r\nIf we think that starting evaluation with an arbitrary proof would be useful, then we can add this back to the API when we need it.",
              "createdAt": "2023-10-23T14:34:17Z",
              "updatedAt": "2023-10-23T14:34:18Z"
            }
          ]
        }
      ]
    },
    {
      "number": 30,
      "id": "PR_kwDOJmRsfc5dfKZy",
      "title": "Pass over the text before draft 00 deadline",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/30",
      "state": "MERGED",
      "author": "hannahdaviscrypto",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Mostly fixing typos; a few substantive changes to the intro for clarification. The main one is not claiming that VDAFs/Poplar1 solves the heavy hitters problem; I think that's inaccurate.",
      "createdAt": "2023-10-23T04:43:05Z",
      "updatedAt": "2023-10-23T14:24:22Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "51df5e3774a96814d342b8ca93dc07b674348bb1",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "hannahdaviscrypto-spec-text",
      "headRefOid": "db3d4bedaa4876e3c27aa746371f41272949679e",
      "closedAt": "2023-10-23T14:24:21Z",
      "mergedAt": "2023-10-23T14:24:21Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "b63fa59852d25de57762b55ce4239be34e978b59"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc5k5GqZ",
          "commit": {
            "abbreviatedOid": "db3d4be"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-23T14:15:32Z",
          "updatedAt": "2023-10-23T14:15:32Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJmRsfc5k5Ljb",
          "commit": {
            "abbreviatedOid": "db3d4be"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-23T14:24:16Z",
          "updatedAt": "2023-10-23T14:24:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 31,
      "id": "PR_kwDOJmRsfc5djPwE",
      "title": "Rename \"VIDPF verifier\" to \"proof\"",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/31",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-23T16:24:42Z",
      "updatedAt": "2023-12-07T18:19:19Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "66cc3dff8d66773ab8ec25d2f84e70865e75d3f4",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/vidpf-proof",
      "headRefOid": "1d613542d942678c1df5b10283ca6955d8b81d8f",
      "closedAt": "2023-10-23T17:35:05Z",
      "mergedAt": "2023-10-23T17:35:05Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "0f36c54a0447321d56297488c9a2f33d37001831"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc5k6cWJ",
          "commit": {
            "abbreviatedOid": "1d61354"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-23T16:49:19Z",
          "updatedAt": "2023-10-23T16:49:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 32,
      "id": "PR_kwDOJmRsfc5djxwA",
      "title": "Automatic update of .github/CODEOWNERS",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/32",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Automated via `make update-codeowners`",
      "createdAt": "2023-10-23T17:53:38Z",
      "updatedAt": "2023-10-23T18:00:37Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "d4aab22d3f12809996a6c7566ed6bbc253ddeff0",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/update-codeowners",
      "headRefOid": "50b68344fad3bf67f2a6b613953e57d86e49be88",
      "closedAt": "2023-10-23T18:00:34Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 33,
      "id": "PR_kwDOJmRsfc5dj0eF",
      "title": "Update CODEOWNERS",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/33",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-23T18:01:35Z",
      "updatedAt": "2023-12-07T18:19:20Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "760ea0a524d5c6d3bb5f706e697436a2790d5ef8",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/update-codeowners-manually",
      "headRefOid": "4b1041734798026da49969c4bf77a521b703f380",
      "closedAt": "2023-10-23T18:18:11Z",
      "mergedAt": "2023-10-23T18:18:11Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "dbcaa56835f43822d39c8aceb6c57520ceb6b258"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc5k7ALX",
          "commit": {
            "abbreviatedOid": "4b10417"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-23T18:03:39Z",
          "updatedAt": "2023-10-23T18:03:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 38,
      "id": "PR_kwDOJmRsfc5dsmbv",
      "title": "Add different thresholds example. (#12)",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/38",
      "state": "MERGED",
      "author": "jimouris",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "enhancement"
      ],
      "body": "Addresses https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/12\r\n\r\nWe had discussed this one before, it's not specific to Mastic but I think it's worth calling out. Right now, it has a lot of duplicate code with `example_weighted_heavy_hitters_mode`, I could merge some of the heavy hitter logic in functions and call these instead.",
      "createdAt": "2023-10-25T01:14:44Z",
      "updatedAt": "2023-10-25T20:18:45Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "67ad8247ce83c91c4ffe9df723ca4c8baf109472",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "diff-thresholds",
      "headRefOid": "04f945e92edba2a68014a47b7f893acc82cef7f7",
      "closedAt": "2023-10-25T20:08:01Z",
      "mergedAt": "2023-10-25T20:08:01Z",
      "mergedBy": "jimouris",
      "mergeCommit": {
        "oid": "44cc696029824e8cf8eb6c5ca872bb0c3eb41faa"
      },
      "comments": [
        {
          "author": "pratiksarkar93",
          "authorAssociation": "COLLABORATOR",
          "body": "Moreover, the sorting-based approaches cannot support multiple thresholds at different layers. Only the DPF-based ones (like Poplar, Doplar, and PLASMA) support it. In fact, it supports different thresholds for different prefixes (i.e., even multiple thresholds for different strings as the same level).\r\n\r\nThis technique can be useful to compute heavy-hitting selling items on Amazon based on customer's expenditures. Run the multiple-thresholds protocol over customers spending $ on Amazon purchases. The amount that needs to be spent on specific categories to consider a category as a heavy-hitter might be different. For example, grocery items will have a lower threshold than luxury items. ",
          "createdAt": "2023-10-25T11:31:46Z",
          "updatedAt": "2023-10-25T11:31:46Z"
        },
        {
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "body": "Okay, good ideas. I added two examples, one with URLs and one with e-commerce. Also, I removed duplicate code.",
          "createdAt": "2023-10-25T14:55:33Z",
          "updatedAt": "2023-10-25T14:55:33Z"
        },
        {
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "body": "Closes https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/12",
          "createdAt": "2023-10-25T20:18:13Z",
          "updatedAt": "2023-10-25T20:18:45Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc5lGaEd",
          "commit": {
            "abbreviatedOid": "480caeb"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Let's add a more concrete example to motivate this. Right now it's kind of abstract (basically, we might know in advance that some prefixes are more popular than others) and I don't quite understand what purpose is served by setting different thresholds for different prefixes.\r\n\r\nThat said the example about highways versus small roads could be interesting. Perhaps elaborate on this a bit more?\r\n\r\nPerhaps another fruitful direction: Take the \"popular URLs\" use case, which I think most people are familiar with. You might know that google.com is likely to be a heavy hitter; so how do you set the threshold for this?",
          "createdAt": "2023-10-25T01:58:02Z",
          "updatedAt": "2023-10-25T01:58:02Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJmRsfc5lMGNS",
          "commit": {
            "abbreviatedOid": "5745819"
          },
          "author": "pratiksarkar93",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-25T15:23:24Z",
          "updatedAt": "2023-10-25T15:23:24Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJmRsfc5lNJVp",
          "commit": {
            "abbreviatedOid": "5745819"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-25T17:56:47Z",
          "updatedAt": "2023-10-25T18:05:51Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Internet-Drafts typically don't mess with the font. (Similarly below.)\r\n```suggestion\r\n1. Popular URLs: [google.com](https://google.com/) receives a massive amount\r\n```",
              "createdAt": "2023-10-25T17:56:47Z",
              "updatedAt": "2023-10-25T18:05:51Z"
            },
            {
              "originalPosition": 18,
              "body": "Don't use real URLs in Internet-Drafts. If you need a domain name, use \"example.com\". If you need two domains for your example, use \"a.example.com\" and \"b.example.com\".",
              "createdAt": "2023-10-25T17:58:19Z",
              "updatedAt": "2023-10-25T18:05:51Z"
            },
            {
              "originalPosition": 18,
              "body": "Don't add hyperlinks to Internet-Drafts.\r\n```suggestion\r\n1. **Popular URLs:** `google.com` receives a massive amount\r\n```",
              "createdAt": "2023-10-25T17:58:46Z",
              "updatedAt": "2023-10-25T18:05:51Z"
            },
            {
              "originalPosition": 28,
              "body": "```suggestion\r\n   heavy-hitting grocery items on an e-commerce website, Aggregators could use\r\n```",
              "createdAt": "2023-10-25T17:59:59Z",
              "updatedAt": "2023-10-25T18:05:51Z"
            },
            {
              "originalPosition": 91,
              "body": "Code design: `bin_prefix` seems to represent a node in the IDPF tree. Elsewhere we represent this as the pair `(prefix, level)`. Is there a reason why the new representation is useful? I think it would be better to be consistent unless there's a reason not to.",
              "createdAt": "2023-10-25T18:04:35Z",
              "updatedAt": "2023-10-25T18:05:51Z"
            },
            {
              "originalPosition": 55,
              "body": "```suggestion\r\n    Return the threshold of the given prefix if it exists. If not, check if any of\r\n```",
              "createdAt": "2023-10-25T18:05:05Z",
              "updatedAt": "2023-10-25T18:05:51Z"
            },
            {
              "originalPosition": 56,
              "body": "```suggestion\r\n    its prefixes exist. If not, return the default threshold.\r\n```",
              "createdAt": "2023-10-25T18:05:23Z",
              "updatedAt": "2023-10-25T18:05:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5lNTjo",
          "commit": {
            "abbreviatedOid": "5745819"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-25T18:18:40Z",
          "updatedAt": "2023-10-25T18:18:41Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Should I use the google.com example or replace it with example.com?",
              "createdAt": "2023-10-25T18:18:41Z",
              "updatedAt": "2023-10-25T18:18:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5lNVzS",
          "commit": {
            "abbreviatedOid": "5745819"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-25T18:22:19Z",
          "updatedAt": "2023-10-25T18:22:19Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "we represent the alpha values as ints (e.g., 0b001). But here we want a dict and values such as 0b00 and 0b0 are both zero. So I'm converting these to strings \"0b00\" and \"0b0\", respectively.",
              "createdAt": "2023-10-25T18:22:19Z",
              "updatedAt": "2023-10-25T18:22:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5lNYwd",
          "commit": {
            "abbreviatedOid": "5745819"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-25T18:26:12Z",
          "updatedAt": "2023-10-25T18:26:12Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Replace it with example.com",
              "createdAt": "2023-10-25T18:26:12Z",
              "updatedAt": "2023-10-25T18:26:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5lNaJu",
          "commit": {
            "abbreviatedOid": "5745819"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-25T18:27:43Z",
          "updatedAt": "2023-10-25T18:27:43Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "My opinion is that we should represent the keys in this dictionary as pairs `(prefix, level)` rather than strings. Better to have the reader need just one mental model for thinking about how to represent this value.",
              "createdAt": "2023-10-25T18:27:43Z",
              "updatedAt": "2023-10-25T18:27:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5lNh1K",
          "commit": {
            "abbreviatedOid": "5745819"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-25T18:47:56Z",
          "updatedAt": "2023-10-25T18:47:56Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "Okay, done.",
              "createdAt": "2023-10-25T18:47:56Z",
              "updatedAt": "2023-10-25T18:47:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5lN-Dt",
          "commit": {
            "abbreviatedOid": "04f945e"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "\ud83d\udc4d ",
          "createdAt": "2023-10-25T20:03:07Z",
          "updatedAt": "2023-10-25T20:03:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 40,
      "id": "PR_kwDOJmRsfc5eJKXK",
      "title": "Add Prio3-style joint randomness derivation",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/40",
      "state": "MERGED",
      "author": "hannahdaviscrypto",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-30T16:37:00Z",
      "updatedAt": "2023-11-14T21:45:33Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "d5a641799670afe9ab495189ad40b4ad17144745",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "hannah.e.davis/jointrand",
      "headRefOid": "512d57d28a4d56525e0d7efbbe10fc0476b3fb04",
      "closedAt": "2023-11-14T21:45:33Z",
      "mergedAt": "2023-11-14T21:45:33Z",
      "mergedBy": "hannahdaviscrypto",
      "mergeCommit": {
        "oid": "512d57d28a4d56525e0d7efbbe10fc0476b3fb04"
      },
      "comments": [
        {
          "author": "hannahdaviscrypto",
          "authorAssociation": "COLLABORATOR",
          "body": "I wasn't able to run the tests yet as I'm still waiting on IT support for permission to install Sage. I'll update when that comes through. ",
          "createdAt": "2023-10-30T16:41:51Z",
          "updatedAt": "2023-10-30T16:41:51Z"
        },
        {
          "author": "hannahdaviscrypto",
          "authorAssociation": "COLLABORATOR",
          "body": "Finally, my workspace is up and running and the tests pass.",
          "createdAt": "2023-11-03T20:15:08Z",
          "updatedAt": "2023-11-03T20:15:08Z"
        },
        {
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "body": "I'll try to take a look over the weekend, it'll help me understand how the joint randomness is generated.",
          "createdAt": "2023-11-03T20:22:24Z",
          "updatedAt": "2023-11-03T20:22:24Z"
        },
        {
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "body": "@hannahdaviscrypto Could you also add some text in the draft to describe the joint randomness and in which cases we will need it and in which not? ",
          "createdAt": "2023-11-03T20:24:04Z",
          "updatedAt": "2023-11-03T20:24:04Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Hey @hannahdaviscrypto sorry about this but I merged #41, which caused conflicts that you'll need to rebase on top of. You'll also need to address any linter warnings that CI throws at you. Take a look at .github/workflows/lint-python.yml for details. Note that `autopep8` and `isort` are tools you can install and run locally to automatically fix the warnings.",
          "createdAt": "2023-11-09T17:12:25Z",
          "updatedAt": "2023-11-09T17:12:25Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc5mOKj4",
          "commit": {
            "abbreviatedOid": "a95f080"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Some nit-picky comments but looks great overall.",
          "createdAt": "2023-11-06T11:55:15Z",
          "updatedAt": "2023-11-06T11:57:38Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "I think something like this would be more Python-ish\r\n```suggestion\r\n            (\r\n                vidpf_init_seed[0], \r\n                flp_leader_proof_share,\r\n                flp_leader_blind,\r\n            ),\r\n```",
              "createdAt": "2023-11-06T11:55:15Z",
              "updatedAt": "2023-11-06T11:57:38Z"
            },
            {
              "originalPosition": 139,
              "body": "```suggestion\r\n            joint_rand = []\r\n```",
              "createdAt": "2023-11-06T11:55:51Z",
              "updatedAt": "2023-11-06T11:57:38Z"
            },
            {
              "originalPosition": 272,
              "body": "Why not just delete this instead of commenting it out?",
              "createdAt": "2023-11-06T11:56:33Z",
              "updatedAt": "2023-11-06T11:57:38Z"
            },
            {
              "originalPosition": 321,
              "body": "In the test_vdaf() examples below, maybe add a test case with `Sum`.",
              "createdAt": "2023-11-06T11:57:36Z",
              "updatedAt": "2023-11-06T11:57:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5mluac",
          "commit": {
            "abbreviatedOid": "a95f080"
          },
          "author": "hannahdaviscrypto",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-08T19:56:01Z",
          "updatedAt": "2023-11-08T19:56:02Z",
          "comments": [
            {
              "originalPosition": 321,
              "body": "I did change the example_aggregation_by_labels_mode() test case to use Sum instead of Count and changed the values a bit to fall in a wider range. Should I change that back and add a new test case just for Sum?",
              "createdAt": "2023-11-08T19:56:02Z",
              "updatedAt": "2023-11-08T19:56:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5mlwLP",
          "commit": {
            "abbreviatedOid": "a95f080"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-08T20:00:34Z",
          "updatedAt": "2023-11-08T20:00:35Z",
          "comments": [
            {
              "originalPosition": 321,
              "body": "I think it makes sense to use `Sum` in `example_aggregation_by_labels_mode` and have only that. Using `Count` there is trivial, I don't see any application in which we'd want to do that realistically since it can be achieved with a simple encoding more effectively (in fact we don't even need the tuple if we do `Count`).",
              "createdAt": "2023-11-08T20:00:34Z",
              "updatedAt": "2023-11-08T20:00:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5msuYj",
          "commit": {
            "abbreviatedOid": "a95f080"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-09T16:31:45Z",
          "updatedAt": "2023-11-09T16:31:45Z",
          "comments": [
            {
              "originalPosition": 321,
              "body": "For test coverage purposes we should have unit tests for Mastic with and without joint randomness. Yes it's technically redundant, given that the examples already exercise the former, but the examples aren't intended to be unit tests.",
              "createdAt": "2023-11-09T16:31:45Z",
              "updatedAt": "2023-11-09T16:31:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5muOw4",
          "commit": {
            "abbreviatedOid": "a95f080"
          },
          "author": "hannahdaviscrypto",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-09T19:59:12Z",
          "updatedAt": "2023-11-09T19:59:12Z",
          "comments": [
            {
              "originalPosition": 321,
              "body": "Should be done now.",
              "createdAt": "2023-11-09T19:59:12Z",
              "updatedAt": "2023-11-09T19:59:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5mvUsq",
          "commit": {
            "abbreviatedOid": "512d57d"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-09T23:27:38Z",
          "updatedAt": "2023-11-09T23:27:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 41,
      "id": "PR_kwDOJmRsfc5fDh8o",
      "title": "Add Python linters to CI",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/41",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This workflow was borrowed from draft-irtf-cfrg-vdaf.",
      "createdAt": "2023-11-09T16:36:09Z",
      "updatedAt": "2023-12-07T18:19:21Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "44cc696029824e8cf8eb6c5ca872bb0c3eb41faa",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/add-linter-and-tests-to-ci",
      "headRefOid": "2255c4bd57effdda2844f76accb0bac8fc1922e4",
      "closedAt": "2023-11-09T17:10:39Z",
      "mergedAt": "2023-11-09T17:10:39Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "daa3b588d034bd5d76fd321cd9ac0a7df7ac1241"
      },
      "comments": [
        {
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "body": "Neat!",
          "createdAt": "2023-11-09T16:56:35Z",
          "updatedAt": "2023-11-09T16:56:35Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc5ms_wD",
          "commit": {
            "abbreviatedOid": "2255c4b"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-09T16:56:24Z",
          "updatedAt": "2023-11-09T16:56:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 42,
      "id": "PR_kwDOJmRsfc5fDxqR",
      "title": "Run tests from CI",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/42",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-11-09T17:18:06Z",
      "updatedAt": "2023-12-07T18:19:22Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "daa3b588d034bd5d76fd321cd9ac0a7df7ac1241",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/add-tests-to-ci",
      "headRefOid": "158361e9b07f5cfdd2ac84579b9f239e62a74786",
      "closedAt": "2023-11-09T17:52:35Z",
      "mergedAt": "2023-11-09T17:52:35Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "d5a641799670afe9ab495189ad40b4ad17144745"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc5mtNt8",
          "commit": {
            "abbreviatedOid": "158361e"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Thanks for adding this!",
          "createdAt": "2023-11-09T17:23:08Z",
          "updatedAt": "2023-11-09T17:23:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 43,
      "id": "PR_kwDOJmRsfc5fJyrM",
      "title": "Clean up",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/43",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Stacked on #40 (merge that first).",
      "createdAt": "2023-11-10T15:32:26Z",
      "updatedAt": "2023-12-07T18:19:23Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "512d57d28a4d56525e0d7efbbe10fc0476b3fb04",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/35",
      "headRefOid": "30c1a25f27be77cc0aeda9e2df5055dc8c1dc0c0",
      "closedAt": "2023-11-15T15:01:07Z",
      "mergedAt": "2023-11-15T15:01:07Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "c4d61c656f0fe30200dd903edf3b1db2e6470fa2"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased.",
          "createdAt": "2023-11-15T15:00:59Z",
          "updatedAt": "2023-11-15T15:00:59Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc5m1Zej",
          "commit": {
            "abbreviatedOid": "30c1a25"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-10T17:46:39Z",
          "updatedAt": "2023-11-10T17:46:39Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJmRsfc5nI3WK",
          "commit": {
            "abbreviatedOid": "30c1a25"
          },
          "author": "hannahdaviscrypto",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good to me!",
          "createdAt": "2023-11-14T17:53:26Z",
          "updatedAt": "2023-11-14T17:53:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 44,
      "id": "PR_kwDOJmRsfc5fKLGh",
      "title": "Pass measurement count to `Flp.decode()`",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/44",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #35.\r\nStacked on #43 (merge that first).\r\n\r\nAt the moment we simply pass `meas_count == 0` to `Flp.decode()` because we don't know the actual value of `meas_count`. This makes `Mastic` incompatible with any FLP that requires the measurement count at decoding time.\r\n\r\nTo address this, plumb a counter for each measurement from VIDPF evaluation to FLP unsharding. The value of the counter is `1` if the prefix is on the `alpha`-path and `0` otherwise. To accomplish this, we do the simplest thing: prepend a field element to each correction word.\r\n\r\nAlong the way, fix a bug in `Mastic.aggregate()` and `Mastic.unshard()` whereby the accumulator vector was initialized to the wrong length.",
      "createdAt": "2023-11-10T16:31:42Z",
      "updatedAt": "2023-12-07T18:19:24Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "c4d61c656f0fe30200dd903edf3b1db2e6470fa2",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/35-2",
      "headRefOid": "f93dfbc9aee2af0066ca14af531429840f87d66a",
      "closedAt": "2023-11-16T00:50:25Z",
      "mergedAt": "2023-11-16T00:50:25Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "c13585f2887766b8395e87d81813747c14aa6e3c"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased.",
          "createdAt": "2023-11-15T15:02:35Z",
          "updatedAt": "2023-11-15T15:02:35Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc5m1CTV",
          "commit": {
            "abbreviatedOid": "1d49cff"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-10T16:46:19Z",
          "updatedAt": "2023-11-10T16:46:19Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "@jimouris please check carefully that this matches PLASMA.",
              "createdAt": "2023-11-10T16:46:19Z",
              "updatedAt": "2023-11-10T16:46:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5m4puP",
          "commit": {
            "abbreviatedOid": "1d49cff"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-11T21:12:24Z",
          "updatedAt": "2023-11-11T21:12:24Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "You are referring to this specific line, right? `counter_share = y0[0] + y1[0] + cls.Field(agg_id)`\r\n\r\nWhich PLASMA check do you have in mind?",
              "createdAt": "2023-11-11T21:12:24Z",
              "updatedAt": "2023-11-11T21:12:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5nIrBu",
          "commit": {
            "abbreviatedOid": "1d49cff"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-14T17:32:50Z",
          "updatedAt": "2023-11-14T17:32:50Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "> You are referring to this specific line, right? `counter_share = y0[0] + y1[0] + cls.Field(agg_id)`\r\n\r\nYes.\r\n\r\n> Which PLASMA check do you have in mind?\r\n\r\nThis is the thing where we make sure the value programmed into the VIDPF (i.e., part of $\\beta$) is `1`.\r\n",
              "createdAt": "2023-11-14T17:32:50Z",
              "updatedAt": "2023-11-14T17:32:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5nKGK-",
          "commit": {
            "abbreviatedOid": "1d49cff"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-14T20:18:49Z",
          "updatedAt": "2023-11-14T20:18:49Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Not exactly. In PLASMA we do the following checks:\r\n* for the root level: we check that $H(1 - y_{S0}^0 - y_{S0}^1) == H(y_{S1}^0 + y_{S1}^1)$\r\n* for all other levels: we check that $H(y_{S0}^p - y_{S0}^{p||0} - y_{S0}^{p||1}) == H(-y_{S1}^p + y_{S1}^{p||0} + y_{S1}^{p||1})$\r\n\r\nSo the check that actually checks if beta is one is the first one for the root level.",
              "createdAt": "2023-11-14T20:18:49Z",
              "updatedAt": "2023-11-14T20:18:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5nP_8t",
          "commit": {
            "abbreviatedOid": "1d49cff"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-15T15:05:48Z",
          "updatedAt": "2023-11-15T15:05:48Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "I believe that's exactly what I'm doing here:\r\n```python\r\ncounter_share = y0[0] + y1[0] + cls.Field(agg_id)\r\n```\r\nExcept that the second server's share is not negated. (For some reason, the math works out this way in the current VIDPF implementation, as we noted on an earlier PR.)",
              "createdAt": "2023-11-15T15:05:48Z",
              "updatedAt": "2023-11-15T15:05:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5nRANV",
          "commit": {
            "abbreviatedOid": "f93dfbc"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-15T17:05:49Z",
          "updatedAt": "2023-11-15T17:05:49Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJmRsfc5nRzPg",
          "commit": {
            "abbreviatedOid": "f93dfbc"
          },
          "author": "hannahdaviscrypto",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "One possible bug in how the counter_share is used, but otherwise looks good to me. Thanks, Chris!",
          "createdAt": "2023-11-15T18:53:10Z",
          "updatedAt": "2023-11-15T18:55:58Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "I think this counter_share isn't getting returned by the VIDPF or included in the out_share?",
              "createdAt": "2023-11-15T18:53:11Z",
              "updatedAt": "2023-11-15T18:55:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5nUAMH",
          "commit": {
            "abbreviatedOid": "f93dfbc"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-16T00:49:06Z",
          "updatedAt": "2023-11-16T00:49:06Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "the `out_share` returned at the end of this function would include a share of  $1 \\|| \\beta$ if one of the prefixes is on the $\\alpha$ path. At this point we're just checking that the programmed value is indeed $1$.",
              "createdAt": "2023-11-16T00:49:06Z",
              "updatedAt": "2023-11-16T00:49:06Z"
            }
          ]
        }
      ]
    },
    {
      "number": 46,
      "id": "PR_kwDOJmRsfc5g8lNh",
      "title": "vidpf: Use the `Xof` API from the base draft for hashing",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/46",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #17.\r\n\r\nReplace SHA-3 with `XofShake128` (SHAKE128). This has two benefits:\r\n\r\n1. It simplifies domain separation, which will be useful if we end up needing to model instances of this object as random oracles in security proofs.\r\n\r\n2. It allows us to easily swap `XofShake128` with `XofTurboShake128` (TurboSHAKE128) as required in the next draft (draft-irtf-cfrg-vdaf-08).\r\n\r\nWe also replace update the base \"cs proof\" by using the SHA256 hash of a fixed string instead of SHA3. This is because SHA256 is more likely to be implemented in common cryptographic libraries.",
      "createdAt": "2023-12-02T00:52:04Z",
      "updatedAt": "2023-12-07T22:32:25Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "63d63d941191cb162814b5f0fee3082c44e49e3d",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/xof-cleanup",
      "headRefOid": "8c5e33cfb849b904c122fda229e63be4038e61d2",
      "closedAt": "2023-12-07T22:32:25Z",
      "mergedAt": "2023-12-07T22:32:25Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "48c38b7ce358e519e77761954b6a87ba6f9319bd"
      },
      "comments": [
        {
          "author": "hannahdaviscrypto",
          "authorAssociation": "COLLABORATOR",
          "body": "Small question: don't we need SHA3 (or another indifferentiable hash function) for the FLPs? So in the case where SHA256 is implemented but SHA3 isn't, Mastic may not be a good candidate regardless of the choice for the cs proof.",
          "createdAt": "2023-12-07T18:55:30Z",
          "updatedAt": "2023-12-07T18:55:30Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> Small question: don't we need SHA3 (or another indifferentiable hash function) for the FLPs? So in the case where SHA256 is implemented but SHA3 isn't, Mastic may not be a good candidate regardless of the choice for the cs proof.\r\n\r\nThis change is replacing SHA3 with SHAKE128, not SHA256. SHAKE128 is Keccak-based, just like SHA3.",
          "createdAt": "2023-12-07T19:28:47Z",
          "updatedAt": "2023-12-07T19:28:47Z"
        },
        {
          "author": "hannahdaviscrypto",
          "authorAssociation": "COLLABORATOR",
          "body": "> > Small question: don't we need SHA3 (or another indifferentiable hash function) for the FLPs? So in the case where SHA256 is implemented but SHA3 isn't, Mastic may not be a good candidate regardless of the choice for the cs proof.\r\n> \r\n> This change is replacing SHA3 with SHAKE128, not SHA256. SHAKE128 is Keccak-based, just like SHA3.\r\n\r\nSorry, miscommunication. My comment was in reference to the ROOT_PI_PROOF only, which this commit changes from a SHA3 digest to a SHA256 digest. The initial PR description suggests this is because SHA256 is more likely to be implemented, but we're going to need a Keccak implemenation regardless. ",
          "createdAt": "2023-12-07T21:27:32Z",
          "updatedAt": "2023-12-07T21:27:53Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> > > Small question: don't we need SHA3 (or another indifferentiable hash function) for the FLPs? So in the case where SHA256 is implemented but SHA3 isn't, Mastic may not be a good candidate regardless of the choice for the cs proof.\r\n> > \r\n> > \r\n> > This change is replacing SHA3 with SHAKE128, not SHA256. SHAKE128 is Keccak-based, just like SHA3.\r\n> \r\n> Sorry, miscommunication. My comment was in reference to the ROOT_PI_PROOF only, which this commit changes from a SHA3 digest to a SHA256 digest. The initial PR description suggests this is because SHA256 is more likely to be implemented, but we're going to need a Keccak implemenation regardless.\r\n\r\nThat's my bad, I didn't provide enough context.\r\n\r\nWe're using SHAKE, but when we align with the latest VDAF draft (draft-irtf-cfrg-vdaf-08), we will switch to TurboSHAKE. (See https://mailarchive.ietf.org/arch/msg/cfrg/cFTfEq9zWSzgnomY4TMEeXPcoVU/ for reasoning.) SHAKE and TurboSHAKE both use Keccak (as SHA3 does) but but TurboSHAKE uses half as many rounds. Thus an implementation of permutation may not be interchangeable.\r\n\r\nIn fact, the function we use to derive the root proof doesn't matter. I expect implementations to hard-code the hash in any case. We're sort of using this value as a salt: we want it to be unlikely that some other application would have the same hard-coded salt in it. We could just pick a random 32-byte number, but using a hash of a public value ensure there are no \"nothing-up-my-sleeve\" constants in the spec (https://words.filippo.io/dispatches/seeds-bounty/).\r\n\r\nI'd be happy to go back to using SHA3 instead.",
          "createdAt": "2023-12-07T21:38:37Z",
          "updatedAt": "2023-12-07T21:38:37Z"
        },
        {
          "author": "hannahdaviscrypto",
          "authorAssociation": "COLLABORATOR",
          "body": "> > > > Small question: don't we need SHA3 (or another indifferentiable hash function) for the FLPs? So in the case where SHA256 is implemented but SHA3 isn't, Mastic may not be a good candidate regardless of the choice for the cs proof.\r\n> > > \r\n> > > \r\n> > > This change is replacing SHA3 with SHAKE128, not SHA256. SHAKE128 is Keccak-based, just like SHA3.\r\n> > \r\n> > \r\n> > Sorry, miscommunication. My comment was in reference to the ROOT_PI_PROOF only, which this commit changes from a SHA3 digest to a SHA256 digest. The initial PR description suggests this is because SHA256 is more likely to be implemented, but we're going to need a Keccak implemenation regardless.\r\n> \r\n> That's my bad, I didn't provide enough context.\r\n> \r\n> We're using SHAKE, but when we align with the latest VDAF draft (draft-irtf-cfrg-vdaf-08), we will switch to TurboSHAKE. (See https://mailarchive.ietf.org/arch/msg/cfrg/cFTfEq9zWSzgnomY4TMEeXPcoVU/ for reasoning.) SHAKE and TurboSHAKE both use Keccak (as SHA3 does) but but TurboSHAKE uses half as many rounds. Thus an implementation of permutation may not be interchangeable.\r\n> \r\n> In fact, the function we use to derive the root proof doesn't matter. I expect implementations to hard-code the hash in any case. We're sort of using this value as a salt: we want it to be unlikely that some other application would have the same hard-coded salt in it. We could just pick a random 32-byte number, but using a hash of a public value ensure there are no \"nothing-up-my-sleeve\" constants in the spec (https://words.filippo.io/dispatches/seeds-bounty/).\r\n> \r\n> I'd be happy to go back to using SHA3 instead.\r\n\r\nNope, that makes perfect sense. Thanks for the additional explanation!",
          "createdAt": "2023-12-07T22:06:46Z",
          "updatedAt": "2023-12-07T22:06:46Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc5pie_i",
          "commit": {
            "abbreviatedOid": "e418dbb"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Nice!",
          "createdAt": "2023-12-07T17:05:53Z",
          "updatedAt": "2023-12-07T17:05:53Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJmRsfc5pjU8L",
          "commit": {
            "abbreviatedOid": "e418dbb"
          },
          "author": "hannahdaviscrypto",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I think there are a couple of changes here with implications for the proof/paper, we should confirm that we're all on the same page about them before merging.",
          "createdAt": "2023-12-07T19:09:19Z",
          "updatedAt": "2023-12-07T19:21:58Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "I think the prefix/node is getting left out here.",
              "createdAt": "2023-12-07T19:09:19Z",
              "updatedAt": "2023-12-07T19:21:58Z"
            },
            {
              "originalPosition": 85,
              "body": "Combining the one-hot and sum proofs into a single hash crosses the VIDPF abstraction boundary. I think it's likely okay from a security standpoint but we'll definitely want the change reflected in the paper.",
              "createdAt": "2023-12-07T19:18:30Z",
              "updatedAt": "2023-12-07T19:21:58Z"
            },
            {
              "originalPosition": 98,
              "body": "Again, the node is getting removed here.",
              "createdAt": "2023-12-07T19:19:31Z",
              "updatedAt": "2023-12-07T19:21:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5pjeOl",
          "commit": {
            "abbreviatedOid": "e418dbb"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-07T19:35:37Z",
          "updatedAt": "2023-12-07T19:38:17Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Good catch, I completely missed this. Modified `next_cs_proofI()` to take in the node as input. Please double check how the node is encoded.",
              "createdAt": "2023-12-07T19:35:37Z",
              "updatedAt": "2023-12-07T19:38:17Z"
            },
            {
              "originalPosition": 98,
              "body": "Done.",
              "createdAt": "2023-12-07T19:35:44Z",
              "updatedAt": "2023-12-07T19:38:17Z"
            },
            {
              "originalPosition": 85,
              "body": "How do you mean? (What is \"sum proof\" here?) The VIDPF proof is meant to ensure three things:\r\n1. The output is one-hot (`pi_proof`)\r\n2. The value of the counter is one (`counter`)\r\n3. Each node in the prefix tree is the sum of its children (`path`)",
              "createdAt": "2023-12-07T19:37:55Z",
              "updatedAt": "2023-12-07T19:38:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5pjohE",
          "commit": {
            "abbreviatedOid": "e418dbb"
          },
          "author": "hannahdaviscrypto",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-07T20:04:10Z",
          "updatedAt": "2023-12-07T20:04:11Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "At least in the paper, the VIDPF only guarantees 1. and 2. as you've numbered them. 3 is a separate check that PLASMA does on the VIDPF output shares, which is why it used a separate proof. This is at least partially because the path proof requires multiple VIDPF evaluations to generate, so it doesn't quite line up with the existing syntax.",
              "createdAt": "2023-12-07T20:04:11Z",
              "updatedAt": "2023-12-07T20:04:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5pjq1O",
          "commit": {
            "abbreviatedOid": "e418dbb"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-07T20:11:10Z",
          "updatedAt": "2023-12-07T20:11:10Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "I see. Since this issue suggested before this PR, I suggest we resolve it separately. Let's discuss with @jimouris in slack what we want to do about this.",
              "createdAt": "2023-12-07T20:11:10Z",
              "updatedAt": "2023-12-07T20:11:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5pkUZ4",
          "commit": {
            "abbreviatedOid": "8c5e33c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-07T21:04:50Z",
          "updatedAt": "2023-12-07T21:04:55Z",
          "comments": [
            {
              "originalPosition": 120,
              "body": "@hannahdaviscrypto are you happy with this?",
              "createdAt": "2023-12-07T21:04:50Z",
              "updatedAt": "2023-12-07T21:04:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5pkaxH",
          "commit": {
            "abbreviatedOid": "8c5e33c"
          },
          "author": "hannahdaviscrypto",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-07T21:24:30Z",
          "updatedAt": "2023-12-07T21:35:58Z",
          "comments": [
            {
              "originalPosition": 120,
              "body": "Yep",
              "createdAt": "2023-12-07T21:24:30Z",
              "updatedAt": "2023-12-07T21:35:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5pkob-",
          "commit": {
            "abbreviatedOid": "8c5e33c"
          },
          "author": "hannahdaviscrypto",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-07T22:05:16Z",
          "updatedAt": "2023-12-07T22:05:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 47,
      "id": "PR_kwDOJmRsfc5hFYSd",
      "title": "Coalesce the helper's proof share seed and blind",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/47",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #45.",
      "createdAt": "2023-12-04T17:53:12Z",
      "updatedAt": "2023-12-07T20:11:39Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "63d63d941191cb162814b5f0fee3082c44e49e3d",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/45",
      "headRefOid": "9c6eff3ee8e06460ae779d1bd108fff537ecc95f",
      "closedAt": "2023-12-07T20:11:38Z",
      "mergedAt": "2023-12-07T20:11:38Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "6dba358ee6b2a0155c29f6152d2ddcf265ddc1b7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc5pifkM",
          "commit": {
            "abbreviatedOid": "39021b1"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-12-07T17:07:15Z",
          "updatedAt": "2023-12-07T17:07:32Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "flp_pleader_seed -> flp_leader_seed",
              "createdAt": "2023-12-07T17:07:16Z",
              "updatedAt": "2023-12-07T17:07:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5pi8nl",
          "commit": {
            "abbreviatedOid": "39021b1"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-07T18:03:49Z",
          "updatedAt": "2023-12-07T18:03:49Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "Done.",
              "createdAt": "2023-12-07T18:03:49Z",
              "updatedAt": "2023-12-07T18:03:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5pi-tE",
          "commit": {
            "abbreviatedOid": "b9c39d1"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-07T18:09:15Z",
          "updatedAt": "2023-12-07T18:09:15Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJmRsfc5pjaes",
          "commit": {
            "abbreviatedOid": "b9c39d1"
          },
          "author": "hannahdaviscrypto",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Mostly just variable name suggestions but I think line 400 does need a double-check.",
          "createdAt": "2023-12-07T19:25:16Z",
          "updatedAt": "2023-12-07T19:36:05Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "Change this to (vidpf_init_seed, flp_proof_share, flp_seed) since we've gotten rid of the \"blinds\"?",
              "createdAt": "2023-12-07T19:27:28Z",
              "updatedAt": "2023-12-07T19:36:05Z"
            },
            {
              "originalPosition": 95,
              "body": "Change to flp_seed for consistency?",
              "createdAt": "2023-12-07T19:30:36Z",
              "updatedAt": "2023-12-07T19:36:05Z"
            },
            {
              "originalPosition": 103,
              "body": "<= not >? We only need a leader seed if the joint randomness is present.",
              "createdAt": "2023-12-07T19:33:27Z",
              "updatedAt": "2023-12-07T19:36:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5pjgFe",
          "commit": {
            "abbreviatedOid": "b9c39d1"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-07T19:41:06Z",
          "updatedAt": "2023-12-07T19:41:07Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "Done. I also changed `k_blind` to `flp_seed` in `joint_rand_part()`.",
              "createdAt": "2023-12-07T19:41:07Z",
              "updatedAt": "2023-12-07T19:41:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5pjgmZ",
          "commit": {
            "abbreviatedOid": "b9c39d1"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-07T19:42:32Z",
          "updatedAt": "2023-12-07T19:44:08Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "Done.",
              "createdAt": "2023-12-07T19:42:32Z",
              "updatedAt": "2023-12-07T19:44:08Z"
            },
            {
              "originalPosition": 103,
              "body": "/giphy Piccard face palm\r\n\r\nDone.",
              "createdAt": "2023-12-07T19:43:34Z",
              "updatedAt": "2023-12-07T19:44:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5pjnru",
          "commit": {
            "abbreviatedOid": "9c6eff3"
          },
          "author": "hannahdaviscrypto",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good to me!",
          "createdAt": "2023-12-07T20:01:43Z",
          "updatedAt": "2023-12-07T20:01:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 50,
      "id": "PR_kwDOJmRsfc5hd4gk",
      "title": "Editorial changes",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/50",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This makes a few editorial changes from my first read-through of the document and proof of concept implementation. See the individual commit messages for explanations.",
      "createdAt": "2023-12-07T21:45:32Z",
      "updatedAt": "2023-12-18T22:15:08Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "6dba358ee6b2a0155c29f6152d2ddcf265ddc1b7",
      "headRepository": "divergentdave/draft-mouris-cfrg-mastic",
      "headRefName": "david/editorial",
      "headRefOid": "117c31a310a4b017ae4906ce50bd855958a1a41a",
      "closedAt": "2023-12-18T22:15:08Z",
      "mergedAt": "2023-12-18T22:15:08Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "eb319759575476027244cb0c7d88739839b51b44"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc5pk4X7",
          "commit": {
            "abbreviatedOid": "3bdfabf"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-07T23:10:41Z",
          "updatedAt": "2023-12-07T23:10:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJmRsfc5pvbS4",
          "commit": {
            "abbreviatedOid": "3bdfabf"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-10T14:04:16Z",
          "updatedAt": "2023-12-10T14:04:16Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "This one is a bit tricky as one-hotness alone implies only that the sum is non-zero at one position. We need both properties together to be sure that this non-zero value is indeed `beta` (which we have checked at the root with the FLP).",
              "createdAt": "2023-12-10T14:04:16Z",
              "updatedAt": "2023-12-10T14:04:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5pvbh8",
          "commit": {
            "abbreviatedOid": "3bdfabf"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "CHANGES_REQUESTED",
          "body": "Looks great, thanks for reading through it! I only have the small comment about one-hotness + path verifiability.",
          "createdAt": "2023-12-10T14:09:12Z",
          "updatedAt": "2023-12-10T14:09:12Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJmRsfc5p4Oeo",
          "commit": {
            "abbreviatedOid": "117c31a"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-11T23:30:13Z",
          "updatedAt": "2023-12-11T23:30:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 52,
      "id": "PR_kwDOJmRsfc5iTcKI",
      "title": "Add public share to joint randomness derivation",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/52",
      "state": "MERGED",
      "author": "hannahdaviscrypto",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes Fiat-Shamir vulnarability highlighted in Issue #48 ",
      "createdAt": "2023-12-18T20:37:33Z",
      "updatedAt": "2024-01-12T16:54:59Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "eb319759575476027244cb0c7d88739839b51b44",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "hannahdaviscrypto/pub-share",
      "headRefOid": "708c9b96b594118cbf3058324f81ea47417781b4",
      "closedAt": "2024-01-12T16:54:59Z",
      "mergedAt": "2024-01-12T16:54:59Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "797ff495ad4bb7e5898f24812802ab5b6bfcefa5"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@hannahdaviscrypto it looks like you need to rebase your branch on main: \r\n![image](https://github.com/jimouris/draft-mouris-cfrg-mastic/assets/3453007/ed1b9823-704e-4756-bda4-dc4e53d321d9)\r\n",
          "createdAt": "2023-12-18T20:42:07Z",
          "updatedAt": "2023-12-18T20:42:07Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc5qj6mq",
          "commit": {
            "abbreviatedOid": "8821b3e"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-18T22:17:19Z",
          "updatedAt": "2023-12-18T22:21:32Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "For consistency (plus `beta_share` is not rthe right term!)\r\n```suggestion\r\n    def joint_rand_part(cls, agg_id, flp_seed, vidpf_key, vidpf_public_share, nonce):\r\n```",
              "createdAt": "2023-12-18T22:17:19Z",
              "updatedAt": "2023-12-18T23:18:10Z"
            },
            {
              "originalPosition": 33,
              "body": "Better aligned with terminology from the VDAF draft\r\n```suggestion\r\n            cls.Vidpf.encode_public_share(public_share),\r\n```",
              "createdAt": "2023-12-18T22:18:24Z",
              "updatedAt": "2023-12-18T22:21:32Z"
            },
            {
              "originalPosition": 42,
              "body": "Why make this change? Did the linter suggest this?\r\n\r\nIn Python3 I believe the convention is to terminate every item in a list with a comma, even the last. (This is the convention in more modern programming languages.)",
              "createdAt": "2023-12-18T22:19:31Z",
              "updatedAt": "2023-12-18T22:21:32Z"
            },
            {
              "originalPosition": 5,
              "body": "Prefer `bytes` instead of `Bytes`: https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/222",
              "createdAt": "2023-12-18T22:20:07Z",
              "updatedAt": "2023-12-18T22:21:32Z"
            },
            {
              "originalPosition": 13,
              "body": "It might be best to crib this from the base draft: https://github.com/cfrg/draft-irtf-cfrg-vdaf/blob/3d2dd77befcf149c818b4bae1744e60c00d0a4f3/poc/idpf_poplar.py#L194",
              "createdAt": "2023-12-18T22:21:24Z",
              "updatedAt": "2023-12-18T22:21:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5qo_-H",
          "commit": {
            "abbreviatedOid": "8821b3e"
          },
          "author": "hannahdaviscrypto",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-19T15:25:31Z",
          "updatedAt": "2023-12-19T15:25:31Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Gotcha. This also needs to be changed in draft-irtf-cfrg-vdaf/poc/Field.py.",
              "createdAt": "2023-12-19T15:25:31Z",
              "updatedAt": "2023-12-19T15:25:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5qpATP",
          "commit": {
            "abbreviatedOid": "8821b3e"
          },
          "author": "hannahdaviscrypto",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-19T15:26:11Z",
          "updatedAt": "2023-12-19T15:26:11Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Picked the wrong branch in the merge. Fixed now.",
              "createdAt": "2023-12-19T15:26:11Z",
              "updatedAt": "2023-12-19T15:26:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5qpDuM",
          "commit": {
            "abbreviatedOid": "8821b3e"
          },
          "author": "hannahdaviscrypto",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-19T15:32:58Z",
          "updatedAt": "2023-12-19T15:32:58Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Can't use it directly but I did steal the method of packing the control bits, thanks!",
              "createdAt": "2023-12-19T15:32:58Z",
              "updatedAt": "2023-12-19T15:32:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5qpNZE",
          "commit": {
            "abbreviatedOid": "708c9b9"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-19T15:52:22Z",
          "updatedAt": "2023-12-19T15:52:22Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJmRsfc5qpNlf",
          "commit": {
            "abbreviatedOid": "8821b3e"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-19T15:52:45Z",
          "updatedAt": "2023-12-19T15:52:45Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "If you have a sec, please send a PR :)",
              "createdAt": "2023-12-19T15:52:45Z",
              "updatedAt": "2023-12-19T15:52:45Z"
            }
          ]
        }
      ]
    },
    {
      "number": 54,
      "id": "PR_kwDOJmRsfc5j9GmG",
      "title": "Upgrade reference to base draft",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/54",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In draft-08, SHAKE was replaced with TurboSHAKE, so upgrade the dependency accordingly.\r\n\r\nThe latest version of the main branch has been checked out rather than the tagged version (draft-irtf-cfrg-vdaf-08). This is because the latest version resolves a technical issue regarding the implementation of TurboSHAKE. This was resolved by upgrading PyCryptodomex to the latest version:\r\n\r\n$ sage -pip install --upgrade pycryptodomex\r\n\r\nVersion 3.20.0 is required.",
      "createdAt": "2024-01-12T17:54:57Z",
      "updatedAt": "2024-01-15T17:32:33Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "797ff495ad4bb7e5898f24812802ab5b6bfcefa5",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/upgrade-base-draft",
      "headRefOid": "1304dca2a3e33c4c4fb0f87f49b5d6f5dfc2ecf9",
      "closedAt": "2024-01-15T17:32:33Z",
      "mergedAt": "2024-01-15T17:32:33Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "9f2c8eb3b02c13e80250e71c1f4515a75140ac4d"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Reviewer note: you'll need to update your submodule. I think this works:\r\n```\r\n$ git submodule update --recursive --remote\r\n```",
          "createdAt": "2024-01-12T17:55:16Z",
          "updatedAt": "2024-01-12T17:55:16Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc5smnVG",
          "commit": {
            "abbreviatedOid": "1304dca"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-15T17:16:20Z",
          "updatedAt": "2024-01-15T17:16:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 56,
      "id": "PR_kwDOJmRsfc5lFcfO",
      "title": "Add script for benchmarking communication cost",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/56",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-01-25T16:34:15Z",
      "updatedAt": "2024-01-29T21:53:02Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "9f2c8eb3b02c13e80250e71c1f4515a75140ac4d",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/poplar1-overhaead",
      "headRefOid": "ef85bf668cc77b942772c5bb8426260175598e7e",
      "closedAt": "2024-01-29T21:53:02Z",
      "mergedAt": "2024-01-29T21:53:02Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "8e182826804438207e4c4b73f7555250605e3003"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc5uM9_6",
          "commit": {
            "abbreviatedOid": "ef85bf6"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-29T15:01:16Z",
          "updatedAt": "2024-01-29T15:01:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 57,
      "id": "PR_kwDOJmRsfc5mMCzq",
      "title": "Compare overhead of Prio3 for attribute-based metrics",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/57",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-02-06T20:31:22Z",
      "updatedAt": "2024-02-13T16:10:05Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "8e182826804438207e4c4b73f7555250605e3003",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/prio3-overhead",
      "headRefOid": "76c1439372bc78c09c2c6ff69adbebaa7ebd541a",
      "closedAt": "2024-02-13T16:10:05Z",
      "mergedAt": "2024-02-13T16:10:05Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "a521374cb60b93ac671644fd3dc7a46cf19f7688"
      },
      "comments": [
        {
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "body": "@cjpatton reminder to merge this :)",
          "createdAt": "2024-02-13T13:43:30Z",
          "updatedAt": "2024-02-13T13:43:30Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc5vPlJM",
          "commit": {
            "abbreviatedOid": "76c1439"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-06T21:30:36Z",
          "updatedAt": "2024-02-06T21:30:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 60,
      "id": "PR_kwDOJmRsfc5oOXaM",
      "title": "Add applications",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/60",
      "state": "MERGED",
      "author": "jimouris",
      "authorAssociation": "OWNER",
      "assignees": [
        "jimouris"
      ],
      "labels": [],
      "body": "Closes #59 ",
      "createdAt": "2024-02-28T22:00:41Z",
      "updatedAt": "2024-02-29T01:58:27Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "7a10cd2f562add30d5b2e8751397adc9b25b217b",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "jimouris/applications",
      "headRefOid": "778e9b628b5b25e0c1d6295c1fd1b02961ad178f",
      "closedAt": "2024-02-29T01:58:24Z",
      "mergedAt": "2024-02-29T01:58:24Z",
      "mergedBy": "jimouris",
      "mergeCommit": {
        "oid": "e513a33c882075ca8c0cc0bb702225c5896872ea"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc5xtHWt",
          "commit": {
            "abbreviatedOid": "6b95814"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-28T23:39:14Z",
          "updatedAt": "2024-02-28T23:53:23Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "```suggestion\r\n# Motivating Applications\r\n```",
              "createdAt": "2024-02-28T23:39:14Z",
              "updatedAt": "2024-02-28T23:53:23Z"
            },
            {
              "originalPosition": 106,
              "body": "```suggestion\r\n### Network Error Logging {#NEL}\r\n\r\n```",
              "createdAt": "2024-02-28T23:39:21Z",
              "updatedAt": "2024-02-28T23:53:23Z"
            },
            {
              "originalPosition": 100,
              "body": "Let's make this a subsection of the intro.",
              "createdAt": "2024-02-28T23:39:47Z",
              "updatedAt": "2024-02-28T23:53:23Z"
            },
            {
              "originalPosition": 139,
              "body": "**This doesn't render the way you want it to in all version of internet drafts**.\r\n\r\n```suggestion\r\nMPC helps mitigate these risks by revealing to the\r\n```",
              "createdAt": "2024-02-28T23:40:30Z",
              "updatedAt": "2024-02-28T23:53:23Z"
            },
            {
              "originalPosition": 118,
              "body": "Internet-Drafts shouldn't reference specific companies or institutions. \"Content delivery network\" is clear enough to the intended audience.\r\n\r\n```suggestion\r\nNEL is particularly important for content delivery networks that handle HTTP traffic for a large number of websites\r\n```",
              "createdAt": "2024-02-28T23:42:23Z",
              "updatedAt": "2024-02-28T23:53:23Z"
            },
            {
              "originalPosition": 160,
              "body": "```suggestion\r\n* Each input `alpha` encodes the domain `dom` truncated to `n = 256`\r\n```",
              "createdAt": "2024-02-28T23:42:52Z",
              "updatedAt": "2024-02-28T23:53:23Z"
            },
            {
              "originalPosition": 164,
              "body": "```suggestion\r\n0s.\r\n\r\n* Each weight `beta` represents the error variant `dom`. To compute\r\n```",
              "createdAt": "2024-02-28T23:43:16Z",
              "updatedAt": "2024-02-28T23:53:23Z"
            },
            {
              "originalPosition": 171,
              "body": "Note that unicode charcters, like \"\u00b7\", should not appear in internet drafts. With the exception of authors, it's a good idea to make sure every character is ASCII.\r\n```suggestion\r\nvectors over `F` containing all 0s except for a single 1.\r\n\r\n* Our `order` function computes the ratio of reports with `err\r\n```",
              "createdAt": "2024-02-28T23:44:05Z",
              "updatedAt": "2024-02-28T23:53:23Z"
            },
            {
              "originalPosition": 171,
              "body": "Make sure we have defined `order` for the reader, probably in the conventions section.",
              "createdAt": "2024-02-28T23:46:24Z",
              "updatedAt": "2024-02-28T23:53:23Z"
            },
            {
              "originalPosition": 186,
              "body": "```suggestion\r\n## Attribute-Based Browser Telemetry {#attribute-based-telemetry}\r\n\r\n```",
              "createdAt": "2024-02-28T23:46:48Z",
              "updatedAt": "2024-02-28T23:53:23Z"
            },
            {
              "originalPosition": 187,
              "body": "```suggestion\r\nWeb browsers collect telemetry generated by\r\n```",
              "createdAt": "2024-02-28T23:47:01Z",
              "updatedAt": "2024-02-28T23:53:23Z"
            },
            {
              "originalPosition": 193,
              "body": "```suggestion\r\na list of known popular sites (e.g., `example.com`). The purpose of these metrics\r\n```",
              "createdAt": "2024-02-28T23:47:09Z",
              "updatedAt": "2024-02-28T23:53:23Z"
            },
            {
              "originalPosition": 192,
              "body": "We'll need to remove mention Mozilla by name and speak about a hypothetical browser.",
              "createdAt": "2024-02-28T23:47:44Z",
              "updatedAt": "2024-02-28T23:53:23Z"
            },
            {
              "originalPosition": 198,
              "body": "This is Mozilla's preference, but others might do something else.\r\n```suggestion\r\nby client attributes. Suppose for example that we want to aggregate by 1) the software version,\r\nand 2) information about the client's location.\r\n```",
              "createdAt": "2024-02-28T23:48:51Z",
              "updatedAt": "2024-02-28T23:53:23Z"
            },
            {
              "originalPosition": 201,
              "body": "Have we actually mentioned this? We did in the paper, but I'm not sure we made the Prio3 comparison here.\r\n\r\nFWIW, I don't think we necessarily need to. could we just remove this paragraph without interrupting the flow?",
              "createdAt": "2024-02-28T23:49:39Z",
              "updatedAt": "2024-02-28T23:53:23Z"
            },
            {
              "originalPosition": 208,
              "body": "```suggestion\r\nMastic provides a simple solution to\r\n```",
              "createdAt": "2024-02-28T23:50:40Z",
              "updatedAt": "2024-02-28T23:53:23Z"
            },
            {
              "originalPosition": 211,
              "body": "```suggestion\r\nwhich Prio3 ({{Section 7 of !VDAF}}) is suitable). Each client reports a tuple `(ver, loc, site, time)`\r\n```",
              "createdAt": "2024-02-28T23:51:48Z",
              "updatedAt": "2024-02-28T23:53:23Z"
            },
            {
              "originalPosition": 213,
              "body": "```suggestion\r\nwhere: `ver` is a string representing the client's software version; `loc` is a string encoding its country code (e.g., `GR`, `US`,\r\n```",
              "createdAt": "2024-02-28T23:52:17Z",
              "updatedAt": "2024-02-28T23:53:23Z"
            },
            {
              "originalPosition": 214,
              "body": "```suggestion\r\n`IN`, etc.); `site` is one of a fixed set of sites (e.g., `example.com`,\r\n```",
              "createdAt": "2024-02-28T23:52:26Z",
              "updatedAt": "2024-02-28T23:53:23Z"
            },
            {
              "originalPosition": 230,
              "body": "```suggestion\r\n\r\n* Similar to private NEL, each weight `beta` is a 0-vector except\r\n```",
              "createdAt": "2024-02-28T23:53:06Z",
              "updatedAt": "2024-02-28T23:53:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5xtQRI",
          "commit": {
            "abbreviatedOid": "6b95814"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-29T00:13:52Z",
          "updatedAt": "2024-02-29T00:13:52Z",
          "comments": [
            {
              "originalPosition": 201,
              "body": "good catch.",
              "createdAt": "2024-02-29T00:13:52Z",
              "updatedAt": "2024-02-29T00:13:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc5xtiWG",
          "commit": {
            "abbreviatedOid": "eb7ee4f"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-29T01:19:41Z",
          "updatedAt": "2024-02-29T01:19:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 61,
      "id": "PR_kwDOJmRsfc5oO4OR",
      "title": "Rename \"aggregation-by-labels\" to \"attribute-based metrics\"",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/61",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #58.",
      "createdAt": "2024-02-29T00:08:29Z",
      "updatedAt": "2024-02-29T01:19:52Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "4d4470ae4871f59db5a4249e510d82cfcd5e25d3",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjaptton/58",
      "headRefOid": "35e77218c9936feb9d7dd41410a34989cbbfe6e0",
      "closedAt": "2024-02-29T01:19:52Z",
      "mergedAt": "2024-02-29T01:19:52Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "7a10cd2f562add30d5b2e8751397adc9b25b217b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc5xtR_E",
          "commit": {
            "abbreviatedOid": "35e7721"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-29T00:22:15Z",
          "updatedAt": "2024-02-29T00:22:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 63,
      "id": "PR_kwDOJmRsfc57E68i",
      "title": "Update actions to match the VDAF draft",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/63",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The GitHub actions for the VDAF draft include various improvements, including running unit tests, type checking, and linting. Update our actions to match theirs make the changes necessary to pass the checks.\r\n\r\n* Remove submodule for draft-irtf-cfrg-vdaf; we can now install this from pip directly.\r\n\r\n* Move the tests into their own directory and invoke them with the unittest module. This revealed a few issues:\r\n\r\n  * The VIDPF tests needed some adjusting: we had modified the code so that the output share includes the counter, but never updated the tests to account for this. This was not being checked by the current GitHub actions.\r\n\r\n  * `Vdaf` no longer has a class method called `domain_separation_tag()`. Implement this here, using the Mastic draft version instead of the VDAF draft version.\r\n\r\n  * `FlpGeneric` was renamed to `FlpBBCGGI19` and its attribute `Field` was renamed to `field`. Relatedly, the circuit constructor takes in a field as input.\r\n\r\n* Enforce type hints and fix misalignments with the `Vdaf` API. The main change is that we've dropped the class factory pattern in favor of more conventional Python OOP. Likewise for `Vidpf`.\r\n\r\n* Remove `do_range_check: bool` from the prep state and let this be determined by whether `corrected_joint_rand_seed: Optional[bytes]` is set.\r\n\r\n    * Note: enforcing types revealed a few awkward bits of control flow,\r\n      including this.",
      "createdAt": "2024-09-10T23:35:25Z",
      "updatedAt": "2024-09-11T20:14:25Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "0eac487749b601aacb3fa0c0cd990a62f065ded0",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/update-ci",
      "headRefOid": "b01f4f2251af22301ca23a0146bc83c8bf894098",
      "closedAt": "2024-09-11T20:14:25Z",
      "mergedAt": "2024-09-11T20:14:25Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "296698483fc89c3bd140cbc8a833afecae9b94d8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc6I9418",
          "commit": {
            "abbreviatedOid": "2602c8c"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Nice, thanks for doing this. Everything looks way cleaner now.\r\n\r\nI just have some minor and consistency comments.",
          "createdAt": "2024-09-11T16:47:58Z",
          "updatedAt": "2024-09-11T17:01:54Z",
          "comments": [
            {
              "originalPosition": 289,
              "body": "Should this be:\r\n```suggestion\r\n    def is_valid(self,\r\n                 agg_param: MasticAggParam,\r\n                 previous_agg_params: list[MasticAggParam],\r\n    ) -> bool:\r\n```\r\nfor consistency?",
              "createdAt": "2024-09-11T16:47:58Z",
              "updatedAt": "2024-09-11T17:02:08Z"
            },
            {
              "originalPosition": 307,
              "body": "same here",
              "createdAt": "2024-09-11T16:52:54Z",
              "updatedAt": "2024-09-11T17:01:54Z"
            },
            {
              "originalPosition": 387,
              "body": "don't we nee the `do_range_check` anymore?",
              "createdAt": "2024-09-11T16:54:51Z",
              "updatedAt": "2024-09-11T17:01:54Z"
            },
            {
              "originalPosition": 443,
              "body": "```suggestion\r\n                  prep_msg: MasticPrepMessage,\r\n       ) -> list[F]:\r\n```",
              "createdAt": "2024-09-11T16:55:44Z",
              "updatedAt": "2024-09-11T17:01:54Z"
            },
            {
              "originalPosition": 467,
              "body": "```suggestion\r\n                  out_shares: list[list[F]],\r\n         ) -> list[F]:\r\n```",
              "createdAt": "2024-09-11T16:56:10Z",
              "updatedAt": "2024-09-11T17:01:54Z"
            },
            {
              "originalPosition": 481,
              "body": "```suggestion\r\n                _num_measurements: int,\r\n      ) -> list[AggResult]:\r\n```",
              "createdAt": "2024-09-11T16:57:11Z",
              "updatedAt": "2024-09-11T17:01:54Z"
            },
            {
              "originalPosition": 543,
              "body": "```suggestion\r\n                        nonce: bytes,\r\n        ) -> bytes:\r\n```",
              "createdAt": "2024-09-11T16:57:33Z",
              "updatedAt": "2024-09-11T17:01:54Z"
            },
            {
              "originalPosition": 585,
              "body": "```suggestion\r\n            self, \r\n            input_share: MasticInputShare,\r\n      ) -> bytes:\r\n```",
              "createdAt": "2024-09-11T16:58:19Z",
              "updatedAt": "2024-09-11T17:01:54Z"
            },
            {
              "originalPosition": 601,
              "body": "```suggestion\r\n            self,\r\n            public_share: MasticPublicShare,\r\n     ) -> bytes:\r\n```",
              "createdAt": "2024-09-11T16:58:31Z",
              "updatedAt": "2024-09-11T17:01:54Z"
            },
            {
              "originalPosition": 622,
              "body": "same",
              "createdAt": "2024-09-11T16:58:42Z",
              "updatedAt": "2024-09-11T17:01:55Z"
            },
            {
              "originalPosition": 629,
              "body": "same",
              "createdAt": "2024-09-11T16:58:44Z",
              "updatedAt": "2024-09-11T17:01:55Z"
            },
            {
              "originalPosition": 797,
              "body": "we had `Sum(2)` and now it became `Sum(.., 3)`. Was the +1 implied before or a typo here?",
              "createdAt": "2024-09-11T16:59:41Z",
              "updatedAt": "2024-09-11T17:01:55Z"
            },
            {
              "originalPosition": 836,
              "body": "for example, here it is the same (no +1)",
              "createdAt": "2024-09-11T16:59:56Z",
              "updatedAt": "2024-09-11T17:01:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc6I-N2U",
          "commit": {
            "abbreviatedOid": "2602c8c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-11T17:12:16Z",
          "updatedAt": "2024-09-11T17:16:16Z",
          "comments": [
            {
              "originalPosition": 387,
              "body": "I don't think it's necessary and it made type checking a little more complex. `correction_joint_rand_seed` has type `Optional[bytes]`: if it's not `None`, then we'll do the range check; otherwise we don't.",
              "createdAt": "2024-09-11T17:12:16Z",
              "updatedAt": "2024-09-11T17:16:16Z"
            },
            {
              "originalPosition": 797,
              "body": "The parameterize of `Sum` has changed: instead of taking a number of bits, it takes the maximum measurement, which no longer needs to be a power of 2.",
              "createdAt": "2024-09-11T17:14:36Z",
              "updatedAt": "2024-09-11T17:16:16Z"
            },
            {
              "originalPosition": 836,
              "body": "Here we're changing the maximum measurement from $2^8 - 1$ to $8$, but the test doesn't care, so I just left it as-is.",
              "createdAt": "2024-09-11T17:15:58Z",
              "updatedAt": "2024-09-11T17:16:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc6I-U6l",
          "commit": {
            "abbreviatedOid": "2602c8c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-11T17:19:48Z",
          "updatedAt": "2024-09-11T17:19:48Z",
          "comments": [
            {
              "originalPosition": 307,
              "body": "I applied your suggested formatting changes, but then CI complained about some of them (`autopep8`). I updated the formatting to make CI happy.\r\n\r\nI'm not sure if your linting is optimal, but to be honest I'm not too worried about it right now. Feel free to shoot a PR with tweaks if you find something that looks nicer but still complies with CI.",
              "createdAt": "2024-09-11T17:19:48Z",
              "updatedAt": "2024-09-11T17:19:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc6I-VHH",
          "commit": {
            "abbreviatedOid": "2602c8c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-11T17:20:01Z",
          "updatedAt": "2024-09-11T17:20:01Z",
          "comments": [
            {
              "originalPosition": 307,
              "body": "Of course, tweaking CI is an option as well.",
              "createdAt": "2024-09-11T17:20:01Z",
              "updatedAt": "2024-09-11T17:20:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc6I-i0N",
          "commit": {
            "abbreviatedOid": "2602c8c"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-11T17:37:06Z",
          "updatedAt": "2024-09-11T17:37:06Z",
          "comments": [
            {
              "originalPosition": 307,
              "body": "I think it needs a comma at the end of 243 and then it'll probably work",
              "createdAt": "2024-09-11T17:37:06Z",
              "updatedAt": "2024-09-11T17:37:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc6I-jcd",
          "commit": {
            "abbreviatedOid": "49180a0"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-09-11T17:37:56Z",
          "updatedAt": "2024-09-11T17:37:56Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJmRsfc6I_wsJ",
          "commit": {
            "abbreviatedOid": "2602c8c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-11T19:19:22Z",
          "updatedAt": "2024-09-11T19:19:22Z",
          "comments": [
            {
              "originalPosition": 307,
              "body": "Done.",
              "createdAt": "2024-09-11T19:19:22Z",
              "updatedAt": "2024-09-11T19:19:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 64,
      "id": "PR_kwDOJmRsfc57O77W",
      "title": "Harmonize VIDPF with upstream",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/64",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #51.\r\nPartially addresses #34 (there are changes coming in -12).\r\n\r\nApply various improvements for IDPF in the base draft to VIDPF and simplify things a bit.\r\n\r\n* Merge \"cs proofs\" into correction words\r\n\r\n* Harmonize variable names across key generation and evaluation\r\n\r\n* Align `Vidpf` API closer to `Idpf` API in the base draft:\r\n\r\n    * Rename \"binder\" to \"nonce\" and require to have fixed length\r\n\r\n    * Reorder the public share and keys\r\n\r\n* Use the same method for extending a seed as for the IDPF in the base draft (borrow control bits from the seeds in order to avoid an additional AES call).\r\n\r\n* Discourage branching on secret values, including control bits and `alpha` on the client side.",
      "createdAt": "2024-09-12T00:39:25Z",
      "updatedAt": "2024-09-12T19:46:00Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "296698483fc89c3bd140cbc8a833afecae9b94d8",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/34-1",
      "headRefOid": "486b81cbfaafb2c7a64ebec3450f76928acce7d0",
      "closedAt": "2024-09-12T19:46:00Z",
      "mergedAt": "2024-09-12T19:46:00Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "3cdd7faa7d283c02ceb47bf5b6267921ca5fdb62"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc6JGaG8",
          "commit": {
            "abbreviatedOid": "e6f8ac6"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-09-12T12:29:36Z",
          "updatedAt": "2024-09-12T12:32:04Z",
          "comments": [
            {
              "originalPosition": 419,
              "body": "What we had before here avoided branching:\r\n```\r\ns[0] = xor(s[0], prev_ctrl.conditional_select(seed_cw))  # s^L\r\ns[1] = xor(s[1], prev_ctrl.conditional_select(seed_cw))  # s^R\r\nt[0] += ctrl_cw[0] * prev_ctrl  # t^L\r\nt[1] += ctrl_cw[1] * prev_ctrl  # t^R\r\n```\r\nWhat you added is cleaner but introduces branching. Is there any other benefit we get?",
              "createdAt": "2024-09-12T12:29:36Z",
              "updatedAt": "2024-09-12T12:32:04Z"
            },
            {
              "originalPosition": 457,
              "body": ",\\n",
              "createdAt": "2024-09-12T12:30:43Z",
              "updatedAt": "2024-09-12T12:32:04Z"
            },
            {
              "originalPosition": 487,
              "body": ",\\n",
              "createdAt": "2024-09-12T12:30:54Z",
              "updatedAt": "2024-09-12T12:32:04Z"
            },
            {
              "originalPosition": 508,
              "body": ",\\n",
              "createdAt": "2024-09-12T12:31:12Z",
              "updatedAt": "2024-09-12T12:32:04Z"
            },
            {
              "originalPosition": 530,
              "body": "```suggestion\r\n        for (seed_cw, _ctrl_cw, w_cw, proof) in correction_words:\r\n```\r\n?",
              "createdAt": "2024-09-12T12:31:43Z",
              "updatedAt": "2024-09-12T12:32:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc6JKn-B",
          "commit": {
            "abbreviatedOid": "e6f8ac6"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-12T19:40:01Z",
          "updatedAt": "2024-09-12T19:40:01Z",
          "comments": [
            {
              "originalPosition": 419,
              "body": "Clearer is better I think: I'm trying to make this code as readable as possible. It's up to implementations to make things constant time.",
              "createdAt": "2024-09-12T19:40:01Z",
              "updatedAt": "2024-09-12T19:40:01Z"
            }
          ]
        }
      ]
    },
    {
      "number": 65,
      "id": "PR_kwDOJmRsfc57W6wL",
      "title": "Improve readability and add some unittests",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/65",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-09-12T21:32:55Z",
      "updatedAt": "2024-09-13T16:24:41Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "3cdd7faa7d283c02ceb47bf5b6267921ca5fdb62",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/34-2",
      "headRefOid": "373709535194b6ac5ec1941dc0be7b21d75e2357",
      "closedAt": "2024-09-13T16:24:41Z",
      "mergedAt": "2024-09-13T16:24:41Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "7d0a4116f8901d82ede37c084c7940c5eb2d153b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc6JLeJf",
          "commit": {
            "abbreviatedOid": "3737095"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-12T21:52:23Z",
          "updatedAt": "2024-09-12T21:52:23Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "@jimouris any insights here?",
              "createdAt": "2024-09-12T21:52:23Z",
              "updatedAt": "2024-09-12T21:52:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc6JL-k8",
          "commit": {
            "abbreviatedOid": "3737095"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-13T00:24:15Z",
          "updatedAt": "2024-09-13T00:24:15Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "Alrighty, I've widdled this down a bit, but there's still somewhat of a gap in my understanding: https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/66/files#r1757748172",
              "createdAt": "2024-09-13T00:24:15Z",
              "updatedAt": "2024-09-13T00:25:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc6JTR5u",
          "commit": {
            "abbreviatedOid": "3737095"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-09-13T16:17:52Z",
          "updatedAt": "2024-09-13T16:19:08Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Nice one",
              "createdAt": "2024-09-13T16:17:52Z",
              "updatedAt": "2024-09-13T16:19:08Z"
            }
          ]
        }
      ]
    },
    {
      "number": 66,
      "id": "PR_kwDOJmRsfc57XeMu",
      "title": "Harmonize proof computation with the rest of the code",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/66",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Stacked on #65 (merge that first).\r\n\r\nWhat we previously referred to as `pi_prime` is now the \"node proof\". The node proof is corrected much like the seed, control bit, and payload.\r\n\r\nRename `pi_proof_adjustment()` to `adjusted_proof()`, getting rid of the last reference to \"pi\".\r\n\r\nFinally, replace the zero seed in `eval_proof()` and `adjusted_proof()` with the proof we want to \"hash forward\". As of draft-irtf-cfrg-vdaf-12, XofTurboShake128 can handle variable length seeds.",
      "createdAt": "2024-09-13T00:16:18Z",
      "updatedAt": "2024-09-13T16:31:50Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "7d0a4116f8901d82ede37c084c7940c5eb2d153b",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/34-3",
      "headRefOid": "19be4b553cfa89958b1ab39977cbf5eb2fbb1dd0",
      "closedAt": "2024-09-13T16:31:50Z",
      "mergedAt": "2024-09-13T16:31:50Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "386827a56fad8be898bc6a13aac7b774891d4232"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased.",
          "createdAt": "2024-09-13T16:25:50Z",
          "updatedAt": "2024-09-13T16:25:50Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc6JL-v5",
          "commit": {
            "abbreviatedOid": "fe401e1"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-13T00:25:23Z",
          "updatedAt": "2024-09-13T00:25:24Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "@jimouris I haven't quite figured out where my analysis is going wrong.",
              "createdAt": "2024-09-13T00:25:23Z",
              "updatedAt": "2024-09-13T00:25:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc6JSc9-",
          "commit": {
            "abbreviatedOid": "fe401e1"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-13T14:39:04Z",
          "updatedAt": "2024-09-13T14:39:04Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "I figured out what's going on :)",
              "createdAt": "2024-09-13T14:39:04Z",
              "updatedAt": "2024-09-13T14:39:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc6JTS2z",
          "commit": {
            "abbreviatedOid": "fe401e1"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-13T16:20:06Z",
          "updatedAt": "2024-09-13T16:20:07Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "Was the test wrong?",
              "createdAt": "2024-09-13T16:20:06Z",
              "updatedAt": "2024-09-13T16:20:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc6JTVSD",
          "commit": {
            "abbreviatedOid": "fe401e1"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-13T16:26:05Z",
          "updatedAt": "2024-09-13T16:26:05Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "See updated comment: there was a case that I missed.",
              "createdAt": "2024-09-13T16:26:05Z",
              "updatedAt": "2024-09-13T16:26:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc6JTXp3",
          "commit": {
            "abbreviatedOid": "19be4b5"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-09-13T16:30:21Z",
          "updatedAt": "2024-09-13T16:30:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 67,
      "id": "PR_kwDOJmRsfc57e4PL",
      "title": "Change traversal order, more encapsulation",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/67",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #49.\r\n\r\nPlus, add more encapsulation so that it's easier to refactor.\r\n\r\ncc/ @divergentdave",
      "createdAt": "2024-09-13T21:23:18Z",
      "updatedAt": "2024-09-16T22:49:38Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "386827a56fad8be898bc6a13aac7b774891d4232",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/49",
      "headRefOid": "0180bba191f9a88df518af07e801ef2a75af9344",
      "closedAt": "2024-09-16T22:49:38Z",
      "mergedAt": "2024-09-16T22:49:38Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "12c1c9975cb127013ccbcacd78cb085af169aac3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc6Jeaxg",
          "commit": {
            "abbreviatedOid": "e8b145d"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-09-16T12:06:13Z",
          "updatedAt": "2024-09-16T12:09:42Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "Could you add a comment here on what the test does so it's easier for people to read it? It should be clear already but more comments would be good.",
              "createdAt": "2024-09-16T12:06:13Z",
              "updatedAt": "2024-09-16T12:09:42Z"
            },
            {
              "originalPosition": 70,
              "body": "I'm a bit confused with the `+ 1` and `i - 1`, could you explain it in a comment?",
              "createdAt": "2024-09-16T12:09:04Z",
              "updatedAt": "2024-09-16T12:09:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc6JkJ-B",
          "commit": {
            "abbreviatedOid": "e8b145d"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-16T22:43:39Z",
          "updatedAt": "2024-09-16T22:43:39Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "Done.",
              "createdAt": "2024-09-16T22:43:39Z",
              "updatedAt": "2024-09-16T22:43:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc6JkKmi",
          "commit": {
            "abbreviatedOid": "e8b145d"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-16T22:46:49Z",
          "updatedAt": "2024-09-16T22:46:49Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Done.",
              "createdAt": "2024-09-16T22:46:49Z",
              "updatedAt": "2024-09-16T22:46:49Z"
            }
          ]
        }
      ]
    },
    {
      "number": 68,
      "id": "PR_kwDOJmRsfc57fCLY",
      "title": "Move Mastic examples to their own file and clean up imports",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/68",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Stacked on #67.",
      "createdAt": "2024-09-13T22:06:54Z",
      "updatedAt": "2024-09-16T22:58:34Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "12c1c9975cb127013ccbcacd78cb085af169aac3",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/cleanup-examples",
      "headRefOid": "96cd5d0d06a8f786602a1a5355d505c1cde2de46",
      "closedAt": "2024-09-16T22:58:28Z",
      "mergedAt": "2024-09-16T22:58:28Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "4dea20f09b71c77fa45e1f4841445c9521e3ff7d"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased.",
          "createdAt": "2024-09-16T22:50:36Z",
          "updatedAt": "2024-09-16T22:50:36Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc6Jec7r",
          "commit": {
            "abbreviatedOid": "69a4053"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-09-16T12:10:17Z",
          "updatedAt": "2024-09-16T12:10:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 69,
      "id": "PR_kwDOJmRsfc57fGUh",
      "title": "Use `bool` for control bits instead of `Field2`",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/69",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Stacked on #68.\r\n\r\nThis makes the code a bit clearer.",
      "createdAt": "2024-09-13T22:22:46Z",
      "updatedAt": "2024-09-16T23:40:29Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "4dea20f09b71c77fa45e1f4841445c9521e3ff7d",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/cleanup-2-field2",
      "headRefOid": "c4a2a182c1784ac796d7df05d537ad1a8bbe4616",
      "closedAt": "2024-09-16T23:05:30Z",
      "mergedAt": "2024-09-16T23:05:30Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "fc2bbcd4781e7995d527f99e127b9d0c5c4587ee"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc6JefPn",
          "commit": {
            "abbreviatedOid": "0bdf6cc"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-09-16T12:14:56Z",
          "updatedAt": "2024-09-16T12:22:04Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "maybe `node[0].ctrl != node[1].ctrl` for clarity?",
              "createdAt": "2024-09-16T12:14:57Z",
              "updatedAt": "2024-09-16T12:22:04Z"
            },
            {
              "originalPosition": 45,
              "body": "assert `node[0].ctrl == node[1].ctrl`",
              "createdAt": "2024-09-16T12:15:28Z",
              "updatedAt": "2024-09-16T12:22:04Z"
            },
            {
              "originalPosition": 54,
              "body": "Can we use the Boolean `not` instead of XOR here?",
              "createdAt": "2024-09-16T12:17:45Z",
              "updatedAt": "2024-09-16T12:22:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc6JkNMt",
          "commit": {
            "abbreviatedOid": "0bdf6cc"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-16T23:00:20Z",
          "updatedAt": "2024-09-16T23:00:20Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Done.",
              "createdAt": "2024-09-16T23:00:20Z",
              "updatedAt": "2024-09-16T23:00:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc6JkNRr",
          "commit": {
            "abbreviatedOid": "0bdf6cc"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-16T23:00:46Z",
          "updatedAt": "2024-09-16T23:00:46Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Done.",
              "createdAt": "2024-09-16T23:00:46Z",
              "updatedAt": "2024-09-16T23:00:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc6JkNiQ",
          "commit": {
            "abbreviatedOid": "0bdf6cc"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-16T23:02:02Z",
          "updatedAt": "2024-09-16T23:02:02Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Done.",
              "createdAt": "2024-09-16T23:02:02Z",
              "updatedAt": "2024-09-16T23:02:02Z"
            }
          ]
        }
      ]
    },
    {
      "number": 70,
      "id": "PR_kwDOJmRsfc57fV3O",
      "title": "Clean up TODOs",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/70",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Stacked on #69.\r\nPartially addresses #34.\r\n\r\n* Harmonize code used for domain separation. At the moment, we overload `Vdaf.domain_separation_tag()` to use our own `VERSION`, but we invoke `format_tag()`, which uses the version from the VDAF draft. Eventually we'll want to use our own version for both; for the moment, the minimally invasive change is to just use upstream.\r\n\r\n* Add a NOTE about an apparent bug that's blocking us from making the XOF generic. This may be a `Vdaf` bug or a bug with `Generic` itself. While at it, deduplicate the code for deriving the prove randomness.\r\n\r\n* Modify query randomness derivation by binding to the level. We only generate query randomness once, so this may not be strictly necessary. But this does provide domain separation whenever the aggregation starts at different levels.\r\n\r\n    * Note: The TODO suggested binding to the aggregation parameter as\r\n      well, but this doesn't seem necessary as the FLP can only be used\r\n      once.\r\n\r\n* Align correction word encoding with the IDPF specification in the base draft. Note that the considerations are a little different because we don't have a concept of \"inner field\" versus \"leaf field\", but consistency is nice.\r\n\r\n* Rename the \"counter\" to the \"counter check\" and the \"path\" to the \"payload check\".\r\n\r\n* Refer to the \"VIDPF proof\" from {{MST24}} as the \"path proof\". This is to distinguish it from the \"evaluation proof\", which includes the path proof and the counter and payload checks.",
      "createdAt": "2024-09-13T23:43:28Z",
      "updatedAt": "2024-09-17T13:24:24Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "fc2bbcd4781e7995d527f99e127b9d0c5c4587ee",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/cleanup-3-generic-xof",
      "headRefOid": "07ff1931fbe2c3c4ef99027de3fd6ecf9d39afad",
      "closedAt": "2024-09-17T13:22:45Z",
      "mergedAt": "2024-09-17T13:22:44Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "0ecef036dfa80afe540e2cc2cc41bd7aa4afc48e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc6JkU_4",
          "commit": {
            "abbreviatedOid": "07ff193"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "looks good!",
          "createdAt": "2024-09-16T23:44:36Z",
          "updatedAt": "2024-09-16T23:44:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 74,
      "id": "PR_kwDOJmRsfc57zxN7",
      "title": "Clean up domain separation",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/74",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #71.\r\n\r\nReplace `Vdaf.domain_separation_tag()` and `format_dst()` with a method `dst()` defined here and that uses the version of our document rather than draft-irtf-cfrg-vdaf.",
      "createdAt": "2024-09-17T19:59:57Z",
      "updatedAt": "2024-09-18T19:22:35Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "92cce7ac53f2d49ffe2b253eac2528a6a41a3713",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/dst",
      "headRefOid": "df1ff9f694c4d179a495c871065fb621ca0c6d71",
      "closedAt": "2024-09-18T19:07:48Z",
      "mergedAt": "2024-09-18T19:07:48Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "dedc85a05f87a4e07ba5c4002cefe56a01fe8e0d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc6J4yZd",
          "commit": {
            "abbreviatedOid": "df1ff9f"
          },
          "author": "jimouris",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-09-18T17:43:01Z",
          "updatedAt": "2024-09-18T17:45:28Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I don't understand the comment above. Shouldn't this version match https://datatracker.ietf.org/doc/draft-mouris-cfrg-mastic? (i.e., `02`). ",
              "createdAt": "2024-09-18T17:43:02Z",
              "updatedAt": "2024-09-18T17:45:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc6J5RIF",
          "commit": {
            "abbreviatedOid": "df1ff9f"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-18T18:38:47Z",
          "updatedAt": "2024-09-18T18:38:47Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "If/when this gets adopted, it'll be as a new draft, which would be called `draft-irtf-cfrg-mastic-00`.",
              "createdAt": "2024-09-18T18:38:47Z",
              "updatedAt": "2024-09-18T18:38:47Z"
            }
          ]
        }
      ]
    },
    {
      "number": 75,
      "id": "PR_kwDOJmRsfc58OFpg",
      "title": "Clean up Mastic a bit",
      "url": "https://github.com/jimouris/draft-mouris-cfrg-mastic/pull/75",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "* Fix some awkwardness in the control flow that was revealed when we added type enforcement (296698483fc89c3bd140cbc8a833afecae9b94d8). The main goal was to reduce the number of type assertions we needed.\r\n\r\n* Remove \"flp_\" and \"vidpf_\" prefixes from variable names wherever which primitive they're associated with is clear in context.\r\n\r\n* Avoid nesting the term \"public share\". In other words, Mastic's public is composed of VIDPF correction words and FLP joint rand parts; make these components explicit. This avoids confusing variable aliases, like `flp_public_share = joint_rand_parts`.\r\n\r\n* Make `is_valid()` stricter by preventing aggregating at the same level of the VIDPF tree more than once. We don't know if this is secure, and in any case, this behavior isn't covered by the current proof. Also, try and make the spec of `is_valid()` a little simpler.\r\n\r\n* Align the FLP joint randomness confirmation with @hannahdaviscrypto's implementation. Namely, the prep share includes the aggregator's joint randomness part, and `prep_shares_to_prep()` combines them into the true joint randomness seed. Then `prep_next()` just confirms that the true joint randomness seed matches the one it computed during `prep_init()`.\r\n\r\n* Add a unit test that exercises Mastic with joint randomness. We had been testing this, with the `Sum` circuit; but the `Sum` circuit no longer uses joint randomness in the latest version of the base draft.\r\n\r\n* Improve `is_valid()` unit tests by replacing `assert`s with `self.assertTrue()`s.",
      "createdAt": "2024-09-20T22:28:34Z",
      "updatedAt": "2024-09-20T23:00:32Z",
      "baseRepository": "jimouris/draft-mouris-cfrg-mastic",
      "baseRefName": "main",
      "baseRefOid": "dedc85a05f87a4e07ba5c4002cefe56a01fe8e0d",
      "headRepository": "jimouris/draft-mouris-cfrg-mastic",
      "headRefName": "cjpatton/pass-of-mastic",
      "headRefOid": "93c5f9c484849e7df6d8fc059f0b4378f480ef13",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJmRsfc6KQFOn",
          "commit": {
            "abbreviatedOid": "93c5f9c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-20T22:29:02Z",
          "updatedAt": "2024-09-20T22:29:02Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Removing the nested `Optional` improves control flow.",
              "createdAt": "2024-09-20T22:29:02Z",
              "updatedAt": "2024-09-20T22:29:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJmRsfc6KQFW7",
          "commit": {
            "abbreviatedOid": "93c5f9c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-20T22:29:54Z",
          "updatedAt": "2024-09-20T22:29:54Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "We don't want to allow aggregating at the same level twice.",
              "createdAt": "2024-09-20T22:29:54Z",
              "updatedAt": "2024-09-20T22:29:54Z"
            }
          ]
        }
      ]
    }
  ]
}