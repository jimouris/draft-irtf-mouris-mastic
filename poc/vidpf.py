"""Verifiable Distributed Point Function (VIDPF)"""

import sys
sys.path.append('draft-irtf-cfrg-vdaf/poc')

from common import \
    ERR_INPUT, \
    Bytes, \
    format_dst, \
    gen_rand, \
    vec_add, \
    vec_sub, \
    vec_neg, \
    xor
import hashlib
import ring
from prg import PrgFixedKeyAes128

class Vidpf:
    """A Verifiable Distributed Point Function (VIDPF)."""

    # Number of keys generated by the vidpf-key generation algorithm.
    SHARES = 2

    # Bit length of valid input values (i.e., the length of `alpha` in bits).
    BITS = 16

    # The length of each output vector (i.e., the length of `beta_leaf`).
    VALUE_LEN = 2

    # Size in bytes of each vidpf key share.
    KEY_SIZE = PrgFixedKeyAes128.SEED_SIZE

    # Number of random bytes consumed by the `gen()` algorithm.
    RAND_SIZE = 2 * PrgFixedKeyAes128.SEED_SIZE

    # A nonce.
    BINDER = b'some nonce'

    # The ring used to represent the leaf nodes of the vidpf tree.
    RING = ring.Ring16

    # The ring for the control bits.
    R2 = ring.Ring2

    @classmethod
    def gen(cls, alpha, beta, rand):
        '''
        https://eprint.iacr.org/2023/080.pdf VIDPF.Gen
        '''
        if alpha >= 2**cls.BITS:
            raise ERR_INPUT # alpha too long
        if len(rand) != cls.RAND_SIZE:
            raise ERR_INPUT # unexpected length for random input

        init_seed = [
            rand[:PrgFixedKeyAes128.SEED_SIZE],
            rand[PrgFixedKeyAes128.SEED_SIZE:],
        ]

        # s0^0, s1^0, t0^0, t1^0
        seed = init_seed.copy()
        ctrl = [cls.R2(0), cls.R2(1)]
        correction_words = []
        cs_proofs = []
        alpha_less_than_i = 0
        for i in range(cls.BITS):
            alpha_i = (alpha >> (cls.BITS - i - 1)) & 1
            alpha_less_than_i = (alpha_less_than_i << 1) + alpha_i
            keep, lose = (1, 0) if alpha_i else (0, 1) # if x = 0 then keep <- L, lose <- R

            (s_0, t_0) = cls.extend(seed[0]) # s_0^L || s_0^R || t_0^L || t_0^R
            (s_1, t_1) = cls.extend(seed[1]) # s_1^L || s_1^R || t_1^L || t_1^R
            seed_cw = xor(s_0[lose], s_1[lose])
            ctrl_cw = (
                t_0[0] + t_1[0] + cls.R2(1) + cls.R2(alpha_i), # t_c^L
                t_0[1] + t_1[1] + cls.R2(alpha_i),             # t_c^R
            )

            (seed[0], w_0) = cls.convert(correct(s_0[keep], seed_cw, ctrl[0]), i)
            (seed[1], w_1) = cls.convert(correct(s_1[keep], seed_cw, ctrl[1]), i)
            ctrl[0] = correct(t_0[keep], ctrl_cw[keep], ctrl[0]) # t0'
            ctrl[1] = correct(t_1[keep], ctrl_cw[keep], ctrl[1]) # t1'

            w_cw = vec_add(vec_sub(beta, w_0), w_1)
            mask = cls.RING(1) - cls.RING(2) * cls.RING(ctrl[1].as_unsigned())
            for j in range(len(w_cw)):
                w_cw[j] *= mask

            # Compute hashes for level i
            sha3 = hashlib.sha3_256()
            sha3.update(str(alpha_less_than_i).encode('ascii') + seed[0])
            proof_0 = sha3.digest()
            sha3 = hashlib.sha3_256()
            sha3.update(str(alpha_less_than_i).encode('ascii') + seed[1])
            proof_1 = sha3.digest()

            cs_proofs.append(xor(proof_0, proof_1))
            correction_words.append((seed_cw, ctrl_cw, w_cw))

        return (init_seed, correction_words, cs_proofs)

    @classmethod
    def eval(cls, agg_id, correction_words, init_seed, level, prefixes, cs_proofs):
        if agg_id >= cls.SHARES:
            raise ERR_INPUT  # invalid aggregator ID
        if level >= cls.BITS:
            raise ERR_INPUT  # level too deep
        if len(set(prefixes)) != len(prefixes):
            raise ERR_INPUT  # candidate prefixes are non-unique

        out_share = {}
        for prefix in prefixes:
            if prefix >= 2 ** (level+1):
                raise ERR_INPUT  # prefix too long

            # The Aggregator's output share is the value of a node of
            # the IDPF tree at the given `level`. The node's value is
            # computed by traversing the path defined by the candidate
            # `prefix`. Each node in the tree is represented by a seed
            # (`seed`) and a set of control bits (`ctrl`).
            seed = init_seed
            ctrl = cls.R2(agg_id)
            x_less_than_i = 0
            for current_level in range(level+1):
                x_i = (prefix >> (level - current_level)) & 1
                x_less_than_i = (x_less_than_i << 1) + x_i

                pi_proof = cs_proofs[current_level]
                # Implementation note: Typically the current round of
                # candidate prefixes would have been derived from
                # aggregate results computed during previous rounds. For
                # example, when using `IdpfPoplar` to compute heavy
                # hitters, a string whose hit count exceeded the given
                # threshold in the last round would be the prefix of each
                # `prefix` in the current round. (See [BBCGGI21,
                # Section 5.1].) In this case, part of the path would
                # have already been traversed.
                #
                # Re-computing nodes along previously traversed paths is
                # wasteful. Implementations can eliminate this added
                # complexity by caching nodes (i.e., `(seed, ctrl)`
                # pairs) output by previous calls to `eval_next()`.

                (seed, ctrl, y, pi_proof) = cls.eval_next(
                    seed,
                    ctrl,
                    correction_words[current_level],
                    cs_proofs[current_level],
                    current_level,
                    x_less_than_i,
                    pi_proof
                )
            out_share[prefix] = (y if agg_id == 0 else vec_neg(y))
        return out_share, pi_proof

    @classmethod
    def eval_extend(cls, agg_id, correction_words, init_seed, level,
                    prefixes, cs_proofs):
        if agg_id >= cls.SHARES:
            raise ERR_INPUT  # invalid aggregator ID
        if level >= cls.BITS-1:
            raise ERR_INPUT  # level too deep
        if len(set(prefixes)) != len(prefixes):
            raise ERR_INPUT  # candidate prefixes are non-unique

        out_share = {}
        cache = {}
        for prefix in prefixes:
            if prefix >= 2 ** (level+1):
                raise ERR_INPUT  # prefix too long

            # The Aggregator's output share is the value of a node of
            # the IDPF tree at the given `level`. The node's value is
            # computed by traversing the path defined by the candidate
            # `prefix`. Each node in the tree is represented by a seed
            # (`seed`) and a set of control bits (`ctrl`).
            seed = init_seed
            ctrl = cls.R2(agg_id)
            x_less_than_i = 0
            for current_level in range(level+1):
                x_i = (prefix >> (level - current_level)) & 1
                x_less_than_i = (x_less_than_i << 1) + x_i

                pi_proof = cs_proofs[current_level]
                # Implementation note: Typically the current round of
                # candidate prefixes would have been derived from
                # aggregate results computed during previous rounds. For
                # example, when using `IdpfPoplar` to compute heavy
                # hitters, a string whose hit count exceeded the given
                # threshold in the last round would be the prefix of each
                # `prefix` in the current round. (See [BBCGGI21,
                # Section 5.1].) In this case, part of the path would
                # have already been traversed.
                #
                # Re-computing nodes along previously traversed paths is
                # wasteful. Implementations can eliminate this added
                # complexity by caching nodes (i.e., `(seed, ctrl)`
                # pairs) output by previous calls to `eval_next()`.

                (seed, ctrl, y, pi_proof) = cls.eval_next(
                    seed,
                    ctrl,
                    correction_words[current_level],
                    cs_proofs[current_level],
                    current_level,
                    x_less_than_i,
                    pi_proof
                )
            out_share[prefix] = (y if agg_id == 0 else vec_neg(y))
            cache[prefix] = (seed, ctrl, x_less_than_i)
        return out_share, pi_proof, cache
    
    @classmethod
    def eval_level(cls, cache, correction_word, level, prefixes, pi_proof):
        if agg_id >= cls.SHARES:
            raise ERR_INPUT  # invalid aggregator ID
        if level >= cls.BITS:
            raise ERR_INPUT  # level too deep
        if len(set(prefixes)) != len(prefixes):
            raise ERR_INPUT  # candidate prefixes are non-unique

        out_share = {}
        cs_proof = pi_proof
        for prefix in prefixes:
            if prefix >= 2 ** (level+1):
                raise ERR_INPUT  # prefix too long

            # The Aggregator's output share is the value of a node of
            # the IDPF tree at the given `level`. The node's value is
            # computed by traversing the path defined by the candidate
            # `prefix`. Each node in the tree is represented by a seed
            # (`seed`) and a set of control bits (`ctrl`).
            seed, ctrl, x_less_than_i = cache[prefix>>1]
            x_i = (prefix >> level) & 1
            x_less_than_i = (x_less_than_i << 1) + x_i

            (_, _, y, pi_proof) = cls.eval_next(
                seed,
                ctrl,
                correction_word,
                cs_proof,
                x_less_than_i,
                cs_proof
            )
            out_share[prefix] = (y if agg_id == 0 else vec_neg(y))
        return out_share, pi_proof

    @classmethod
    def eval_next(cls, prev_seed, prev_ctrl, correction_word, cs_proof,
                  level, x_less_than_i, pi_proof):
        """
        Compute the next node in the VIDPF tree along the path determined by
        a candidate prefix. The next node is determined by `bit`, the bit of
        the prefix corresponding to the next level of the tree.
        """
        (seed_cw, ctrl_cw, w_cw) = correction_word

        (s, t) = cls.extend(prev_seed) # (s^L, s^R), (t^L, t^R) = PRG(s^{i-1})
        s[0] = xor(s[0], prev_ctrl.conditional_select(seed_cw)) # s^L
        s[1] = xor(s[1], prev_ctrl.conditional_select(seed_cw)) # s^R
        t[0] += ctrl_cw[0] * prev_ctrl # t^L
        t[1] += ctrl_cw[1] * prev_ctrl # t^R

        x_i = x_less_than_i & 1
        next_ctrl = t[x_i] # t'^i
        (next_seed, w) = cls.convert(s[x_i], level) # s^i, W^i
        # Implementation note: Here we add the correction word to the
        # output if `next_ctrl` is set. We avoid branching on the value of
        # the control bit in order to reduce side channel leakage.
        y = []
        mask = cls.RING(next_ctrl.as_unsigned())
        for i in range(len(w)):
            y.append(w[i] + w_cw[i] * mask)

        # TODO(@jimouris): Update x_i to be x_{<=i}
        sha3 = hashlib.sha3_256()
        # pi' = H(x^{<= i} || s^i)
        sha3.update(str(x_less_than_i).encode('ascii') + next_seed)
        pi_prime = sha3.digest()

        # \pi = \pi xor H(\pi \xor (proof_prime \xor next_ctrl * cs_proof))
        sha3 = hashlib.sha3_256()
        if next_ctrl.as_unsigned() == 1:
            h2 = xor(pi_proof, xor(pi_prime, cs_proof))
        else:
            h2 = xor(pi_proof, pi_prime)
        sha3.update(h2)
        pi_proof = xor(pi_proof, sha3.digest())

        return (next_seed, next_ctrl, y, pi_proof)

    @classmethod
    def verify(cls, proof_0, proof_1):
        '''Check proofs'''
        return proof_0 == proof_1

    @classmethod
    def extend(cls, seed):
        '''
        Extend seed to (seed_L, t_L, seed_R, t_R)
        '''
        prg = PrgFixedKeyAes128(seed, format_dst(1, 0, 0), cls.BINDER)
        new_seed = [
            prg.next(PrgFixedKeyAes128.SEED_SIZE),
            prg.next(PrgFixedKeyAes128.SEED_SIZE),
        ]
        bit = prg.next(1)[0]
        ctrl = [cls.R2(bit & 1), cls.R2((bit >> 1) & 1)]
        return (new_seed, ctrl)

    @classmethod
    def convert(cls, seed, level = BITS):
        # TODO(jimouris): level is currently unused.
        '''
        Converting seed to a pseudorandom element of G.
        '''
        prg = PrgFixedKeyAes128(seed, format_dst(1, 0, 1), cls.BINDER)
        next_seed = prg.next(PrgFixedKeyAes128.SEED_SIZE)
        # TODO(cjpatton) This is slightly abusing the `Prg` API, as
        # `next_vec()` expects a `Field` as its first parameter. Either
        # re-implement the method here (if the ring modulus is a power of 2,
        # then this should be quite easy) or update the `Prg` upstream to take
        # a `Ring` and make `Field` a subclass of `Ring`.
        return (next_seed, prg.next_vec(cls.RING, cls.VALUE_LEN))


def correct(k_0, k_1, ctrl):
    ''' return k_0 if ctrl == 0 else xor(k_0, k_1) '''
    if isinstance(k_0, Bytes):
        return xor(k_0, ctrl.conditional_select(k_1))
    if isinstance(k_0, list): # list of ints or ring elements
        for i in range(len(k_0)):
            k_0[i] += ctrl * k_1[i]
        return k_0
    # int or ring element
    return k_0 + ctrl * k_1


def main():
    '''Driver'''
    vidpf = Vidpf
    vidpf.VALUE_LEN = 1
    vidpf.BITS = 2
    vidpf.BINDER = b'some nonce'

    measurements = [0b10, 0b00, 0b11, 0b01, 0b11] # alpha values from different users
    beta = vidpf.RING.ones(vidpf.BITS)
    prefixes = [0b0, 0b1]
    level = 0

    out = [vidpf.RING.zeros(vidpf.VALUE_LEN)] * len(prefixes)
    for measurement in measurements:
        rand = gen_rand(vidpf.RAND_SIZE)
        init_seed, correction_words, cs_proofs = vidpf.gen(measurement, beta, rand)

        proofs = []
        for agg_id in range(vidpf.SHARES):
            y_id, pi_id = vidpf.eval(agg_id, correction_words, init_seed[agg_id], level, prefixes, cs_proofs)

            proofs.append(pi_id)
            for i in range(len(prefixes)):
                out[i] = vec_add(out[i], y_id[i])
        assert vidpf.verify(proofs[0], proofs[1])

    print('Aggregated:', out)
    assert out == [[vidpf.RING(2)], [vidpf.RING(3)]]


    vidpf.BITS = 16
    measurements = [
        0b1111000011110000, 0b1111000011110001, 0b1111000011110010, 0b0000010011110010
        ] # alpha values from different users
    beta = vidpf.RING.ones(vidpf.BITS)
    prefixes = [0b000001, 0b111100]
    level = 5

    out = [vidpf.RING.zeros(vidpf.VALUE_LEN)] * len(prefixes)
    for measurement in measurements:
        rand = gen_rand(vidpf.RAND_SIZE)
        init_seed, correction_words, cs_proofs = vidpf.gen(measurement, beta, rand)

        proofs = []
        for agg_id in range(vidpf.SHARES):
            y_id, pi_id = vidpf.eval(agg_id, correction_words, init_seed[agg_id], level, prefixes, cs_proofs)

            proofs.append(pi_id)
            for i in range(len(prefixes)):
                out[i] = vec_add(out[i], y_id[i])
        assert vidpf.verify(proofs[0], proofs[1])

    print('Aggregated:', out)
    assert out == [[vidpf.RING(1)], [vidpf.RING(3)]]


if __name__ == '__main__':
    main()
