---
title: "The Mastic VDAF"
abbrev: "Mastic"
category: info

docname: draft-mouris-cfrg-mastic-latest
submissiontype: IRTF
number:
date:
consensus: true
v: 3
area: "IRTF"
workgroup: "Crypto Forum"
keyword:
  - Internet-Draft
venue:
  group: "Crypto Forum"
  type: "Research Group"
  mail: "cfrg@ietf.org"
  arch: "https://mailarchive.ietf.org/arch/search/?email_list=cfrg"
  github: "jimouris/draft-mouris-cfrg-mastic"
<!--   latest: https://example.com/LATEST -->

author:
 -
    fullname: Hannah Davis
    email: hannahedavis@protonmail.com
 -
    fullname: Dimitris Mouris
    organization: University of Delaware
    email: jimouris@udel.edu
 -
    name: Christopher Patton
    organization: Cloudflare
    email: chrispatton+ietf@gmail.com
 -
    fullname: Pratik Sarkar
    organization: Supra Research
    email: pratik93@bu.edu
 -
    fullname: Nektarios G. Tsoutsos
    organization: University of Delaware
    email: tsoutsos@udel.edu

normative:

informative:

  BBCGGI21:
    title: "Lightweight Techniques for Private Heavy Hitters"
    author:
      - ins: D. Boneh
      - ins: E. Boyle
      - ins: H. Corrigan-Gibbs
      - ins: N. Gilboa
      - ins: Y. Ishai
    date: 2021
    seriesinfo: IEEE S&P 2021
    target: https://ia.cr/2021/017

  CP22:
    title: "Lightweight, Maliciously Secure Verifiable Function Secret Sharing"
    author:
      - ins: Leo de Castro
      - ins: Antigoni Polychroniadou
    date : 2022
    seriesinfo: EUROCRYPT 2022
    target: https://iacr.org/cryptodb/data/paper.php?pubkey=31935

  DPRS23:
    title: "Verifiable Distributed Aggregation Functions"
    author:
      - ins: H. Davis
      - ins: C. Patton
      - ins: M. Rosulek
      - ins: P. Schoppmann
    date: 2023
    seriesinfo: Proceedings on Privacy Enhancing Technologies (PoPETs)
    target: https://doi.org/10.56553/popets-2023-0126

  GI14:
    title: "Distributed Point Functions and Their Applications"
    author:
      - ins: N. Gilboa
      - ins: Y. Ishai
    date: 2014
    seriesinfo: EUROCRYPT 2014
    target: https://link.springer.com/chapter/10.1007/978-3-642-55220-5_35

  MST23:
    title: "PLASMA: Private, Lightweight Aggregated Statistics against Malicious Adversaries"
    author:
      - ins: Dimitris Mouris
      - ins: Pratik Sarkar
      - ins: Nektarios Georgios Tsoutsos
    date : 2023
    target: https://ia.cr/2023/080

--- abstract

This document describes Mastic, a two-party VDAF for the following aggregation
task: each client holds a string, and the collector wishes to count how many of
these strings begin with a given prefix. Such a VDAF can be used to solve the
private heavy hitters problem, where the goal is to compute the subset of the
strings that occur most frequently without learning which client holds which
string. This document also describes different modes of operation for Mastic
that support additional use cases and admit various performance and security
trade-offs.

--- middle

# Introduction

> TO BE REMOVED BY RFC EDITOR: The source for this draft and the reference code
> can be found at https://github.com/jimouris/draft-mouris-cfrg-mastic.

The "private heavy hitters" problem is to recover the most popular measurements
generated by clients without learning the measurements themselves. For
example, a browser vendor might want to know which websites are visited most
frequently without learning which clients visited which websites. For string
measurements, this problem can be solved by combining a binary search with a
subroutine solving the "private prefix histogram" subproblem. The goal of this
subproblem is to compute a histogram over the fixed-length prefixes of client
measurement strings without revealing the prefixes. The subproblem can be
solved using a Verifiabile Distributed Aggregation Function, or VDAF
{{!VDAF=I-D.draft-irtf-cfrg-vdaf-07}}. In particular, the Poplar1 VDAF
described in {{Section 8 of !VDAF}} describes how to distribute this
computation amongst a small set of aggregation servers such that, as long as
one server is honest, no individual measurement is observed in the clear. At
the same time, Poplar1 allows the servers to detect and remove any invalid
measurements that would otherwise corrupt the computation of the histogram.

This document describes Mastic, a VDAF that can be used as a drop-in
replacement for Poplar1, while offering improved performance and communication
cost. [CP: We'll need numbers to back this up.] Based on the PLASMA protocol
{{MST23}}, the scheme's design also improves communication complexity, requiring
just one round for report preparation compared to Poplar1's two rounds. Mastic
is specified in {{vdaf}}.

Mastic is also highly extensible. Like Poplar1, Mastic's core functionality is
to compute how many of the measurements -- here viewed as bit strings of some
fixed length -- begin with a given prefix string. (Over several rounds of
aggregation, the prefix counting can be used to compute the heavy hitters as
described in {{Section 8 of !VDAF}}.) Mastic allows this basic counter data
type to be generalized to support a wide variety of secure aggregation tasks.
In particular, Mastic supports any data type that can be expressed as a type
for the Prio3 VDAF {{Section 7 of !VDAF}}. For example, the counter could be
replaced with a bounded weight (say, representing a dollar amount) such
that the "heaviest weight" measurements are recovered. We describe this
mode of operation in {{weighted-heavy-hitters}}.

This generalization also allows Mastic to support another important use case. A
desirable feature for a secure aggregation systems is the ability to "drill
down" on the data by splitting up the aggregate based on specific properties of
the clients. For example, a browser vendor may wish to partition aggregates by
version (different versions of the browser may have different performance
profiles) or geographic location. We will call these properties "labels". [CP:
See https://github.com/ietf-wg-ppm/draft-ietf-ppm-dap/issues/489 for the
discussion that originally motivated this idea.]

Aggregating by labels requires representing the information in such a way that
that measurements submitted by clients with the same label are aggregated
together. Prio3 can be adapted for this purpose, but the communication cost
would be linear in the number of possible distinct labels, which quickly
becomes prohibitive if the label space is large or subject to change over time.
(For example, the label might encode the client's user agent as defined in
{{Section 10.1.5 of !RFC9110}}.) Mastic encodes the label and measurement with
constant communication overhead such that, for an arbitrary sequence of labels,
the reports can be "queried" to reveal the aggregate for each label without
learning the label or measurement of any client. We describe this mode of
operation in {{aggregation-by-labels}}.

Finally, we describe two modes of operation for Mastic that admit useful
performance and security trade-offs.

First, we describe an optimization for plain heavy hitters that, in the best
case, reduces the communication cost of preparation from linear in the number
of reports to constant, leading to a dramatic improvement in performance
compared to Poplar1. This best-case behavior is observed when all clients
behave honestly: if a fraction of the clients submit invalid reports, then
additional rounds of communication are required in order to isolate the invalid
reports and remove them. We describe this idea in detail in
{{plain-heavy-hitters-with-proof-aggregation}}.

Second, in {{plain-heavy-hitters-with-three-aggregators}} we describe an
enhancement for plain heavy hitters that allows Mastic to achieve robustness in
the presence of a malicious server. Rather than two aggregation servers as in
the previous modes, this mode of operation involves three aggregators,
where every pair of aggregators communicate over a different channel. [CP: Anything
else to mention here? Is the transform generic, i.e., apply to any 2-party
VDAF, or are there tricks in {{MST23}} that we want to take advantage of
for efficiency] While more complex to implement than 2-party Mastic, this mode
allows achieves "full security", where both privacy and robustness
hold in the honest majority setting.

# Conventions and Definitions

{::boilerplate bcp14-tagged}

This document uses the following terms as defined in {{!VDAF}}:
"Aggregator",
"Client",
"Collector",
"aggregate result",
"aggregate share",
"aggregation parameter",
"input share",
"measurement",
"output share",
"prep message",
"prep share", and
"report".

In Mastic, a Client's VDAF measurement is comprised of two components, which we
denote `alpha` and `beta`. The function that each component serves depends on
the use case: for plain and weighted heavy-hitters, we shall refer to `alpha`
as the "payload" and `beta` as the payload's "weight"; for
aggregation-by-labels, we shall refer to `alpha` as the "label" and to `beta`
as the "payload". When doing so is unambiguous, we may also refer to the
payload as the "measurement".

# Preliminaries

Mastic makes use of three primitives described in the base VDAF specification
{{!VDAF}}: finite fields, eXtendable Output Functions (XOFs), and Fully Linear
Proofs (FLPs). It also makes use of a fourth primitive, which extends the
security properties of Incremental Distributed Point Functions (IDPFs), also
described in the base specification. All four primitives are described below.

## Finite fields {#field}

An implementation of the `Field` interface in {{Section 6.1 of !VDAF}} is
required. This object implements arithmetic in a prime field with a modulus
suitable for use with the Number Theoretic Transform (called "FFT-friendly" in
{{!VDAF}}).

## XOF {#xof}

An implementation of the `Xof` interface in {{Section 6.2 of !VDAF}} is
required. This object implements an XOF that takes a short seed and some
auxiliary data as input and outputs a string of any length required for the
application.

## FLP {#flp}

An implementation of the `Flp` interface in {{Section 7.1 of !VDAF}} is
required. This object implements a zero-knowledge proof system used to verify
that the measurement conforms to the data type required by the application. The
Client generates a proof that its measurement is valid and sends secret shares
of this proof to each Aggregator. Verification is split into two phases. In the
first phase, each Aggregator "queries" its share of the measurement and proof
to obtain its "verifier share". In the second phase, the Aggregators sum up the
verifier shares and use the sum to decide if the input is valid.

## Verifiable IDPF (VIDPF) {#vidpf}

Function secret sharing (FSS) allows secret sharing of the output of a function
`f()` into additive shares, where each function share is represented by a
separate key {{GI14}}. These keys enable their respective owners to efficiently
generate an additive share of the function’s output `f(x)` for a given input
`x`. Distributed Point Functions (DPF) are a particular case of FSS where `f()`
is a "point function" for which `f(x) = beta` if `x` equals `alpha` and `0`
otherwise for some `alpha, beta`.

An IDPF ({{Section 8.1 of !VDAF}}) generalizes DPF by secret-sharing a
"incremental point function". Here we take `alpha` to be a bit string of
fixed length and we have that `f(x) = beta` if `x` is a prefix of `alpha` and
`0` otherwise.

An IDPF has two main operations. The first is the key-generation algorithm,
which is run by the Client. It takes as input `alpha` and `beta` and returns
three values: two "key shares", one for each of two Aggregators; and the
"public share", to be distributed to both Aggregators. The second is the
key-evaluation algorithm, run by each Aggregator. It takes as input a candidate
prefix string `x`, the public share, and the Aggregator's key share and returns
the Aggregator's share of `f(x)`.

Shares of the IDPF outputs can be aggregated together across multiple reports.
This is used in Poplar1 ({{Section 8 of !VDAF}}) to count how many input
strings begin with a candidate prefix. IDPFs are private in the sense that each
Aggregators learning nothing about the underlying inputs beyond the value of
this sum. However, IDPFs on their own do not provide robustness. For example,
it is possible for a malicious Client to fool the Aggregators into accepting
malformed counter (i.e., a value other than `0` or `1`). It is also possible
for a Client to "vote twice" by construcing key shares for which `f(x) = f(x')
= beta`, where `x` and `x'` are distinct, equal-length strings.

To mitigate these issues, IDPF must be composed with some interactive mechanism
for ensuring the IDPF outputs are well-formed. Mastic uses the VIDPF of
{{MST23}} for this purpose, which endows IDPF with the following properties:

1. **One-hot Verifiability:** There is at most one prefix of each length whose
   value under f is non-zero. In particular, the output shares at each level
   are additive shares of a one-hot vector.

1. **Path Verifiability:** The One-hot Verifiability property alone is not
    sufficient to guarantee that the keys are well formed. The Aggregators
    still need to verify that: a) the non-zero output values are
    across a single path in the tree, and b) the value of the root node is
    consistently propagated down the VIDPF tree. For example, if the root
    value is `beta`, then there is only a single path from root to the leaves
    with nonzero values, and all such values equal `beta`.

Below we describe the syntax of VIDPF; in {{vidpf-construction}} we specify the
concrete construction of {{MST23}}.

A concrete `Vidpf` defines the types and constants enumerated in
{{vidpf-param}}. In addition it implements the following methods:

* `Vidpf.gen(alpha: Unsigned, beta: list[Vidpf.Field], binder: bytes, rand:
  bytes) -> tuple[PublicShare, list[bytes]]` is the randomized key generation
  algorithm. (`rand` denotes the random bytes consumed by the algorithm.) Its
  inputs are the VIDPF index `alpha` (defined the same way as "IDPF index" in
  {{Section 8 of !VDAF}}), the output value `beta`, and a binder string.  The
  value of `alpha` MUST be in range `[0, 2^Vidpf.BITS)`; and `len(rand)` MUST
  be `Vidpf.RAND_SIZE`. The outputs are the public share and the list of key
  shares, one for each Aggregator. The length of each key share MUST be
  `Vidpf.KEY_SIZE`.

* `Vidpf.eval(agg_id: Unsigned, public_share: Vidpf.PublicShare, key_share:
  bytes, level: Unsigned, prefixes: tuple[Unsigned, ...], binder: bytes) ->
  tuple[list[Vidpf.Field], bytes]` is the deterministic key evaulation
  algorithm. It takes as input the Aggregator ID (which MUST be in range `[0,
  Vidpf.SHARES)`, the public share, the Aggregator's key share, the VIDFP level
  (defined the same way as "IDPF level" in {{Section 8 of !VDAF}}), the list of
  prefixes to evaluate, and a binder string. Its outputs are the VIDPF output
  share and the VIDPF verifier.

The veriability properties are guaranteed as long as each Aggregator computes
the same verifier string. Note that One-hot Verifiability and Path
Verifiability are not sufficient to ensure robustness of Mastic; we will also
need to ensure that the `beta` chosen by the Client is "in range". We will rely
on FLPs ({{flp}}) for this purpose. ({{MST23}} describe a simple `range(2)`
check, but we would like more sophisticated range checks for Mastic.)

| Parameter  | Description               |
|:-----------|:--------------------------|
| SHARES      | Number of VIDPF keys output by VIDPF-key generator |
| BITS        | Length in bits of each input string |
| VALUE_LEN   | Number of field elements of each output value |
| RAND_SIZE   | Size of the random string consumed by the VIDPF-key generator. Equal to twice the XOF's seed size. |
| KEY_SIZE    | Size in bytes of each VIDPF key |
| Field       | Implementation of `Field` ({{field}}) used for each value |
| PublicShare | Type of the VIDPF public share |
{: #vidpf-param title="Constants and types defined by a concrete VIDPF."}

# Definition of `Mastic` {#vdaf}

TODO overview

> NOTE To be specified. We are pretty confident about the overall structure of
> the VDAF, but there are some details to work out and security analysis to do.
> In the meantime, check out the current reference implementation at
> https://github.com/jimouris/draft-mouris-cfrg-mastic/tree/main/poc.

## Sharding

> NOTE to be specified in full detail.

## Preparation

> NOTE to be specified in full detail.

## Validity of Aggregation Parameters

> NOTE to be specified in full detail.

## Aggregation

> NOTE to be specified in full detail.

## Unsharding

> NOTE to be specified in full detail.

# Modes of Operation for `Mastic`

## Weighted Heavy-Hitters {#weighted-heavy-hitters}

TODO Add an overview of the goal and how Mastic is used to achieve it.

> NOTE to be specified in full detail.

## Aggregation by Labels {#aggregation-by-labels}

TODO Add an overview of the goal and how Mastic is used to achieve it.

> NOTE to be specified in full detail.

## Plain Heavy-Hitters with Proof Aggregation {#plain-heavy-hitters-with-proof-aggregation}

TODO Add an overview of the goal and how Mastic is used to achieve it.

> NOTE to be specified in full detail.

## Malicious Robustness for Plain Heavy-Hitters {#plain-heavy-hitters-with-three-aggregators}

TODO(jimouris) Add an overview of the goal and how Mastic is used to achieve it.

> NOTE to be specified in full detail.

# Definition of `Vidpf` {#vidpf-construction}

The construction of {{MST23}} builds on techniques from {{CP22}} to lift an
IDPF to a VIDPF with the properties described in {{vidpf}}. Instead of a
2-round "secure sketch" MPC like that of Poplar1, the scheme relys on hashing.

TODO(jimouris) Add an overview.

> NOTE To be specified. The design is based on VIDPF from {{MST23}}.
> https://github.com/jimouris/draft-mouris-cfrg-mastic/tree/main/poc for the
> reference implementation.

# Security Considerations

> NOTE to be specified.

# IANA Considerations

> NOTE to be specified.

--- back

# Acknowledgments
{:numbered="false"}

> NOTE to be specified.
