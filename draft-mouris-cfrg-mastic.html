<!DOCTYPE html>
<html lang="en" class="Internet-Draft">
<head>
<meta charset="utf-8">
<meta content="Common,Latin" name="scripts">
<meta content="initial-scale=1.0" name="viewport">
<title>The Mastic VDAF</title>
<meta content="Hannah Davis" name="author">
<meta content="Dimitris Mouris" name="author">
<meta content="Christopher Patton" name="author">
<meta content="Nektarios G. Tsoutsos" name="author">
<meta content="
       This document describes Mastic, a two-party VDAF for the following secure
aggregation task: each client holds an input string and an associated weight,
and the data collector wants to aggregate the weights of all clients whose
inputs begin with a prefix chosen by the data collector. This functionality
enables two classes of applications. First, it allows grouping metrics by
client attributes without revealing which clients have which attributes.
Second, it solves the weighted heavy hitters problem, where the goal is to
compute the subset of inputs that have the highest total weight. 
    " name="description">
<meta content="xml2rfc 3.26.0" name="generator">
<meta content="Internet-Draft" name="keyword">
<meta content="draft-mouris-cfrg-mastic-latest" name="ietf.draft">
<!-- Generator version information:
  xml2rfc 3.26.0
    Python 3.12.8
    ConfigArgParse 1.7
    google-i18n-address 3.1.1
    intervaltree 3.1.0
    Jinja2 3.1.5
    lxml 5.3.0
    platformdirs 4.3.6
    pycountry 24.6.1
    PyYAML 6.0.2
    requests 2.32.3
    setuptools 70.3.0
    wcwidth 0.2.13
-->
<link href="draft-mouris-cfrg-mastic.xml" rel="alternate" type="application/rfc+xml">
<link href="#copyright" rel="license">
<style type="text/css">@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}

@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-cyrillic.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-cyrillic.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: local('Lora SemiBold'), local('Lora-SemiBold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-semibold-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Oxygen Mono';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Oxygen Mono'), local('OxygenMono-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/oxygenmono-regular-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Oxygen Mono';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Oxygen Mono'), local('OxygenMono-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/oxygenmono-regular-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: italic;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-italic-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C8A, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: italic;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-italic-cyrillic.woff2') format('woff2');
  unicode-range: U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: italic;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-italic-greek.woff2') format('woff2');
  unicode-range: U+0370-0377, U+037A-037F, U+0384-038A, U+038C, U+038E-03A1, U+03A3-03FF;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: italic;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-italic-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-02BA, U+02BD-02C5, U+02C7-02CC, U+02CE-02D7, U+02DD-02FF, U+0304, U+0308, U+0329, U+1D00-1DBF, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: italic;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-italic-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: normal;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-regular-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C8A, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: normal;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-regular-cyrillic.woff2') format('woff2');
  unicode-range: U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: normal;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-regular-greek.woff2') format('woff2');
  unicode-range: U+0370-0377, U+037A-037F, U+0384-038A, U+038C, U+038E-03A1, U+03A3-03FF;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: normal;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-regular-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-02BA, U+02BD-02C5, U+02C7-02CC, U+02CE-02D7, U+02DD-02FF, U+0304, U+0308, U+0329, U+1D00-1DBF, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: normal;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-regular-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

:root {
  color-scheme: light dark;
  --background-color: #fff;
  --text-color: #222;
  --title-color: #191919;
  --link-color: #2a6496;
  --highlight-color: #f9f9f9;
  --line-color: #eee;
  --pilcrow-weak: #ddd;
  --pilcrow-strong: #bbb;
  --small-font-size: 14.5px;
  --font-mono: 'Oxygen Mono', monospace;
  --font-title: "Sofia Sans Semi Condensed", sans-serif;
  scrollbar-color: #bbb #eee;
}
body {
  max-width: 600px;
  margin: 75px auto;
  padding: 0 5px;
  color: var(--text-color);
  background-color: var(--background-color);
  font: 16px/22px "Lora", serif;
  scroll-behavior: smooth;
}

.ears {
  display: none;
}

/* headings */
section {
  clear: both;
}
.section-number {
  padding-right: 0.5em;
}
h1, h2, h3, h4, h5, h6 {
  font-family: var(--font-title);
  font-weight: 680;
  margin: 0.8em 0 0.3em;
  font-size-adjust: 0.5;
  color: var(--title-color);
}
h1#title {
  font-size: 32px;
  line-height: 40px;
  clear: both;
}
h1#title, h1#rfcnum {
  margin: 1.5em 0 0.2em;
}
h1#rfcnum + h1#title {
  margin: 0.2em 0;
}

h1, h2, h3 {
  font-size: 22px;
  line-height: 27px;
}
h4, h5, h6 {
  font-size: 20px;
  line-height: 24px;
}

/* general structure */
.author {
  padding-bottom: 0.3em;
  vertical-align: top;
}
#abstract+p {
  font-size: 18px;
  line-height: 24px;
}
#abstract+p code, #abstract+p samp, #abstract+p tt {
  font-size: 16px;
  line-height: 0;
}

p {
  padding: 0;
  margin: 0.5em 0;
  text-align: left;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: var(--highlight-color);
  border: 1px solid var(--line-color);
  border-radius: 3px;
  padding: 0.5em 1em 0;
  margin-bottom: 0.5em;
}
.alignRight.art-text pre {
  padding: 0;
  width: auto;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
/* font-family isn't space-separated, but =~ will have to do */
svg[font-family~="monospace" i], svg [font-family~="monospace" i] {
  font-family: var(--font-mono);
}
.alignCenter.art-text {
  background-color: var(--highlight-color);
  border: 1px solid var(--line-color);
  border-radius: 3px;
  padding: 0.5em 1em 0;
  margin-bottom: 0.5em;
}
.alignCenter.art-text pre {
  padding: 0;
  width: auto;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  border: none;
  /* this isn't optimal, but it's an existence proof.  PrinceXML doesn't
     support flexbox yet.
  */
  display: table;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 0.5em 2em;
  & :is(ol, ul) {
    margin-left: 1em;
  }
}
li {
  margin: 0 0 0.25em 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
  & li {
    margin-top: 0.5em;
  }
}
:is(ul, ol).compact, .ulCompact, .olCompact {
  margin: 0 0 0 2em;
  & li {
    margin: 0;
    & :first-child { margin-top: 0; }
    & :last-child { margin-bottom: 0; }
  }
}

/* definition lists */
dl {
  clear: left;
  --indent: 3ch;
  /* --indent: attr(indent ch); not supported in any browser, but we can dream */
  &.olPercent {
    --indent: 5ch;
    & > dt {
      min-width: calc(var(--indent) - 2ch);
    }
  }
  &.olPercent > dt {
    float: none;
  }

  dl > dd > & {
    margin-top: 0.5em;
    margin-bottom: 0;
  }
}
dl > dt {
  float: left;
  margin-right: 2ch;
  min-width: 8ch;
}
dl > dd {
  margin-bottom: .8em;
  margin-left: var(--indent) !important; /* stupid element overrides */
  min-height: 2ex;
}
:is(dl.compact, .dlCompact) > dd {
  margin-bottom: 0;
  & > :is(:first-child, .break:first-child + *) {
    margin-top: 0;
  }
  & > :is(:last-child) {
    margin-bottom: 0;
  }
}
:is(dd, span).break {
  display: none;
}

/* links */
a, a[href].selfRef:hover {
  text-decoration: none;
}
a[href] {
  color: var(--link-color);
}
a[href].selfRef, .iref + a[href].internal {
  color: var(--text-color);
}
a[href]:hover {
  text-decoration: underline;
}
a[href].selfRef:hover {
  background-color: var(--highlight-color);
}
a.xref:is(.cite, .auto), :is(#status-of-memo, #copyright) a {
  white-space: nowrap;
}

/* Figures */
tt, code, pre {
  background-color: var(--highlight-color);
  font: 14px/22px var(--font-mono);
}
tt, code {
  /* changing the font for inline elements leads to different ascender
     and descender heights; as we want to retain baseline alignment,
     remove leading to avoid altering the final height of lines
     note: this fails if these blocks take an entire line,
     a different solution would be great */
  line-height: 0;
}
:is(h1, h2, h3, h4, h5, h6) :is(tt, code) {
  font-size: 84%;
}
pre {
  border: 1px solid var(--line-color);
  font-size: 13.5px;
  line-height: 16px;
  letter-spacing: -0.2px;
  margin: 5px;
  padding: 5px;
}
img {
  max-width: 100%;
}
figure {
  margin: 0.5em 0;
  padding: 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption, caption {
  font-style: italic;
  margin: 0.5em 1.5em;
  text-align: left;
  caption-side: bottom;
}
@media screen {
  /* Auto-collapse boilerplate. */
  :is(#status-of-memo, #copyright) p {
    margin: -2px 0;
    max-height: 0;
    transition: max-height 2s ease, margin 0.5s ease 0.5s;
    overflow: hidden;
  }
  :is(#status-of-memo, #copyright):hover p,
  :is(#status-of-memo, #copyright) h2:target ~ p {
    margin: 0.5em 0;
    max-height: 500px;
    overflow: auto;
  }
  pre, svg {
    display: inline-block;
    /* In the horizontal direction, sometimes people make over-sized figures.
       Scrollbars for those is therefore necessary: auto adds them as necessary..
       In the vertical direction, the line-height can combine with the font
       asender/descender height to produce scrollbars: hidden avoids that. */
    overflow: auto hidden;
  }
  pre {
    max-width: 100%;
    width: calc(100% - 22px - 1em);
  }
  svg {
    max-width: calc(100% - 22px - 1em);
  }
  figure pre {
    display: block;
    width: calc(100% - 25px);
  }
  :is(pre, svg) + .pilcrow {
    display: inline-block;
    vertical-align: text-bottom;
    padding-bottom: 8px;
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 0 2em;
  font-style: italic;
}
blockquote {
  margin: 1em 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}

/* tables */
table {
  width: auto;
  max-width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
}
table.right {
  margin-left: auto;
}
table.center {
  margin-left: auto;
  margin-right: auto;
}
table.left {
  margin-right: auto;
}
table .text-left {
  text-align: left;
}
table .text-center {
  text-align: center;
}
table .text-right {
  text-align: right;
}

thead, tbody {
  border: 1px solid var(--line-color);
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 5px 10px;
}
th {
  background-color: var(--line-color);
}
:is(tr:nth-child(2n), thead+tbody > tr:nth-child(2n+1)) > td {
  background-color: var(--background-color);
}
:is(tr:nth-child(2n+1), thead+tbody > tr:nth-child(2n)) > td {
  background-color: var(--highlight-color);
}
table caption {
  margin: 0;
  padding: 3px 0 3px 1em;
}
table p {
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  margin-left: 3px;
  opacity: 0.2;
  user-select: none;
  &[href] {
    color: var(--pilcrow-weak);
    &:hover { text-decoration: none; }
  }
}
@media not print {
  :hover > a.pilcrow {
    opacity: 1;
  }
  a.pilcrow[href]:hover {
    color: var(--pilcrow-strong);
    background-color: transparent;
  }
}
@media print {
  a.pilcrow {
    display: none;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid var(--line-color);
}
.bcp14 {
  font-variant: small-caps;
  font-weight: 600;
  font-size: var(--small-font-size);
}
.role {
  font-variant: all-small-caps;
}
sub, sup {
  line-height: 1;
  font-size: 80%;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: var(--small-font-size);
  line-height: 18px;
  --identifier-width: 15ch;
  & dt {
    width: var(--identifier-width);
    min-width: var(--identifier-width);
    clear: left;
    float: left;
    text-align: right;
    margin-right: 1ch;
  }
  & dd {
    margin: 0;
    margin-left: calc(1em + var(--identifier-width)) !important;
    min-width: 5em;
  }
  & .authors {
    & .author {
      display: inline-block;
      margin-right: 1.5em;
    }
    & .org {
      font-style: italic;
    }
  }
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #999;
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;

  & nav {
    & ul {
      margin: 0 0.5em 0 0;
      padding: 0;
      list-style: none;
    }
    & li {
      line-height: 1.3em;
      margin: 2px 0;
      padding-left: 1.2em;
      text-indent: -1.2em;
    }
  }
  & a.xref {
    white-space: normal;
  }
}

.references {
  & > dt {
    text-align: right;
    font-weight: bold;
    min-width: 10ch;
    margin-right: 1.5ch;
    &:target::before {
      content: "⇒";
      margin: 0 10px 0 -25px;
    }
  }
  & > dd {
    margin-left: 12ch !important;
    overflow: visible;
    & .refInstance {
      margin-bottom: 0.8em;
    }
    & .ascii {
      margin-bottom: 0.25em;
    }
  }
}

#rfc\.index\.index + ul {
  margin-left: 0;
}

/* authors */
address.vcard {
  font-style: normal;
  max-width: 20em;
  margin: 1em auto 1em 0;

  & .nameRole {
    font-weight: 700;
    margin-left: 0;
  }
  & .label {
    margin: 0.5em 0;
  }
  & .type {
    display: none;
  }
  & .alternative-contact {
    margin: 0.5em 0 0.25em 0;
  }
  & .non-ascii {
    margin: 0 0 0 2em;
  }
  & div.left {
    text-align: left;
  }
  & div.right {
    text-align: right;
  }
}

hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}
@media (min-width: 500px) {
  #authors-addresses > section {
    column-count: 2;
    column-gap: 20px;
  }
  #authors-addresses > section > h2 {
    column-span: all;
  }
  /* hack for break-inside: avoid-column */
  #authors-addresses address {
    display: inline-block;
    break-inside: avoid-column;
  }
}

/* Comments */
.rfcEditorRemove p:first-of-type {
  font-style: italic;
}
.cref {
  background-color: rgba(249, 232, 105, 0.3);
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}

@media screen {
  #toc nav {
    font-family: var(--font-title);
    font-weight: 360;
    & > ul { margin-bottom: 2em; }
    & ul {
      margin: 0 0 0 4px;
      & :is(p, li) {
        margin: 2px 0;
      }
    }
  }
  #toc a.toplink {
    float: right;
  }
}
@media not screen {
  #toc a.toplink {
    display: none;
  }
}


/* TOC layout for smaller screens */
@media screen and (max-width: 929px) {
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 1px 0 0 0;
    margin: 0;
    border-bottom: 1px solid #ccc;
    opacity: 0.6;
  }
  #toc h2 {
    margin: 0;
    padding: 2px 0 2px 6px;
    padding-right: 1em;
    font-size: 18px;
    line-height: 24px;
    min-width: 190px;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
    &::before { /* css hamburger */
      float: right;
      position: relative;
      width: 1em;
      height: 1px;
      left: -164px;
      margin: 8px 0 0 0;
      background: white none repeat scroll 0 0;
      box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
      content: "";
    }
  }
  #toc nav {
    display: none;
    background-color: var(--background-color);
    padding: 0.5em 1em 1em;
    overflow: auto;
    overscroll-behavior: contain;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
  #toc.active {
    opacity: 1;
    & nav { display: block; }
  }
  /* Make the collapsed ToC header render white on gray also when it's a link */
  #toc h2 a,
  #toc h2 a:is(:link, :focus, :hover),
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
  #toc a.toplink {
    margin: 2px 0.5em 0;
  }
}

/* TOC layout for wide screens */
@media screen and (min-width: 930px) {
  body {
    padding-right: 360px;
    padding-right: calc(min(180px + 20%, 500px));
  }
  #toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 480px);
    width: 312px;
    margin: 0;
    padding: 0;
    z-index: 1;
  }
  #toc h2 {
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 2em;
    overflow: auto;
    overscroll-behavior: contain;
    scrollbar-width: thin;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
  #toc a.toplink {
    margin: 8px 0.5em 0;
  }
}

/* pagination */
@media print {
  body {
    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre, .vcard {
    page-break-inside: avoid;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  :is(h2, h3, h4, h5, h6)+*, dd {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
}

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
}

/* Dark mode. */
@media (prefers-color-scheme: dark) {
:root {
  --background-color: #121212;
  --text-color: #f0f0f0;
  --title-color: #fff;
  --link-color: #4da4f0;
  --highlight-color: #282828;
  --line-color: #444;
  --pilcrow-weak: #444;
  --pilcrow-strong: #666;
  scrollbar-color: #777 #333;
}
}

/* SVG Trick: a prefix match works because only black and white are allowed */
svg :is([stroke="black"], [stroke^="#000"]) {
  stroke: var(--text-color);
}
svg :is([stroke="white"], [stroke^="#fff"]) {
  stroke: var(--background-color);
}
svg :is([fill="black"], [fill^="#000"], :not([fill])) {
  fill: var(--text-color);
}
svg :is([fill="white"], [fill^="#fff"]) {
  fill: var(--background-color);
}
</style>

</head>
<body class="xml2rfc">
<table class="ears">
<thead><tr>
<td class="left">Internet-Draft</td>
<td class="center">Mastic</td>
<td class="right">February 2025</td>
</tr></thead>
<tfoot><tr>
<td class="left">Davis, et al.</td>
<td class="center">Expires 8 August 2025</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div id="external-metadata" class="document-information"></div>
<div id="internal-metadata" class="document-information">
<dl id="identifiers">
<dt class="label-workgroup">Workgroup:</dt>
<dd class="workgroup">Crypto Forum</dd>
<dt class="label-internet-draft">Internet-Draft:</dt>
<dd class="internet-draft">draft-mouris-cfrg-mastic-latest</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time datetime="2025-02-04" class="published">4 February 2025</time>
    </dd>
<dt class="label-intended-status">Intended Status:</dt>
<dd class="intended-status">Informational</dd>
<dt class="label-expires">Expires:</dt>
<dd class="expires"><time datetime="2025-08-08">8 August 2025</time></dd>
<dt class="label-authors">Authors:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">H. Davis</div>
<div class="org">Seagate</div>
</div>
<div class="author">
      <div class="author-name">D. Mouris</div>
<div class="org">Nillion</div>
</div>
<div class="author">
      <div class="author-name">C. Patton</div>
<div class="org">Cloudflare</div>
</div>
<div class="author">
      <div class="author-name">N. G. Tsoutsos</div>
<div class="org">University of Delaware</div>
</div>
</dd>
</dl>
</div>
<h1 id="title">The Mastic VDAF</h1>
<section id="section-abstract">
      <h2 id="abstract"><a href="#abstract" class="selfRef">Abstract</a></h2>
<p id="section-abstract-1">This document describes Mastic, a two-party VDAF for the following secure
aggregation task: each client holds an input string and an associated weight,
and the data collector wants to aggregate the weights of all clients whose
inputs begin with a prefix chosen by the data collector. This functionality
enables two classes of applications. First, it allows grouping metrics by
client attributes without revealing which clients have which attributes.
Second, it solves the weighted heavy hitters problem, where the goal is to
compute the subset of inputs that have the highest total weight.<a href="#section-abstract-1" class="pilcrow">¶</a></p>
</section>
<section class="note rfcEditorRemove" id="section-note.1">
      <h2 id="name-about-this-document">
<a href="#name-about-this-document" class="section-name selfRef">About This Document</a>
      </h2>
<p id="section-note.1-1">This note is to be removed before publishing as an RFC.<a href="#section-note.1-1" class="pilcrow">¶</a></p>
<p id="section-note.1-2">
        Status information for this document may be found at <span><a href="https://datatracker.ietf.org/doc/draft-mouris-cfrg-mastic/">https://datatracker.ietf.org/doc/draft-mouris-cfrg-mastic/</a></span>.<a href="#section-note.1-2" class="pilcrow">¶</a></p>
<p id="section-note.1-3">
        Discussion of this document takes place on the
        Crypto Forum Research Group mailing list (<span><a href="mailto:cfrg@ietf.org">mailto:cfrg@ietf.org</a></span>),
        which is archived at <span><a href="https://mailarchive.ietf.org/arch/search/?email_list=cfrg">https://mailarchive.ietf.org/arch/search/?email_list=cfrg</a></span>.
        Subscribe at <span><a href="https://www.ietf.org/mailman/listinfo/cfrg/">https://www.ietf.org/mailman/listinfo/cfrg/</a></span>.<a href="#section-note.1-3" class="pilcrow">¶</a></p>
<p id="section-note.1-4">Source for this draft and an issue tracker can be found at
        <span><a href="https://github.com/jimouris/draft-mouris-cfrg-mastic">https://github.com/jimouris/draft-mouris-cfrg-mastic</a></span>.<a href="#section-note.1-4" class="pilcrow">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo">
<a href="#name-status-of-this-memo" class="section-name selfRef">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
        This Internet-Draft is submitted in full conformance with the
        provisions of BCP 78 and BCP 79.<a href="#section-boilerplate.1-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-2">
        Internet-Drafts are working documents of the Internet Engineering Task
        Force (IETF). Note that other groups may also distribute working
        documents as Internet-Drafts. The list of current Internet-Drafts is
        at <span><a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a></span>.<a href="#section-boilerplate.1-2" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-3">
        Internet-Drafts are draft documents valid for a maximum of six months
        and may be updated, replaced, or obsoleted by other documents at any
        time. It is inappropriate to use Internet-Drafts as reference
        material or to cite them other than as "work in progress."<a href="#section-boilerplate.1-3" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-4">
        This Internet-Draft will expire on 8 August 2025.<a href="#section-boilerplate.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice">
<a href="#name-copyright-notice" class="section-name selfRef">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2025 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a href="#section-boilerplate.2-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document.<a href="#section-boilerplate.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a href="#" onclick="scroll(0,0)" class="toplink">▲</a><h2 id="name-table-of-contents">
<a href="#name-table-of-contents" class="section-name selfRef">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1">
            <p id="section-toc.1-1.1.1" class="keepWithNext"><a href="#section-1" class="auto internal xref">1</a>.  <a href="#name-introduction" class="internal xref">Introduction</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1" class="keepWithNext"><a href="#section-2" class="auto internal xref">2</a>.  <a href="#name-conventions-and-definitions" class="internal xref">Conventions and Definitions</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1"><a href="#section-3" class="auto internal xref">3</a>.  <a href="#name-specification-of-vidpf" class="internal xref">Specification of VIDPF</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1">
                <p id="section-toc.1-1.3.2.1.1" class="keepWithNext"><a href="#section-3.1" class="auto internal xref">3.1</a>.  <a href="#name-key-generation" class="internal xref">Key Generation</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2">
                <p id="section-toc.1-1.3.2.2.1"><a href="#section-3.2" class="auto internal xref">3.2</a>.  <a href="#name-key-evaluation" class="internal xref">Key Evaluation</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.3">
                <p id="section-toc.1-1.3.2.3.1"><a href="#section-3.3" class="auto internal xref">3.3</a>.  <a href="#name-auxiliary-functions" class="internal xref">Auxiliary functions</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a href="#section-4" class="auto internal xref">4</a>.  <a href="#name-specification-of-mastic" class="internal xref">Specification of Mastic</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1">
                <p id="section-toc.1-1.4.2.1.1"><a href="#section-4.1" class="auto internal xref">4.1</a>.  <a href="#name-sharding" class="internal xref">Sharding</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2">
                <p id="section-toc.1-1.4.2.2.1"><a href="#section-4.2" class="auto internal xref">4.2</a>.  <a href="#name-preparation" class="internal xref">Preparation</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.3">
                <p id="section-toc.1-1.4.2.3.1"><a href="#section-4.3" class="auto internal xref">4.3</a>.  <a href="#name-validity-of-aggregation-par" class="internal xref">Validity of Aggregation Parameters</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.4">
                <p id="section-toc.1-1.4.2.4.1"><a href="#section-4.4" class="auto internal xref">4.4</a>.  <a href="#name-aggregation" class="internal xref">Aggregation</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.5">
                <p id="section-toc.1-1.4.2.5.1"><a href="#section-4.5" class="auto internal xref">4.5</a>.  <a href="#name-unsharding" class="internal xref">Unsharding</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.6">
                <p id="section-toc.1-1.4.2.6.1"><a href="#section-4.6" class="auto internal xref">4.6</a>.  <a href="#name-auxiliary-functions-2" class="internal xref">Auxiliary Functions</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a href="#section-5" class="auto internal xref">5</a>.  <a href="#name-security-considerations" class="internal xref">Security Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a href="#section-6" class="auto internal xref">6</a>.  <a href="#name-iana-considerations" class="internal xref">IANA Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a href="#section-7" class="auto internal xref">7</a>.  <a href="#name-references" class="internal xref">References</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.1">
                <p id="section-toc.1-1.7.2.1.1"><a href="#section-7.1" class="auto internal xref">7.1</a>.  <a href="#name-normative-references" class="internal xref">Normative References</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2">
                <p id="section-toc.1-1.7.2.2.1"><a href="#section-7.2" class="auto internal xref">7.2</a>.  <a href="#name-informative-references" class="internal xref">Informative References</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a href="#appendix-A" class="auto internal xref"></a><a href="#name-acknowledgments" class="internal xref">Acknowledgments</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9">
            <p id="section-toc.1-1.9.1"><a href="#appendix-B" class="auto internal xref"></a><a href="#name-motivating-applications" class="internal xref">Motivating Applications</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.1">
                <p id="section-toc.1-1.9.2.1.1"><a href="#appendix-B.1" class="auto internal xref"></a><a href="#name-network-error-logging" class="internal xref">Network Error Logging</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.2">
                <p id="section-toc.1-1.9.2.2.1"><a href="#appendix-B.2" class="auto internal xref"></a><a href="#name-attribute-based-browser-tel" class="internal xref">Attribute-Based Browser Telemetry</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10">
            <p id="section-toc.1-1.10.1"><a href="#appendix-C" class="auto internal xref"></a><a href="#name-modes-of-operation" class="internal xref">Modes of Operation</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10.2.1">
                <p id="section-toc.1-1.10.2.1.1"><a href="#appendix-C.1" class="auto internal xref"></a><a href="#name-weighted-heavy-hitters" class="internal xref">Weighted Heavy-Hitters</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10.2.1.2.1">
                    <p id="section-toc.1-1.10.2.1.2.1.1"><a href="#appendix-C.1.1" class="auto internal xref"></a><a href="#name-different-thresholds" class="internal xref">Different Thresholds</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10.2.2">
                <p id="section-toc.1-1.10.2.2.1"><a href="#appendix-C.2" class="auto internal xref"></a><a href="#name-attribute-based-metrics" class="internal xref">Attribute-based Metrics</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10.2.3">
                <p id="section-toc.1-1.10.2.3.1"><a href="#appendix-C.3" class="auto internal xref"></a><a href="#name-plain-heavy-hitters-with-vi" class="internal xref">Plain Heavy-Hitters with VIDPF-Proof Aggregation</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10.2.4">
                <p id="section-toc.1-1.10.2.4.1"><a href="#appendix-C.4" class="auto internal xref"></a><a href="#name-robustness-against-a-malici" class="internal xref">Robustness Against a Malicious Aggregator</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11">
            <p id="section-toc.1-1.11.1"><a href="#appendix-D" class="auto internal xref"></a><a href="#name-test-vectors" class="internal xref">Test Vectors</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12">
            <p id="section-toc.1-1.12.1"><a href="#appendix-E" class="auto internal xref"></a><a href="#name-contributors" class="internal xref">Contributors</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13">
            <p id="section-toc.1-1.13.1"><a href="#appendix-F" class="auto internal xref"></a><a href="#name-authors-addresses" class="internal xref">Authors' Addresses</a></p>
</li>
        </ul>
</nav>
</section>
</div>
<div id="introduction">
<section id="section-1">
      <h2 id="name-introduction">
<a href="#section-1" class="section-number selfRef">1. </a><a href="#name-introduction" class="section-name selfRef">Introduction</a>
      </h2>
<p id="section-1-1">(RFC EDITOR: Remove this paragraph.) The source for this draft and the
reference code can be found at
https://github.com/jimouris/draft-mouris-cfrg-mastic.<a href="#section-1-1" class="pilcrow">¶</a></p>
<p id="section-1-2">The private "heavy hitters" problem is to compute the most popular input
strings generated by clients without learning the inputs themselves. For
example, a browser vendor might want to know which websites are visited most
frequently without learning which clients visited which websites.<a href="#section-1-2" class="pilcrow">¶</a></p>
<p id="section-1-3">This problem can be solved by combining a binary search with a subroutine
solving the simpler "prefix histogram" problem. The goal of this problem is to
count how many of the input strings begin with each of a sequence of candidate
prefixes. This problem can be solved using a Verifiable Distributed Aggregation
Function, or VDAF <span>[<a href="#VDAF" class="cite xref">VDAF</a>]</span>.<a href="#section-1-3" class="pilcrow">¶</a></p>
<p id="section-1-4">The Poplar1 VDAF specified in <span><a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-14#section-8" class="relref">Section 8</a> of [<a href="#VDAF" class="cite xref">VDAF</a>]</span> describes how to
distribute this computation amongst two aggregation servers such that, as long
as one server is honest, no individual's input is observed in the clear. At the
same time, Poplar1 allows the servers to detect and remove any invalid
measurements that would otherwise corrupt the computation.<a href="#section-1-4" class="pilcrow">¶</a></p>
<p id="section-1-5">This document describes Mastic <span>[<a href="#MPDST25" class="cite xref">MPDST25</a>]</span>, a VDAF for the following, more
general functionality: each client holds an input and an associated weight, and
the data collector's goal is, for each candidate prefix, to aggregate the
weights of all clients whose inputs have the prefix in common. This
functionality gives rise to two types of applications:<a href="#section-1-5" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-1-6">
<li id="section-1-6.1">
          <p id="section-1-6.1.1">"weighted heavy hitters": Rather than compute the most frequent inputs, as
in plain heavy hitters, the goal here is to compute the set of inputs with
the highest total weight. For example, a browser vendor might want to know
which web pages have the highest average load time, perhaps indicating a
performance issue in the browser. Because weighted heavy hitters is more
general, Mastic can be used as a drop-in replacement for Poplar1. It is is
also more efficient, requiring just one round of communication for
preparation (<span><a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-14#section-5.2" class="relref">Section 5.2</a> of [<a href="#VDAF" class="cite xref">VDAF</a>]</span>) compared to Poplar1's two rounds.<a href="#section-1-6.1.1" class="pilcrow">¶</a></p>
</li>
        <li id="section-1-6.2">
          <p id="section-1-6.2.1">"attribute-based metrics": The Prio3 VDAF (<span><a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-14#section-7" class="relref">Section 7</a> of [<a href="#VDAF" class="cite xref">VDAF</a>]</span>) can be
used for a variety of aggregation tasks, ranging from simple summary
statistics, like average or standard deviation, to more sophisticated
representations of data, like histograms or linear regression. In many
situations, it is desirable to group such metrics by client attributes such
as geolocation or user agent (<span><a href="https://rfc-editor.org/rfc/rfc9110#section-10.1.5" class="relref">Section 10.1.5</a> of [<a href="#RFC9110" class="cite xref">RFC9110</a>]</span>). Mastic
provides this functionality without revealing any client's attribute to the
aggregation servers or data collector.<a href="#section-1-6.2.1" class="pilcrow">¶</a></p>
</li>
      </ol>
<p id="section-1-7">The main component of Mastic is the Verifiable Incremental Distributed Point
Function (VIDPF) of <span>[<a href="#MST24" class="cite xref">MST24</a>]</span>. VIDPF extends IDPF (<span><a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-14#section-8.3" class="relref">Section 8.3</a> of [<a href="#VDAF" class="cite xref">VDAF</a>]</span>),
the main building block of Poplar1. Both IDPF and VIDPF are a form of function
secret sharing <span>[<a href="#BGI15" class="cite xref">BGI15</a>]</span>, where a client generates shares of a secret function
<code>F</code> such that each server can compute shares of <code>F(X)</code> for a chosen <code>X</code>. In our
case, the function being shared is associated with a secret input string <code>alpha</code>
and weight <code>beta</code> for which <code>F(X) = beta</code> for every prefix <code>X</code> of <code>alpha</code> and
<code>F(X) = 0</code> for every <code>X</code> this is not a prefix of <code>alpha</code>. The scheme is
verifiable in the sense that, for any two candidate prefixes of the same length,
the servers can verify that at most one of them evaluates to <code>beta</code> and the
other(s) evaluate(s) to <code>0</code>.<a href="#section-1-7" class="pilcrow">¶</a></p>
<p id="section-1-8">Mastic combines VIDPF with a method for checking that <code>beta</code> itself is a valid
weight. For example, if the weights represent page load times, it is important
to make sure each weight is within a sensible range, say within seconds rather
than hours or days. Otherwise, misbehaving clients would be able to poison the
computation by reporting out of range values.<a href="#section-1-8" class="pilcrow">¶</a></p>
<p id="section-1-9">This range check is accomplished with the Fully Linear Proof (FLP) system of
<span><a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-14#section-7.3" class="relref">Section 7.3</a> of [<a href="#VDAF" class="cite xref">VDAF</a>]</span>. An FLP allows properties of secret shared data to be
validated without revealing the data itself. In Mastic, the client generates an
FLP of its <code>beta</code>'s validity; when the servers are ready to evaluate the VIDPF,
they first compute shares of <code>beta</code> and verify the FLP, which itself is secret
shared. Then the VIDPF ensures that the non-<code>0</code> output of the point function is
the same for each evaluation.<a href="#section-1-9" class="pilcrow">¶</a></p>
<p id="section-1-10">This document specifies VIDPF in <a href="#vidpf" class="auto internal xref">Section 3</a> and the composition of VIDPF and FLP
into Mastic in <a href="#vidpf" class="auto internal xref">Section 3</a>. The appendix includes supplementary material:<a href="#section-1-10" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1-11.1">
          <p id="section-1-11.1.1"><a href="#motivation" class="auto internal xref">Appendix "Motivating Applications"</a> discusses some use cases that motivated Mastic's
functionality.<a href="#section-1-11.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-1-11.2">
          <p id="section-1-11.2.1"><a href="#additional-modes" class="auto internal xref">Appendix "Modes of Operation"</a> describes extensions and optimizations for Mastic,
including a batched "preparation" (<span><a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-14#section-5.2" class="relref">Section 5.2</a> of [<a href="#VDAF" class="cite xref">VDAF</a>]</span>) mode of
operation that reduces communication cost, and a 3-party variant of the
protocol that ensures robustness against poisoning attacks in the presence of
one malicious aggregation server.<a href="#section-1-11.2.1" class="pilcrow">¶</a></p>
</li>
      </ul>
</section>
</div>
<div id="conventions">
<section id="section-2">
      <h2 id="name-conventions-and-definitions">
<a href="#section-2" class="section-number selfRef">2. </a><a href="#name-conventions-and-definitions" class="section-name selfRef">Conventions and Definitions</a>
      </h2>
<p id="section-2-1">The key words "<span class="bcp14">MUST</span>", "<span class="bcp14">MUST NOT</span>", "<span class="bcp14">REQUIRED</span>", "<span class="bcp14">SHALL</span>", "<span class="bcp14">SHALL NOT</span>", "<span class="bcp14">SHOULD</span>", "<span class="bcp14">SHOULD NOT</span>", "<span class="bcp14">RECOMMENDED</span>", "<span class="bcp14">NOT RECOMMENDED</span>",
"<span class="bcp14">MAY</span>", and "<span class="bcp14">OPTIONAL</span>" in this document are to be interpreted as
described in BCP 14 <span>[<a href="#RFC2119" class="cite xref">RFC2119</a>]</span> <span>[<a href="#RFC8174" class="cite xref">RFC8174</a>]</span> when, and only when, they
appear in all capitals, as shown here.<a href="#section-2-1" class="pilcrow">¶</a></p>
<p id="section-2-2">This document uses the same conventions and definitions as <span><a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-14#section-2" class="relref">Section 2</a> of [<a href="#VDAF" class="cite xref">VDAF</a>]</span>. The following terms as defined in therein:
"Aggregator",
"Client",
"Collector",
"aggregate result",
"aggregate share",
"aggregation parameter",
"batch",
"input share",
"measurement",
"output share",
"prep message",
"prep share", and
"report".<a href="#section-2-2" class="pilcrow">¶</a></p>
<p id="section-2-3">The following functions are as defined therein:<a href="#section-2-3" class="pilcrow">¶</a></p>
<span id="name-common-functionalities"></span><div id="common-functions">
<table class="center" id="table-1">
        <caption>
<a href="#table-1" class="selfRef">Table 1</a>:
<a href="#name-common-functionalities" class="selfRef">Common Functionalities.</a>
        </caption>
<thead>
          <tr>
            <th class="text-left" rowspan="1" colspan="1">Functionality</th>
            <th class="text-left" rowspan="1" colspan="1">Type</th>
            <th class="text-left" rowspan="1" colspan="1">Definition</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>byte</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Function</td>
            <td class="text-left" rowspan="1" colspan="1">Section 2</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>cast</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Function</td>
            <td class="text-left" rowspan="1" colspan="1">Section 2</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>concat</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Function</td>
            <td class="text-left" rowspan="1" colspan="1">Section 2</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>front</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Function</td>
            <td class="text-left" rowspan="1" colspan="1">Section 2</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>range</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Function</td>
            <td class="text-left" rowspan="1" colspan="1">Section 2</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>to_le_bytes</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Function</td>
            <td class="text-left" rowspan="1" colspan="1">Section 2</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>xor</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Function</td>
            <td class="text-left" rowspan="1" colspan="1">Section 2</td>
          </tr>
        </tbody>
      </table>
</div>
<p id="section-2-5">Mastic also uses finite fields as specified in <span><a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-14#section-6.1" class="relref">Section 6.1</a> of [<a href="#VDAF" class="cite xref">VDAF</a>]</span>. We
usually denote a finite field by <code>F</code> and its Python class object, a subclass of
<code>Field</code>, as <code>field: type[F]</code>. This document references the following operations
on fields, defined in <span><a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-14#section-6.1" class="relref">Section 6.1</a> of [<a href="#VDAF" class="cite xref">VDAF</a>]</span>:<a href="#section-2-5" class="pilcrow">¶</a></p>
<span id="name-finite-field-functionalitie"></span><div id="field-functionalities">
<table class="center" id="table-2">
        <caption>
<a href="#table-2" class="selfRef">Table 2</a>:
<a href="#name-finite-field-functionalitie" class="selfRef">Finite Field Functionalities.</a>
        </caption>
<thead>
          <tr>
            <th class="text-left" rowspan="1" colspan="1">Functionality</th>
            <th class="text-left" rowspan="1" colspan="1">Type</th>
            <th class="text-left" rowspan="1" colspan="1">Definition</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>Field</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Constructor</td>
            <td class="text-left" rowspan="1" colspan="1">Section 6.1</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>field.encode_vec</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Instance Method</td>
            <td class="text-left" rowspan="1" colspan="1">Section 6.1.1</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>field.zeros</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Instance Method</td>
            <td class="text-left" rowspan="1" colspan="1">Section 6.1</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>vec_add</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Function</td>
            <td class="text-left" rowspan="1" colspan="1">Section 6.1.1</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>vec_neg</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Function</td>
            <td class="text-left" rowspan="1" colspan="1">Section 6.1.1</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>vec_sub</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Function</td>
            <td class="text-left" rowspan="1" colspan="1">Section 6.1.1</td>
          </tr>
        </tbody>
      </table>
</div>
<p id="section-2-7">Mastic uses the Fully Linear Proof (FLP) system specified in <span><a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-14#section-7.3" class="relref">Section 7.3</a> of [<a href="#VDAF" class="cite xref">VDAF</a>]</span>. The draft refers to the following methods on an instance <code>flp</code> of the
class <code>Flp</code> defined in <span>[<a href="#VDAF" class="cite xref">VDAF</a>]</span>:<a href="#section-2-7" class="pilcrow">¶</a></p>
<span id="name-flp-methods-and-parameters"></span><div id="FLP-functionalities">
<table class="center" id="table-3">
        <caption>
<a href="#table-3" class="selfRef">Table 3</a>:
<a href="#name-flp-methods-and-parameters" class="selfRef">FLP methods and parameters.</a>
        </caption>
<thead>
          <tr>
            <th class="text-left" rowspan="1" colspan="1">Functionality</th>
            <th class="text-left" rowspan="1" colspan="1">Type  --</th>
            <th class="text-left" rowspan="1" colspan="1">Definition</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>flp.decide</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Instance Method</td>
            <td class="text-left" rowspan="1" colspan="1">Section 7.1</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>flp.decode</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Instance Method</td>
            <td class="text-left" rowspan="1" colspan="1">Section 7.1.1</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>flp.encode</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Instance Method</td>
            <td class="text-left" rowspan="1" colspan="1">Section 7.1.1</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>flp.prove</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Instance Method</td>
            <td class="text-left" rowspan="1" colspan="1">Section 7.1</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>flp.query</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Instance Method</td>
            <td class="text-left" rowspan="1" colspan="1">Section 7.1</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>flp.truncate</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Instance Method</td>
            <td class="text-left" rowspan="1" colspan="1">Section 7.1.1</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>MEAS_LEN</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">integer</td>
            <td class="text-left" rowspan="1" colspan="1">Section 7.3.2</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>OUTPUT_LEN</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">integer</td>
            <td class="text-left" rowspan="1" colspan="1">Section 7.3.2</td>
          </tr>
        </tbody>
      </table>
</div>
<p id="section-2-9">Mastic also uses eXtendable Output Functions (XOFs) as specified in <span><a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-14#section-6.2" class="relref">Section 6.2</a> of [<a href="#VDAF" class="cite xref">VDAF</a>]</span>. The following functionalities are as defined therein (<code>xof</code>
denotes an instance of class <code>Xof</code>):<a href="#section-2-9" class="pilcrow">¶</a></p>
<span id="name-xof-functionalities"></span><div id="XOF-functionalities">
<table class="center" id="table-4">
        <caption>
<a href="#table-4" class="selfRef">Table 4</a>:
<a href="#name-xof-functionalities" class="selfRef">XOF Functionalities.</a>
        </caption>
<thead>
          <tr>
            <th class="text-left" rowspan="1" colspan="1">Functionality</th>
            <th class="text-left" rowspan="1" colspan="1">Type</th>
            <th class="text-left" rowspan="1" colspan="1">Definition</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>XofFixedKeyAes128</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Constructor</td>
            <td class="text-left" rowspan="1" colspan="1">Section 6.2</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>XofTurboShake128</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Constructor</td>
            <td class="text-left" rowspan="1" colspan="1">Section 6.2</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>xof.next</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Instance Method</td>
            <td class="text-left" rowspan="1" colspan="1">Section 6.2</td>
          </tr>
        </tbody>
      </table>
</div>
<p id="section-2-11">Each invocation of a XOF is initialized with a domain separation tag. Each
domain separation tag encodes the version of this document, the application
context string (<span><a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-14#section-4.1" class="relref">Section 4.1</a> of [<a href="#VDAF" class="cite xref">VDAF</a>]</span>), and a distinguished byte identifying
how the XOF output is used. The tag may also encode a VDAF algorithm ID
(<span><a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-14#section-5" class="relref">Section 5</a> of [<a href="#VDAF" class="cite xref">VDAF</a>]</span>).<a href="#section-2-11" class="pilcrow">¶</a></p>
<p id="section-2-12">The version of this document is a byte denoted <code>VERSION</code>. Its value <span class="bcp14">SHALL</span> be <code>0</code>.<a href="#section-2-12" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-2-13.1">
          <p id="section-2-13.1.1">NOTE We'll bump <code>VERSION</code> whenever we publish a draft with incompatible
changes from the previous draft.<a href="#section-2-13.1.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-2-14">Algorithms in the remainder will use the following algorithms:<a href="#section-2-14" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-2-15">
<pre>
def dst(ctx: bytes, usage: int) -&gt; bytes:
    return b'mastic' + byte(VERSION) + byte(usage) + ctx

def dst_alg(ctx: bytes, usage: int, algorithm_id: int) -&gt; bytes:
    return b'mastic'\
        + byte(VERSION) \
        + byte(usage) \
        + to_be_bytes(algorithm_id, 4) \
        + ctx
</pre><a href="#section-2-15" class="pilcrow">¶</a>
</div>
<p id="section-2-16">When using Mastic or VIDPF, the length of the application context string
(denoted <code>ctx</code>) <span class="bcp14">MUST</span> be in range <code>[0, 2^16 - 12)</code>.<a href="#section-2-16" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-2-17.1">
          <p id="section-2-17.1.1">NOTE This range was computed by taking the maximum size of the domain
separation tag supported by both XofFixedKeyAes128 and XofTurboShake128 and
subtracting the length of the prefix.<a href="#section-2-17.1.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-2-18">Finally, for completeness, we define some Python methods used in the remainder:<a href="#section-2-18" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-2-19.1">
          <p id="section-2-19.1.1"><code>bool(val: Any) -&gt; bool</code> converts a value <code>val</code> to a Boolean.<a href="#section-2-19.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-19.2">
          <p id="section-2-19.2.1"><code>bytearray(source: Union[str, bytes, bytearray, Iterable[int]]) -&gt;
bytearray</code> returns a mutable sequence of bytes.<a href="#section-2-19.2.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-19.3">
          <p id="section-2-19.3.1"><code>bytes(source: Union[str, bytes, bytearray, Iterable[int]]) -&gt; bytes</code>
returns a immutable sequence of bytes.<a href="#section-2-19.3.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-19.4">
          <p id="section-2-19.4.1"><code>len(obj: Sized) -&gt; int</code> returns the number of items in <code>obj</code>. The object
argument can be a sequence (e.g., string, list, or tuple) or a collection
(e.g., dictionary, set).<a href="#section-2-19.4.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-19.5">
          <p id="section-2-19.5.1"><code>list.append(elem: Any) -&gt; None</code> adds a single element <code>elem</code> to the end of
a <code>list</code> instance.<a href="#section-2-19.5.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-19.6">
          <p id="section-2-19.6.1"><code>list.copy() -&gt; list</code> returns a shallow copy of a <code>list</code> instance.<a href="#section-2-19.6.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-19.7">
          <p id="section-2-19.7.1"><code>set(iterable: Optional[Iterable] = None) -&gt; set</code> creates a new set object,
which is an unordered collection of unique elements. The optional <code>iterable</code>
argument (e.g., list, tuple, or string) is used to initialize the set. If no
argument is provided, an empty set is created.<a href="#section-2-19.7.1" class="pilcrow">¶</a></p>
</li>
      </ul>
</section>
</div>
<div id="vidpf">
<section id="section-3">
      <h2 id="name-specification-of-vidpf">
<a href="#section-3" class="section-number selfRef">3. </a><a href="#name-specification-of-vidpf" class="section-name selfRef">Specification of VIDPF</a>
      </h2>
<span id="name-vidpf-parameters"></span><div id="vidpf-params">
<table class="center" id="table-5">
        <caption>
<a href="#table-5" class="selfRef">Table 5</a>:
<a href="#name-vidpf-parameters" class="selfRef">VIDPF parameters.</a>
        </caption>
<thead>
          <tr>
            <th class="text-left" rowspan="1" colspan="1">Parameter</th>
            <th class="text-left" rowspan="1" colspan="1">Description</th>
            <th class="text-left" rowspan="1" colspan="1">Value</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>KEY_SIZE: int</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">the size of each VIDPF key</td>
            <td class="text-left" rowspan="1" colspan="1">
              <code>XofFixedKeyAes128.SEED_SIZE</code> (<span><a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-14#section-6.2.2" class="relref">Section 6.2.2</a> of [<a href="#VDAF" class="cite xref">VDAF</a>]</span>)</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>NONCE_SIZE: int</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">the size of the VIDPF nonce</td>
            <td class="text-left" rowspan="1" colspan="1">
              <code>KEY_SIZE</code>
</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>RAND_SIZE: int</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">the number of random bytes consumed by <code>gen()</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">
              <code>2 * KEY_SIZE</code>
</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>BITS: int</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">bit length of the input string <code>alpha</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">set by constructor</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>VALUE_LEN: int</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">length of <code>beta</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">set by constructor</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>field: type[F]</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">class object for the field (<span><a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-14#section-6.1" class="relref">Section 6.1</a> of [<a href="#VDAF" class="cite xref">VDAF</a>]</span>)</td>
            <td class="text-left" rowspan="1" colspan="1">set by constructor</td>
          </tr>
        </tbody>
      </table>
</div>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-3-2.1">
          <p id="section-3-2.1.1">NOTE This specification is based on <span>[<a href="#MST24" class="cite xref">MST24</a>]</span>, which in turn draws on ideas
from <span>[<a href="#CP22" class="cite xref">CP22</a>]</span>. We don't yet have a concrete security analysis of the complete
construction. Some details are likely to change as a result of such analysis.<a href="#section-3-2.1.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-3-3">This section specifies the Verifiable Incremental Distributed Point Function
(VIDPF) of <span>[<a href="#MST24" class="cite xref">MST24</a>]</span>. Its parameters are summarized in <a href="#vidpf-params" class="auto internal xref">Table 5</a>.<a href="#section-3-3" class="pilcrow">¶</a></p>
<p id="section-3-4">VIDPF is a function secret sharing scheme <span>[<a href="#BGI15" class="cite xref">BGI15</a>]</span> for functions <code>F</code> for which:<a href="#section-3-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3-5.1">
          <p id="section-3-5.1.1"><code>F(X) = </code>beta<code> if </code>X<code> is a prefix of </code>alpha`<a href="#section-3-5.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-3-5.2">
          <p id="section-3-5.2.1"><code>F(X) = field.zeros(VALUE_LEN)</code> if <code>x</code> is not a prefix of <code>alpha</code><a href="#section-3-5.2.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-3-6">where <code>alpha</code> and <code>beta</code> are the input and encoded weight of a Client and
<code>field</code> the finite field. The scheme is designed to allow each Aggregator to
compute a share of <code>F(X)</code> for any candidate prefix <code>X</code> without revealing any
information about <code>alpha</code> or <code>beta</code>. Furthermore, the output shares can be
aggregated locally, allowing each Aggregator to compute a share of the total
weight for all inputs that have <code>X</code> as a prefix.<a href="#section-3-6" class="pilcrow">¶</a></p>
<p id="section-3-7">VIDPF comprises two algorithms.<a href="#section-3-7" class="pilcrow">¶</a></p>
<p id="section-3-8">The key generation algorithm defined in <a href="#vidpf-key-gen" class="auto internal xref">Section 3.1</a> takes in a <code>(alpha,
beta)</code> and the report nonce and outputs secret shares of <code>F</code>. The shares take
the form of a pair of "keys", one for each Aggregator, and a sequence of
"correction words" sent to both Aggregators. We define correction words in the
next section.<a href="#section-3-8" class="pilcrow">¶</a></p>
<p id="section-3-9">The Aggregators evaluate a Client's VIDPF on a sequence of candidate prefixes.
Imagine arranging these prefixes in a binary tree where each path from the root
corresponds to a prefix <code>X</code> and each node corresponds to a payload <code>F(X)</code>. We
refer to this as the "prefix tree".<a href="#section-3-9" class="pilcrow">¶</a></p>
<p id="section-3-10">The key evaluation algorithm defined in <a href="#vidpf-key-eval" class="auto internal xref">Section 3.2</a> takes in the
correction words, the Aggregator's key, the sequence of candidate prefixes, and
the nonce associated with the Client's report. It the Aggregator's share of the
prefix tree.<a href="#section-3-10" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-3-11.1">
          <p id="section-3-11.1.1">TODO Define the "node proofs".<a href="#section-3-11.1.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<div id="vidpf-key-gen">
<section id="section-3.1">
        <h3 id="name-key-generation">
<a href="#section-3.1" class="section-number selfRef">3.1. </a><a href="#name-key-generation" class="section-name selfRef">Key Generation</a>
        </h3>
<p id="section-3.1-1">The VIDPF-key generation algorithm run by each Client is listed below. The
specification invokes auxiliary functions, namely <code>extend()</code>, <code>convert()</code>, and
<code>node_proof()</code>, which are defined in <a href="#vidpf-aux" class="auto internal xref">Section 3.3</a>. Its inputs are the input
string <code>alpha</code>, the encoded weight <code>beta</code>, the application context string <code>ctx</code>
(<span><a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-14#section-4.1" class="relref">Section 4.1</a> of [<a href="#VDAF" class="cite xref">VDAF</a>]</span>), a public nonce of length <code>NONCE_SIZE</code>, and the
randomness consumed by the algorithm of length <code>RAND_SIZE</code>. Its outputs are the
public sequence of "correction words", one for each level of the tree, and the
secret keys, one for each Aggregator.<a href="#section-3.1-1" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-3.1-2.1">
            <p id="section-3.1-2.1.1">TODO Give a high level overview of how IDPF works, in particular the
seed/control-bit invariant for each level. Define <code>CorrectionWord</code> and
explain the role of correction words and define node proofs, which are unique
to VIDPF.<a href="#section-3.1-2.1.1" class="pilcrow">¶</a></p>
<p id="section-3.1-2.1.2">TODO Specify bounds on the inputs, namely that the nonce has to be random.
(This is inherited from IDPF security considerations.)<a href="#section-3.1-2.1.2" class="pilcrow">¶</a></p>
<p id="section-3.1-2.1.3">TODO Explain functional differences between VIDPF and IDPF in
<span><a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-14#section-8" class="relref">Section 8</a> of [<a href="#VDAF" class="cite xref">VDAF</a>]</span>. Namely, there is no distinction between inner and
leaf nodes and the payload is supposed to be the same at each level.<a href="#section-3.1-2.1.3" class="pilcrow">¶</a></p>
</li>
        </ul>
<div class="breakable lang-python sourcecode" id="section-3.1-3">
<pre>
def gen(self,
        alpha: tuple[bool, ...],
        beta: list[F],
        ctx: bytes,
        nonce: bytes,
        rand: bytes,
        ) -&gt; tuple[list[CorrectionWord], list[bytes]]:
    '''
    The VIDPF key generation algorithm.

    Returns the public share (i.e., the correction word for each
    level of the tree) and two keys, one for each aggregator.

    Implementation note: for clarity, this algorithm has not been
    written in a manner that is side-channel resistant. To avoid
    leaking `alpha` via a side-channel, implementations should avoid
    branching or indexing into arrays in a data-dependent manner.
    '''
    if len(alpha) != self.BITS:
        raise ValueError("alpha out of range")
    if len(beta) != self.VALUE_LEN:
        raise ValueError("incorrect beta length")
    if len(nonce) != self.NONCE_SIZE:
        raise ValueError("incorrect nonce size")
    if len(rand) != self.RAND_SIZE:
        raise ValueError("randomness has incorrect length")

    keys = [rand[:self.KEY_SIZE], rand[self.KEY_SIZE:]]

    # [MST24, Fig. 15]: s0^0, s1^0, t0^0, t1^0
    seed = keys.copy()
    ctrl = [False, True]
    correction_words = []
    for i in range(self.BITS):
        idx = PrefixTreeIndex(alpha[:i+1])
        bit = alpha[i]

        # [MST24]: if x = 0 then keep &lt;- L, lose &lt;- R
        #
        # Implementation note: the value of `bit` is
        # `alpha`-dependent.
        (keep, lose) = (1, 0) if bit else (0, 1)

        # Extend: compute the left and right children the current
        # level of the tree. During evaluation, one of these children
        # will be selected as the next seed and control bit.
        #
        # [MST24]: s_0^L || s_0^R || t_0^L || t_0^R
        #          s_1^L || s_1^R || t_1^L || t_1^R
        (s0, t0) = self.extend(seed[0], ctx, nonce)
        (s1, t1) = self.extend(seed[1], ctx, nonce)

        # Compute the correction words for this level's seed and
        # control bit. Our goal is to maintain the following
        # invariant, after correction:
        #
        # * If evaluation is on path, then each aggregator will
        #   compute a different seed and their control bits will be
        #   secret shares of one.
        #
        # * If evaluation is off path, then the aggregators will
        #   compute the same seed and their control bits will be
        #   shares of zero.
        #
        # Implementation note: the index `lose` is `alpha`-dependent.
        seed_cw = xor(s0[lose], s1[lose])
        ctrl_cw = [
            t0[0] ^ t1[0] ^ (not bit),  # [MST24]: t_c^L
            t0[1] ^ t1[1] ^ bit,        # [MST24]: t_c^R
        ]

        # Correct.
        #
        # Implementation note: the index `keep` is `alpha`-dependent,
        # as is `ctrl`.
        if ctrl[0]:
            s0[keep] = xor(s0[keep], seed_cw)
            t0[keep] ^= ctrl_cw[keep]
        if ctrl[1]:
            s1[keep] = xor(s1[keep], seed_cw)
            t1[keep] ^= ctrl_cw[keep]

        # Convert.
        (seed[0], w0) = self.convert(s0[keep], ctx, nonce)
        (seed[1], w1) = self.convert(s1[keep], ctx, nonce)
        ctrl[0] = t0[keep]  # [MST24]: t0'
        ctrl[1] = t1[keep]  # [MST24]: t1'

        # Compute the correction word for this level's payload.
        #
        # Implementation note: `ctrl` is `alpha`-dependent.
        w_cw = vec_add(vec_sub(beta, w0), w1)
        if ctrl[1]:
            w_cw = vec_neg(w_cw)

        # Compute the correction word for this level's node proof. If
        # evaluation is on path, then exactly one of the aggregatos
        # will correct their node proof, causing them to compute the
        # same node value. If evaluation is off path, then both will
        # correct or neither will; and since they compute the same
        # seed, they will again compute the same value.
        proof_cw = xor(
            self.node_proof(seed[0], ctx, idx),
            self.node_proof(seed[1], ctx, idx),
        )

        correction_words.append((seed_cw, ctrl_cw, w_cw, proof_cw))

    return (correction_words, keys)
</pre><a href="#section-3.1-3" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="vidpf-key-eval">
<section id="section-3.2">
        <h3 id="name-key-evaluation">
<a href="#section-3.2" class="section-number selfRef">3.2. </a><a href="#name-key-evaluation" class="section-name selfRef">Key Evaluation</a>
        </h3>
<p id="section-3.2-1">The VIDPF-key evaluation algorithm is listed below. See <a href="#vidpf-aux" class="auto internal xref">Section 3.3</a> for
deferred auxiliary functions. Its inputs are the Aggregator's ID (either <code>0</code> or
<code>1</code>), the correction words, the Aggregator's key, the level of the tree, the
sequence of prefixes, and the nonce associated with the report. Its outputs are
the sequence of output shares for each prefix, and the evaluation proof.<a href="#section-3.2-1" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-3.2-2.1">
            <p id="section-3.2-2.1.1">TODO Define <code>PrefixTreeIndex</code> and <code>PrefixTreeEntry</code>.<a href="#section-3.2-2.1.1" class="pilcrow">¶</a></p>
<p id="section-3.2-2.1.2">TODO Say why we also visit the siblings of nodes in the prefix tree (it's
needed for Mastic).<a href="#section-3.2-2.1.2" class="pilcrow">¶</a></p>
</li>
        </ul>
<div class="lang-python sourcecode" id="section-3.2-3">
<pre>
def eval_next(self,
                node: PrefixTreeEntry,
                correction_word: CorrectionWord,
                ctx: bytes,
                nonce: bytes,
                idx: PrefixTreeIndex,
                ) -&gt; PrefixTreeEntry:
    """
    Extend a node in the tree, select and correct one of its
    children, then convert it into a payload and the next seed.
    """
    (seed_cw, ctrl_cw, w_cw, proof_cw) = correction_word
    keep = int(idx.path[-1])

    # Extend.
    #
    # [MST24, Fig. 17]: (s^L, s^R), (t^L, t^R) = PRG(s^{i-1})
    (s, t) = self.extend(node.seed, ctx, nonce)

    # Correct.
    #
    # Implementation note: avoid branching on the value of control
    # bits, as its value may be leaked by a side channel.
    if node.ctrl:
        s[keep] = xor(s[keep], seed_cw)
        t[keep] ^= ctrl_cw[keep]

    # Convert and correct the payload.
    #
    # Implementation note: the conditional addition should be
    # replaced with a constant-time select in practice in order to
    # reduce leakage via timing side channels.
    (next_seed, w) = self.convert(s[keep], ctx, nonce)
    next_ctrl = t[keep]  # [MST24]: s^i, W^i, t'^i
    if next_ctrl:
        w = vec_add(w, w_cw)

    # Compute and correct the node proof.
    #
    # Implementation note: avoid branching on the control bit here.
    node_proof = self.node_proof(next_seed, ctx, idx)
    if next_ctrl:
        node_proof = xor(node_proof, proof_cw)

    return PrefixTreeEntry(next_seed, next_ctrl, w, node_proof)
</pre><a href="#section-3.2-3" class="pilcrow">¶</a>
</div>
<p id="section-3.2-4">Evaluating the prefix tree, plus the sibling of each n ode in the prefix tree:<a href="#section-3.2-4" class="pilcrow">¶</a></p>
<div class="breakable lang-python sourcecode" id="section-3.2-5">
<pre>
def eval_with_siblings(self,
                        agg_id: int,
                        correction_words: list[CorrectionWord],
                        key: bytes,
                        level: int,
                        prefixes: tuple[tuple[bool, ...], ...],
                        ctx: bytes,
                        nonce: bytes,
                        ) -&gt; tuple[list[list[F]], PrefixTreeEntry]:
    """
    The VIDPF key evaluation algorithm.

    The return value consists of the weights for each candidate prefix and
    the root of the prefix tree. The prefix tree includes the prefixes and
    the siblings of each node visited.
    """
    if agg_id not in range(2):
        raise ValueError("invalid aggregator ID")
    if len(correction_words) != self.BITS:
        raise ValueError("corrections words has incorrect length")
    if level not in range(self.BITS):
        raise ValueError("level too deep")
    for prefix in prefixes:
        if len(prefix) != level + 1:
            raise ValueError("prefix with incorrect length")
    if len(set(prefixes)) != len(prefixes):
        raise ValueError("candidate prefixes are non-unique")

    # Evaluate our share of the prefix tree, including the sibling of each
    # node we visit.
    #
    # Implementation note: we can save computation by storing the tree
    # across `eval()` calls for the same report.
    root = PrefixTreeEntry.root(key, bool(agg_id))
    out_share = []
    for prefix in prefixes:
        n = root
        for (i, bit) in enumerate(prefix):
            idx = PrefixTreeIndex(prefix[:i+1])
            if n.left_child is None:
                n.left_child = self.eval_next(n, correction_words[i], ctx,
                                                nonce, idx.left_sibling())
            if n.right_child is None:
                n.right_child = self.eval_next(n, correction_words[i], ctx,
                                                nonce, idx.right_sibling())
            n = n.right_child if bit else n.left_child
        out_share.append(n.w if agg_id == 0 else vec_neg(n.w))

    return (out_share, root)
</pre><a href="#section-3.2-5" class="pilcrow">¶</a>
</div>
<p id="section-3.2-6">Obtaining our share of <code>beta</code>, the payload programmed into the prefix tree:<a href="#section-3.2-6" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-3.2-7">
<pre>
def get_beta_share(
        self,
        agg_id: int,
        correction_words: list[CorrectionWord],
        key: bytes,
        ctx: bytes,
        nonce: bytes,
) -&gt; list[F]:
    root = PrefixTreeEntry.root(key, bool(agg_id))
    left = self.eval_next(root, correction_words[0], ctx, nonce,
                          PrefixTreeIndex((False,)))
    right = self.eval_next(root, correction_words[0], ctx, nonce,
                           PrefixTreeIndex((True,)))
    beta_share = vec_add(left.w, right.w)
    if agg_id == 1:
        beta_share = vec_neg(beta_share)
    return beta_share
</pre><a href="#section-3.2-7" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="vidpf-aux">
<section id="section-3.3">
        <h3 id="name-auxiliary-functions">
<a href="#section-3.3" class="section-number selfRef">3.3. </a><a href="#name-auxiliary-functions" class="section-name selfRef">Auxiliary functions</a>
        </h3>
<div class="breakable lang-python sourcecode" id="section-3.3-1">
<pre>
def extend(self,
            seed: bytes,
            ctx: bytes,
            nonce: bytes,
            ) -&gt; tuple[list[bytes], Ctrl]:
    '''
    Extend a seed into the seed and control bits for its left and
    right children in the VIDPF tree.
    '''
    xof = XofFixedKeyAes128(seed, dst(ctx, USAGE_EXTEND), nonce)
    s = [
        bytearray(xof.next(self.KEY_SIZE)),
        bytearray(xof.next(self.KEY_SIZE)),
    ]
    # Use the least significant bits as the control bit correction,
    # and then zero it out. This gives effectively 127 bits of
    # security, but reduces the number of AES calls needed by 1/3.
    t = [bool(s[0][0] &amp; 1), bool(s[1][0] &amp; 1)]
    s[0][0] &amp;= 0xFE
    s[1][0] &amp;= 0xFE
    return ([bytes(s[0]), bytes(s[1])], t)

def convert(self,
            seed: bytes,
            ctx: bytes,
            nonce: bytes,
            ) -&gt; tuple[bytes, list[F]]:
    '''
    Convert a selected seed into a payload and the seed for the next
    level.
    '''
    xof = XofFixedKeyAes128(seed, dst(ctx, USAGE_CONVERT), nonce)
    next_seed = xof.next(XofFixedKeyAes128.SEED_SIZE)
    payload = xof.next_vec(self.field, self.VALUE_LEN)
    return (next_seed, payload)

def node_proof(self,
                seed: bytes,
                ctx: bytes,
                idx: PrefixTreeIndex) -&gt; bytes:
    '''
    Compute the proof for this node.
    '''
    binder = \
        to_le_bytes(self.BITS, 2) + \
        to_le_bytes(idx.level(), 2) + \
        idx.encode()
    xof = XofTurboShake128(seed,
                            dst(ctx, USAGE_NODE_PROOF),
                            binder)
    return xof.next(PROOF_SIZE)
</pre><a href="#section-3.3-1" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
<div id="vdaf">
<section id="section-4">
      <h2 id="name-specification-of-mastic">
<a href="#section-4" class="section-number selfRef">4. </a><a href="#name-specification-of-mastic" class="section-name selfRef">Specification of Mastic</a>
      </h2>
<p id="section-4-1">An instance of Mastic is determined by a desired bit-length of the input,
denoted <code>BITS</code>, and a validity circuit, an instance of <code>Valid</code> as defined in
<span><a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-14#section-7.3.2" class="relref">Section 7.3.2</a> of [<a href="#VDAF" class="cite xref">VDAF</a>]</span>. The validity circuit is used to instantiate the FLP
and defines the type of the weights generated by Clients and the type of the
total weight for each prefix computed by the Collector.<a href="#section-4-1" class="pilcrow">¶</a></p>
<p id="section-4-2">The Client's measurement has two components: the input string <code>alpha:
tuple[bool, ...]</code> of length <code>BITS</code> and its weight. The weight's type is denoted
by <code>W</code>. We use <code>beta: list[F]</code> to denote the encoded weight, obtained by
invoking the FLP's encoder (<span><a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-14#section-7.1.1" class="relref">Section 7.1.1</a> of [<a href="#VDAF" class="cite xref">VDAF</a>]</span>).<a href="#section-4-2" class="pilcrow">¶</a></p>
<p id="section-4-3">The aggregate result has type <code>list[R]</code>, where <code>R</code> is likewise a type defined
by the validity circuit. Each element of this list corresponds to the total
weight for one of the candidate prefixes.<a href="#section-4-3" class="pilcrow">¶</a></p>
<p id="section-4-4">The VIDPF is instantiated with bit length <code>BITS</code>, value length
<code>valid.MEAS_LEN</code>, and field <code>valid.field</code>, where <code>valid</code> is the validity
circuit. We denote this instance of the VIDPF by <code>vidpf</code>.<a href="#section-4-4" class="pilcrow">¶</a></p>
<p id="section-4-5">In the remainder, we write <code>xof</code> as shorthand for <code>XofTurboShake128</code> (<span><a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-14#section-6.2.1" class="relref">Section 6.2.1</a> of [<a href="#VDAF" class="cite xref">VDAF</a>]</span>).<a href="#section-4-5" class="pilcrow">¶</a></p>
<p id="section-4-6">Mastic's implementation of the VDAF interface (<span><a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-14#section-5" class="relref">Section 5</a> of [<a href="#VDAF" class="cite xref">VDAF</a>]</span>) is
specified in the following sections. <a href="#mastic-aux" class="auto internal xref">Section 4.6</a> defines some auxiliary
functions referenced in the sharding and preparation sections.<a href="#section-4-6" class="pilcrow">¶</a></p>
<div id="sharding">
<section id="section-4.1">
        <h3 id="name-sharding">
<a href="#section-4.1" class="section-number selfRef">4.1. </a><a href="#name-sharding" class="section-name selfRef">Sharding</a>
        </h3>
<p id="section-4.1-1">The sharding algorithm takes in the measurement (the input and weight), the
nonce, and the sharding randomness. The size of the nonce is <code>16</code> bytes; the
size of the randomness is <code>vidpf.RAND_SIZE + 2 * xof.SEED_SIZE</code>, plus an
additional <code>xof.SEED_SIZE</code> if the validity circuit takes joint randomness as
input.<a href="#section-4.1-1" class="pilcrow">¶</a></p>
<p id="section-4.1-2">The public share is the sequence of correction words output by the VIPDF key
generation algorithm. The contents of each input share, denoted
<code>MasticInputShare</code>, depends on the Aggregator who receives it. We refer to the
first Aggregator as the "Leader"; we refer to the second Aggregator as the
"Helper". The components of the input share are:<a href="#section-4.1-2" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1-3">
<li id="section-4.1-3.1">
            <p id="section-4.1-3.1.1">The Aggregator's VIDPF key share.<a href="#section-4.1-3.1.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.1-3.2">
            <p id="section-4.1-3.2.1">An optional FLP proof share, a vector of field elements. This is set for the
Leader only.<a href="#section-4.1-3.2.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.1-3.3">
            <p id="section-4.1-3.3.1">An optional seed. This is always set for the Helper, who uses it to derive
its FLP proof share. This is set for the Leader of the circuit uses joint
randomness.<a href="#section-4.1-3.3.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.1-3.4">
            <p id="section-4.1-3.4.1">The peer's FLP joint randomness seed, used to derive joint randomness for
the FLP's validity circuit. This is set for both the Leader and Helper only
if joint randomness is required (i.e., <code>flp.JOINT_RAND_LEN &gt; 0</code>).<a href="#section-4.1-3.4.1" class="pilcrow">¶</a></p>
</li>
        </ol>
<p id="section-4.1-4">The behavior of the sharding algorithm depends on whether the circuit requires
joint randomness:<a href="#section-4.1-4" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-4.1-5">
<pre>
def shard(self,
            ctx: bytes,
            measurement: tuple[tuple[bool, ...], W],
            nonce: bytes,
            rand: bytes,
            ) -&gt; tuple[list[CorrectionWord], list[MasticInputShare]]:
    if self.flp.JOINT_RAND_LEN &gt; 0:
        return self.shard_with_joint_rand(
            ctx, measurement, nonce, rand)
    return self.shard_without_joint_rand(
        ctx, measurement, nonce, rand)
</pre><a href="#section-4.1-5" class="pilcrow">¶</a>
</div>
<p id="section-4.1-6">When no FLP joint randomness is required, sharding involves the following
steps:<a href="#section-4.1-6" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1-7">
<li id="section-4.1-7.1">
            <p id="section-4.1-7.1.1">Encode the weight <code>weight</code> as <code>beta = [field(1)] + flp.encode(weight)</code>. The
prefix <code>[field(1)]</code>, is used to count how many reports share a prefix in
common and is usesd during unsharding. More details in <a href="#unsharding" class="auto internal xref">Section 4.5</a>.<a href="#section-4.1-7.1.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.1-7.2">
            <p id="section-4.1-7.2.1">Generate the VIDPF correction words and keys for input <code>alpha</code> and <code>beta</code> as
the payload.<a href="#section-4.1-7.2.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.1-7.3">
            <p id="section-4.1-7.3.1">Generate the FLP proof of validity for <code>flp.encode(weight)</code>.<a href="#section-4.1-7.3.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.1-7.4">
            <p id="section-4.1-7.4.1">Compute the Leader's share of the proof.<a href="#section-4.1-7.4.1" class="pilcrow">¶</a></p>
</li>
        </ol>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-4.1-8.1">
            <p id="section-4.1-8.1.1">NOTE Each correction word has length <code>flp.MEAS_LEN</code>. We could save a
little bit of communication by truncating the weights according to
<code>flp.truncate()</code>. However, we still need to encode the full weight at
least once, either separately or at the first level of the VIDPF tree.
See issue #98 for details.<a href="#section-4.1-8.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-4.1-9">The complete algorithm is listed below:<a href="#section-4.1-9" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-4.1-10">
<pre>
def shard_without_joint_rand(
        self,
        ctx: bytes,
        measurement: tuple[tuple[bool, ...], W],
        nonce: bytes,
        rand: bytes,
) -&gt; tuple[list[CorrectionWord], list[MasticInputShare]]:
    (vidpf_rand, rand) = front(self.vidpf.RAND_SIZE, rand)
    (prove_rand_seed, rand) = front(self.xof.SEED_SIZE, rand)
    (helper_seed, rand) = front(self.xof.SEED_SIZE, rand)
    assert len(rand) == 0  # REMOVE ME

    # Encode the inputs to VIDPF key generation. The output, denoted
    # `beta`, is a counter concatenated with the encoded weight.
    (alpha, weight) = measurement
    beta = [self.field(1)] + self.flp.encode(weight)

    # Generate VIDPF keys.
    (correction_words, keys) = \
        self.vidpf.gen(alpha, beta, ctx, nonce, vidpf_rand)

    # Generate FLP and split it into shares.
    prove_rand = self.prove_rand(ctx, prove_rand_seed)
    proof = self.flp.prove(beta[1:], prove_rand, [])
    helper_proof_share = self.helper_proof_share(ctx, helper_seed)
    leader_proof_share = vec_sub(proof, helper_proof_share)

    input_shares: list[MasticInputShare] = [
        (keys[0], leader_proof_share, None, None),
        (keys[1], None, helper_seed, None),
    ]
    return (correction_words, input_shares)
</pre><a href="#section-4.1-10" class="pilcrow">¶</a>
</div>
<p id="section-4.1-11">When FLP joint randomness is required, the Client must compute it from the
shares of <code>beta</code> sent to each Aggregator:<a href="#section-4.1-11" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1-12">
<li id="section-4.1-12.1">
            <p id="section-4.1-12.1.1">Encode the weight <code>weight</code> as <code>beta = [field(1)] + flp.encode(weight)</code>.<a href="#section-4.1-12.1.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.1-12.2">
            <p id="section-4.1-12.2.1">Generate the VIDPF correction words and keys for <code>alpha</code> and <code>beta</code>.<a href="#section-4.1-12.2.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.1-12.3">
            <p id="section-4.1-12.3.1">Compute each Aggregator's FLP joint randomness part by hashing its share of
<code>beta</code> with its FLP seed, its VIDPF key, and the VIDPF correction words.<a href="#section-4.1-12.3.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.1-12.4">
            <p id="section-4.1-12.4.1">Compute the FLP joint randomness seed by hashing the joint randomness parts.<a href="#section-4.1-12.4.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.1-12.5">
            <p id="section-4.1-12.5.1">Derive the FLP joint randomness from the joint randomness seed.<a href="#section-4.1-12.5.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.1-12.6">
            <p id="section-4.1-12.6.1">Generate the FLP proof of <code>beta</code>'s validity using the derived joint
randomness.<a href="#section-4.1-12.6.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.1-12.7">
            <p id="section-4.1-12.7.1">Compute the Leader's share of the proof.<a href="#section-4.1-12.7.1" class="pilcrow">¶</a></p>
</li>
        </ol>
<p id="section-4.1-13">The joint randomness is also needed to verify the FLP and must therefore be
recomputed during preparation (<a href="#preparation" class="auto internal xref">Section 4.2</a>). To accomplish this, the Client
includes in each Aggregator's input share the joint randomness part of its peer.<a href="#section-4.1-13" class="pilcrow">¶</a></p>
<p id="section-4.1-14">The complete algorithm is listed below:<a href="#section-4.1-14" class="pilcrow">¶</a></p>
<div class="breakable lang-python sourcecode" id="section-4.1-15">
<pre>
def shard_with_joint_rand(
        self,
        ctx: bytes,
        measurement: tuple[tuple[bool, ...], W],
        nonce: bytes,
        rand: bytes,
) -&gt; tuple[list[CorrectionWord], list[MasticInputShare]]:
    (vidpf_rand, rand) = front(self.vidpf.RAND_SIZE, rand)
    (prove_rand_seed, rand) = front(self.xof.SEED_SIZE, rand)
    (helper_seed, rand) = front(self.xof.SEED_SIZE, rand)
    (leader_seed, rand) = front(self.xof.SEED_SIZE, rand)
    assert len(rand) == 0  # REMOVE ME

    # Encode the inputs to VIDPF key generation. The output, denoted
    # `beta`, is a counter concatenated with the encoded weight.
    (alpha, weight) = measurement
    beta = [self.field(1)] + self.flp.encode(weight)

    # Generate VIDPF keys.
    (correction_words, keys) = \
        self.vidpf.gen(alpha, beta, ctx, nonce, vidpf_rand)

    # Generate FLP joint randomness.
    leader_beta_share = self.vidpf.get_beta_share(0, correction_words,
                                                    keys[0], ctx, nonce)
    helper_beta_share = self.vidpf.get_beta_share(1, correction_words,
                                                    keys[1], ctx, nonce)
    joint_rand_parts = [
        self.joint_rand_part(ctx, leader_seed, leader_beta_share[1:],
                                nonce),
        self.joint_rand_part(ctx, helper_seed, helper_beta_share[1:],
                                nonce),
    ]
    joint_rand = self.joint_rand(
        ctx, self.joint_rand_seed(ctx, joint_rand_parts))

    # Generate FLP and split it into shares.
    prove_rand = self.prove_rand(ctx, prove_rand_seed)
    proof = self.flp.prove(beta[1:], prove_rand, joint_rand)
    helper_proof_share = self.helper_proof_share(ctx, helper_seed)
    leader_proof_share = vec_sub(proof, helper_proof_share)

    leader_joint_rand_part: Optional[bytes] = joint_rand_parts[0]
    helper_joint_rand_part: Optional[bytes] = joint_rand_parts[1]
    input_shares = [
        (keys[0], leader_proof_share, leader_seed, helper_joint_rand_part),
        (keys[1], None, cast(Optional[bytes],
            helper_seed), leader_joint_rand_part),
    ]
    return (correction_words, input_shares)
</pre><a href="#section-4.1-15" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="preparation">
<section id="section-4.2">
        <h3 id="name-preparation">
<a href="#section-4.2" class="section-number selfRef">4.2. </a><a href="#name-preparation" class="section-name selfRef">Preparation</a>
        </h3>
<p id="section-4.2-1">Each Aggregator initializes preparation with: the verification key shared by
both Aggregators; its own ID, either <code>0</code> for the Leader and <code>1</code> for the Helper;
the aggregation parameter; the report's nonce; the public share sent to each
Aggregator; and the Aggregator's own input share.<a href="#section-4.2-1" class="pilcrow">¶</a></p>
<p id="section-4.2-2">The aggregation parameter has the following components:<a href="#section-4.2-2" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2-3">
<li id="section-4.2-3.1">
            <p id="section-4.2-3.1.1">the level of the VIDPF being evaluated<a href="#section-4.2-3.1.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.2-3.2">
            <p id="section-4.2-3.2.1">the sequence of VIDPF prefixes being evaluated<a href="#section-4.2-3.2.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.2-3.3">
            <p id="section-4.2-3.3.1">an indication of whether to verify the FLP<a href="#section-4.2-3.3.1" class="pilcrow">¶</a></p>
</li>
        </ol>
<p id="section-4.2-4">The FLP is verified exactly once, the first time the report is aggregated. See
<a href="#agg-param-validity" class="auto internal xref">Section 4.3</a>.<a href="#section-4.2-4" class="pilcrow">¶</a></p>
<p id="section-4.2-5">The outputs of the initialization algorithm include the Aggregator's prep
state, denoted <code>MasticPrepState</code>, and its outbound prep share, denoted
<code>MasticPrepShare</code>. The prep share includes the Aggregator's FLP verifier share,
joint randomness part, and VIDPF proof. These are combined into the prep
message in the next step.<a href="#section-4.2-5" class="pilcrow">¶</a></p>
<p id="section-4.2-6">Preparation initialization involves the following steps:<a href="#section-4.2-6" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2-7">
<li id="section-4.2-7.1">
            <p id="section-4.2-7.1.1">Evaluate the VIDPF share on the sequence of prefixes, obtaining our share of
the prefix tree.<a href="#section-4.2-7.1.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.2-7.2">
            <p id="section-4.2-7.2.1">If applicable, run the FLP query generation algorithm on our share of the
encoded weight to obtain our FLP verifier share. If joint randomness is
required, then compute our joint randomness part and derive the joint
randomness seed using our peer Aggregator's part provided by the Client.
Note that the Client may have provided the wrong part, so we need to check
that the seed was computed correctly before completing preparation.<a href="#section-4.2-7.2.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.2-7.3">
            <p id="section-4.2-7.3.1">Truncate each payload share according to the FLP encoding scheme and flatten
them into a single vector of field elements. This constitutes Mastic's
output share.<a href="#section-4.2-7.3.1" class="pilcrow">¶</a></p>
</li>
        </ol>
<p id="section-4.2-8">Moreover, when the Aggregators evaluate a Client's VIDPF, they verify three
properties of the prefix tree:<a href="#section-4.2-8" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2-9">
<li id="section-4.2-9.1">
            <p id="section-4.2-9.1.1">One-hotness: at every level of the tree, at most one node has a non-zero
payload.<a href="#section-4.2-9.1.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.2-9.2">
            <p id="section-4.2-9.2.1">Payload consistency: each payload is equal to the sum of the payloads of its
children. If one-hotness holds, then this ensures the payload is equal to
<code>beta</code> for each node along the <code>alpha</code> path.<a href="#section-4.2-9.2.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.2-9.3">
            <p id="section-4.2-9.3.1">Counter consistency: the counter of the non-zero payload is equal to
<code>field(1)</code>.<a href="#section-4.2-9.3.1" class="pilcrow">¶</a></p>
</li>
        </ol>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-4.2-10.1">
            <p id="section-4.2-10.1.1">TODO Define the "evaluation proof".<a href="#section-4.2-10.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-4.2-11">The complete algorithm is listed below:<a href="#section-4.2-11" class="pilcrow">¶</a></p>
<div class="breakable lang-python sourcecode" id="section-4.2-12">
<pre>
def prep_init(
        self,
        verify_key: bytes,
        ctx: bytes,
        agg_id: int,
        agg_param: MasticAggParam,
        nonce: bytes,
        correction_words: list[CorrectionWord],
        input_share: MasticInputShare,
) -&gt; tuple[MasticPrepState, MasticPrepShare]:
    (level, prefixes, do_weight_check) = agg_param
    (key, proof_share, seed, peer_joint_rand_part) = \
        self.expand_input_share(ctx, agg_id, input_share)

    # Evaluate the VIDPF.
    (out_share, root) = self.vidpf.eval_with_siblings(
        agg_id,
        correction_words,
        key,
        level,
        prefixes,
        ctx,
        nonce,
    )

    # Query the FLP if applicable.
    joint_rand_part = None
    joint_rand_seed = None
    verifier_share = None
    if do_weight_check:
        beta_share = self.vidpf.get_beta_share(agg_id, correction_words,
                                                key, ctx, nonce)
        query_rand = self.query_rand(verify_key, ctx, nonce, level)
        joint_rand = []
        if self.flp.JOINT_RAND_LEN &gt; 0:
            assert seed is not None
            assert peer_joint_rand_part is not None
            joint_rand_part = self.joint_rand_part(ctx, seed,
                                                    beta_share[1:], nonce)
            if agg_id == 0:
                joint_rand_parts = [joint_rand_part, peer_joint_rand_part]
            else:
                joint_rand_parts = [peer_joint_rand_part, joint_rand_part]
            joint_rand_seed = self.joint_rand_seed(ctx, joint_rand_parts)
            joint_rand = self.joint_rand(ctx, joint_rand_seed)
        verifier_share = self.flp.query(
            beta_share[1:],
            proof_share,
            query_rand,
            joint_rand,
            2,
        )

    # Payload and onehot checks.
    payload_check_binder = b''
    onehot_check_binder = b''
    assert root.left_child is not None
    assert root.right_child is not None
    q = [root.left_child, root.right_child]
    while len(q) &gt; 0:
        (n, q) = (q[0], q[1:])

        if n.left_child is not None and n.right_child is not None:
            # Update payload check. The weight of each node should equal
            # the sum of its children.
            payload_check_binder += self.field.encode_vec(
                vec_sub(n.w, vec_add(n.left_child.w, n.right_child.w)))
            q += [n.left_child, n.right_child]

        # Update the onehot check.
        onehot_check_binder += n.proof

    payload_check = self.xof(
        b'',
        dst_alg(ctx, USAGE_PAYLOAD_CHECK, self.ID),
        payload_check_binder,
    ).next(PROOF_SIZE)

    onehot_check = self.xof(
        b'',
        dst_alg(ctx, USAGE_ONEHOT_CHECK, self.ID),
        onehot_check_binder,
    ).next(PROOF_SIZE)

    # Counter check: the first element of beta should equal 1.
    #
    # Each aggregator holds an additive share of the counter, so
    # we have aggregator 1 negate its share and add 1 so that they
    # both compute the same value for `counter`.
    w0 = root.left_child.w
    w1 = root.right_child.w
    counter_check = self.field.encode_vec(
        [w0[0] + w1[0] + self.field(agg_id)])

    # Evaluation proof: if both aggregators compute the same
    # value, then they agree on the onehot proof, the counter, and
    # the payload.
    eval_proof = self.xof(
        verify_key,
        dst_alg(ctx, USAGE_EVAL_PROOF, self.ID),
        onehot_check + counter_check + payload_check,
    ).next(PROOF_SIZE)

    # Concatenate the output shares into one aggregatable output,
    # applying the FLP truncation algorithm on each FLP measurement
    # share.
    truncated_out_share = []
    for val_share in out_share:
        truncated_out_share += [val_share[0]] + \
            self.flp.truncate(val_share[1:])

    prep_state = (truncated_out_share, joint_rand_seed)
    prep_share = (eval_proof, verifier_share, joint_rand_part)
    return (prep_state, prep_share)
</pre><a href="#section-4.2-12" class="pilcrow">¶</a>
</div>
<p id="section-4.2-13">Next, the Aggregators' prep shares are combined into the prep message, denoted
<code>MasticPrepMessage</code>:<a href="#section-4.2-13" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2-14">
<li id="section-4.2-14.1">
            <p id="section-4.2-14.1.1">Check that both Aggregators computed the same VIDPF proof. If so, then it is
presumed that the output share is one-hot, has path consistency, and has
counter consistency as defined in <a href="#vidpf" class="auto internal xref">Section 3</a>.<a href="#section-4.2-14.1.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.2-14.2">
            <p id="section-4.2-14.2.1">If applicable, combine the FLP verifier shares into the FLP verifier and run
the FLP decision algorithm. If successful, then it is presumed that the
weight is valid.<a href="#section-4.2-14.2.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.2-14.3">
            <p id="section-4.2-14.3.1">If applicable, compute the FLP joint randomness seed from the parts.<a href="#section-4.2-14.3.1" class="pilcrow">¶</a></p>
</li>
        </ol>
<p id="section-4.2-15">The prep message consists of the optional joint randomness seed. The complete
algorithm is listed below:<a href="#section-4.2-15" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-4.2-16">
<pre>
def prep_shares_to_prep(
        self,
        ctx: bytes,
        agg_param: MasticAggParam,
        prep_shares: list[MasticPrepShare],
) -&gt; MasticPrepMessage:
    (_level, _prefixes, do_weight_check) = agg_param

    if len(prep_shares) != 2:
        raise ValueError('unexpected number of prep shares')

    (eval_proof_0,
     verifier_share_0,
     joint_rand_part_0) = prep_shares[0]
    (eval_proof_1,
     verifier_share_1,
     joint_rand_part_1) = prep_shares[1]

    # Verify the VIDPF output.
    if eval_proof_0 != eval_proof_1:
        raise Exception('VIDPF verification failed')

    if not do_weight_check:
        return None
    if verifier_share_0 is None or verifier_share_1 is None:
        raise ValueError('expected FLP verifier shares')

    # Verify the FLP.
    verifier = vec_add(verifier_share_0, verifier_share_1)
    if not self.flp.decide(verifier):
        raise Exception('FLP verification failed')

    if self.flp.JOINT_RAND_LEN == 0:
        return None
    if joint_rand_part_0 is None or joint_rand_part_1 is None:
        raise ValueError('expected FLP joint randomness parts')

    # Confirm the FLP joint randomness was computed properly.
    prep_msg = self.joint_rand_seed(ctx, [
        joint_rand_part_0,
        joint_rand_part_1,
    ])
    return prep_msg
</pre><a href="#section-4.2-16" class="pilcrow">¶</a>
</div>
<p id="section-4.2-17">Finally, each Aggregator completes preparation by checking that the true FLP
joint randomness seed is equal to the value they computed in the initialization
step, <code>prep_init()</code>. This is only done if a weight check was required by the
aggregation parameter and joint randomness was required by the FLP:<a href="#section-4.2-17" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-4.2-18">
<pre>
def prep_next(self,
                _ctx: bytes,
                prep_state: MasticPrepState,
                prep_msg: MasticPrepMessage,
                ) -&gt; list[F]:
    (truncated_out_share, joint_rand_seed) = prep_state
    if joint_rand_seed is not None:
        if prep_msg is None:
            raise ValueError('expected joint rand confirmation')

        if prep_msg != joint_rand_seed:
            raise Exception('joint rand confirmation failed')

    return truncated_out_share
</pre><a href="#section-4.2-18" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="agg-param-validity">
<section id="section-4.3">
        <h3 id="name-validity-of-aggregation-par">
<a href="#section-4.3" class="section-number selfRef">4.3. </a><a href="#name-validity-of-aggregation-par" class="section-name selfRef">Validity of Aggregation Parameters</a>
        </h3>
<p id="section-4.3-1">To guarantee secure execution of Mastic, care must be taken in choosing the
VIDPF prefixes and whether to verify the FLP. In particular, it is only safe to
consume the FLP once; and it is only safe to evaluate the VIDPF at most once at
any given level of the tree.<a href="#section-4.3-1" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-4.3-2.1">
            <p id="section-4.3-2.1.1">NOTE By "safe" we mean "covered by the analysis of <span>[<a href="#MPDST25" class="cite xref">MPDST25</a>]</span>". It could be
that we have a little more wiggle room, but we're not certain. If we find
matching attacks, we should mention them in <a href="#security-considerations" class="auto internal xref">Section 5</a>.<a href="#section-4.3-2.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-4.3-3">We further restrict aggregation by requiring that the level strictly increases
at each step:<a href="#section-4.3-3" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-4.3-4">
<pre>
def is_valid(self,
                agg_param: MasticAggParam,
                previous_agg_params: list[MasticAggParam],
                ) -&gt; bool:
    (level, _prefixes, do_weight_check) = agg_param

    # Check that the weight check is done exactly once.
    weight_checked = \
        (do_weight_check and len(previous_agg_params) == 0) or \
        (not do_weight_check and
            any(agg_param[2] for agg_param in previous_agg_params))

    # Check that the level is strictly increasing.
    level_increased = len(previous_agg_params) == 0 or \
        level &gt; previous_agg_params[-1][0]

    return weight_checked and level_increased
</pre><a href="#section-4.3-4" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="aggregation">
<section id="section-4.4">
        <h3 id="name-aggregation">
<a href="#section-4.4" class="section-number selfRef">4.4. </a><a href="#name-aggregation" class="section-name selfRef">Aggregation</a>
        </h3>
<p id="section-4.4-1">Each output share consists of the truncated payload for each VIDPF prefix,
flattened into a single vector. Aggregation involves simply adding these up:<a href="#section-4.4-1" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-4.4-2">
<pre>
def agg_init(self, agg_param: MasticAggParam) -&gt; list[F]:
    (_level, prefixes, _do_weight_check) = agg_param
    agg = self.field.zeros(len(prefixes)*(1+self.flp.OUTPUT_LEN))
    return agg

def agg_update(self,
                agg_param: MasticAggParam,
                agg_share: list[F],
                out_share: list[F]) -&gt; list[F]:
    return vec_add(agg_share, out_share)

def merge(self,
            agg_param: MasticAggParam,
            agg_shares: list[list[F]]) -&gt; list[F]:
    (_level, prefixes, _do_weight_check) = agg_param
    agg = self.agg_init(agg_param)
    for agg_share in agg_shares:
        agg = vec_add(agg, agg_share)
    return cast(list[F], agg)
</pre><a href="#section-4.4-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="unsharding">
<section id="section-4.5">
        <h3 id="name-unsharding">
<a href="#section-4.5" class="section-number selfRef">4.5. </a><a href="#name-unsharding" class="section-name selfRef">Unsharding</a>
        </h3>
<p id="section-4.5-1">The aggregate result consists of a list of total weights, each corresponding to
one of the prefixes. To compute it:<a href="#section-4.5-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.5-2">
<li id="section-4.5-2.1">
            <p id="section-4.5-2.1.1">Add up the aggregate shares.<a href="#section-4.5-2.1.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.5-2.2">
            <p id="section-4.5-2.2.1">For each prefix, decode the corresponding vector chunk using the FLP's
decoding algorithm (<span><a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-14#section-7.1.1" class="relref">Section 7.1.1</a> of [<a href="#VDAF" class="cite xref">VDAF</a>]</span>). This requires the prefix
count, which is also encoded by the chunk.<a href="#section-4.5-2.2.1" class="pilcrow">¶</a></p>
</li>
        </ol>
<p id="section-4.5-3">The complete algorithm is listed below:<a href="#section-4.5-3" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-4.5-4">
<pre>
def unshard(self,
            agg_param: MasticAggParam,
            agg_shares: list[list[F]],
            _num_measurements: int,
            ) -&gt; list[R]:
    agg = self.merge(agg_param, agg_shares)

    agg_result = []
    while len(agg) &gt; 0:
        (chunk, agg) = front(self.flp.OUTPUT_LEN + 1, agg)
        meas_count = chunk[0].int()
        agg_result.append(self.flp.decode(chunk[1:], meas_count))
    return agg_result
</pre><a href="#section-4.5-4" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="mastic-aux">
<section id="section-4.6">
        <h3 id="name-auxiliary-functions-2">
<a href="#section-4.6" class="section-number selfRef">4.6. </a><a href="#name-auxiliary-functions-2" class="section-name selfRef">Auxiliary Functions</a>
        </h3>
<div class="breakable lang-python sourcecode" id="section-4.6-1">
<pre>
def expand_input_share(
        self,
        ctx: bytes,
        agg_id: int,
        input_share: MasticInputShare,
) -&gt; tuple[bytes, list[F], Optional[bytes], Optional[bytes]]:
    if agg_id == 0:
        (key, proof_share, seed, peer_joint_rand_part) = input_share
        assert proof_share is not None
    else:
        (key, _leader_proof_share, seed, peer_joint_rand_part) = input_share
        assert seed is not None
        proof_share = self.helper_proof_share(ctx, seed)
    return (key, proof_share, seed, peer_joint_rand_part)

def helper_proof_share(self, ctx, seed: bytes) -&gt; list[F]:
    return self.xof.expand_into_vec(
        self.field,
        seed,
        dst_alg(ctx, USAGE_PROOF_SHARE, self.ID),
        b'',
        self.flp.PROOF_LEN,
    )

def prove_rand(self, ctx: bytes, seed: bytes) -&gt; list[F]:
    return self.xof.expand_into_vec(
        self.field,
        seed,
        dst_alg(ctx, USAGE_PROVE_RAND, self.ID),
        b'',
        self.flp.PROVE_RAND_LEN,
    )

def joint_rand_part(
        self,
        ctx: bytes,
        seed: bytes,
        weight_share: list[F],
        nonce: bytes,
) -&gt; bytes:
    return self.xof.derive_seed(
        seed,
        dst_alg(ctx, USAGE_JOINT_RAND_PART, self.ID),
        nonce + self.field.encode_vec(weight_share),
    )

def joint_rand_seed(self, ctx: bytes, parts: list[bytes]) -&gt; bytes:
    return self.xof.derive_seed(
        b'',
        dst_alg(ctx, USAGE_JOINT_RAND_SEED, self.ID),
        concat(parts),
    )

def joint_rand(self, ctx: bytes, seed: bytes) -&gt; list[F]:
    return self.xof.expand_into_vec(
        self.field,
        seed,
        dst_alg(ctx, USAGE_JOINT_RAND, self.ID),
        b'',
        self.flp.JOINT_RAND_LEN,
    )

def query_rand(self,
               verify_key: bytes,
               ctx: bytes,
               nonce: bytes,
               level: int) -&gt; list[F]:
    return self.xof.expand_into_vec(
        self.field,
        verify_key,
        dst_alg(ctx, USAGE_QUERY_RAND, self.ID),
        nonce + to_le_bytes(level, 2),
        self.flp.QUERY_RAND_LEN,
    )
</pre><a href="#section-4.6-1" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
<div id="security-considerations">
<section id="section-5">
      <h2 id="name-security-considerations">
<a href="#section-5" class="section-number selfRef">5. </a><a href="#name-security-considerations" class="section-name selfRef">Security Considerations</a>
      </h2>
<p id="section-5-1">Mastic inherits its security considerations from <span><a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-14#section-9" class="relref">Section 9</a> of [<a href="#VDAF" class="cite xref">VDAF</a>]</span>. A
security analysis of Mastic is provided in <span>[<a href="#MPDST25" class="cite xref">MPDST25</a>]</span>.<a href="#section-5-1" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-5-2.1">
          <p id="section-5-2.1.1">TODO Contrast with Poplar1, especially <span><a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-14#section-9.4.2" class="relref">Section 9.4.2</a> of [<a href="#VDAF" class="cite xref">VDAF</a>]</span> ("Safe
Usage of IDPF Outputs"). In particular, it's perfectly safe to use Mastic's
intermediate outputs.<a href="#section-5-2.1.1" class="pilcrow">¶</a></p>
</li>
      </ul>
</section>
</div>
<div id="iana-considerations">
<section id="section-6">
      <h2 id="name-iana-considerations">
<a href="#section-6" class="section-number selfRef">6. </a><a href="#name-iana-considerations" class="section-name selfRef">IANA Considerations</a>
      </h2>
<p id="section-6-1">IANA is requested to add new identifiers to the "Verifiable Distributed
Aggregation Functions (VDAF)" registry, that is described in <span><a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-14#section-10" class="relref">Section 10</a> of [<a href="#VDAF" class="cite xref">VDAF</a>]</span>. The new entries to the VDAF Identifier registry are as follows:<a href="#section-6-1" class="pilcrow">¶</a></p>
<span id="name-additional-codepoints-for-t"></span><div id="codepoints">
<table class="center" id="table-6">
        <caption>
<a href="#table-6" class="selfRef">Table 6</a>:
<a href="#name-additional-codepoints-for-t" class="selfRef">Additional codepoints for the VDAF Identifier Registry.</a>
        </caption>
<thead>
          <tr>
            <th class="text-left" rowspan="1" colspan="1">Value</th>
            <th class="text-left" rowspan="1" colspan="1">Scheme</th>
            <th class="text-left" rowspan="1" colspan="1">Type</th>
            <th class="text-left" rowspan="1" colspan="1">Reference</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>0xFFFF0001</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">MasticCount</td>
            <td class="text-left" rowspan="1" colspan="1">VDAF</td>
            <td class="text-left" rowspan="1" colspan="1">
              <a href="#vdaf" class="auto internal xref">Section 4</a> of RFC XXXX</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>0xFFFF0002</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">MasticSum</td>
            <td class="text-left" rowspan="1" colspan="1">VDAF</td>
            <td class="text-left" rowspan="1" colspan="1">
              <a href="#vdaf" class="auto internal xref">Section 4</a> of RFC XXXX</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>0xFFFF0003</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">MasticSumVec</td>
            <td class="text-left" rowspan="1" colspan="1">VDAF</td>
            <td class="text-left" rowspan="1" colspan="1">
              <a href="#vdaf" class="auto internal xref">Section 4</a> of RFC XXXX</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>0xFFFF0004</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">MasticHistogram</td>
            <td class="text-left" rowspan="1" colspan="1">VDAF</td>
            <td class="text-left" rowspan="1" colspan="1">
              <a href="#vdaf" class="auto internal xref">Section 4</a> of RFC XXXX</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>0xFFFF0005</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">MasticMultihotCountVec</td>
            <td class="text-left" rowspan="1" colspan="1">VDAF</td>
            <td class="text-left" rowspan="1" colspan="1">
              <a href="#vdaf" class="auto internal xref">Section 4</a> of RFC XXXX</td>
          </tr>
        </tbody>
      </table>
</div>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-6-3.1">
          <p id="section-6-3.1.1">TODO The codepoints in this section are from the private codepoint range and
are used for testing purposes. We will update this table with the codepoints
assigned by IANA.<a href="#section-6-3.1.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-6-4">(RFC EDITOR: Please replace "RFC XXXX" above with the RFC number assigned to
this document.)<a href="#section-6-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sec-combined-references">
<section id="section-7">
      <h2 id="name-references">
<a href="#section-7" class="section-number selfRef">7. </a><a href="#name-references" class="section-name selfRef">References</a>
      </h2>
<div id="sec-normative-references">
<section id="section-7.1">
        <h3 id="name-normative-references">
<a href="#section-7.1" class="section-number selfRef">7.1. </a><a href="#name-normative-references" class="section-name selfRef">Normative References</a>
        </h3>
<dl class="references">
<dt id="RFC2119">[RFC2119]</dt>
        <dd>
<span class="refAuthor">Bradner, S.</span>, <span class="refTitle">"Key words for use in RFCs to Indicate Requirement Levels"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 2119</span>, <span class="seriesInfo">DOI 10.17487/RFC2119</span>, <time datetime="1997-03" class="refDate">March 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/rfc/rfc2119">https://www.rfc-editor.org/rfc/rfc2119</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8174">[RFC8174]</dt>
        <dd>
<span class="refAuthor">Leiba, B.</span>, <span class="refTitle">"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 8174</span>, <span class="seriesInfo">DOI 10.17487/RFC8174</span>, <time datetime="2017-05" class="refDate">May 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/rfc/rfc8174">https://www.rfc-editor.org/rfc/rfc8174</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="VDAF">[VDAF]</dt>
      <dd>
<span class="refAuthor">Barnes, R.</span>, <span class="refAuthor">Cook, D.</span>, <span class="refAuthor">Patton, C.</span>, and <span class="refAuthor">P. Schoppmann</span>, <span class="refTitle">"Verifiable Distributed Aggregation Functions"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-irtf-cfrg-vdaf-14</span>, <time datetime="2025-01-10" class="refDate">10 January 2025</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-14">https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-14</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</div>
<div id="sec-informative-references">
<section id="section-7.2">
        <h3 id="name-informative-references">
<a href="#section-7.2" class="section-number selfRef">7.2. </a><a href="#name-informative-references" class="section-name selfRef">Informative References</a>
        </h3>
<dl class="references">
<dt id="BGI15">[BGI15]</dt>
        <dd>
<span class="refAuthor">Boyle, E.</span>, <span class="refAuthor">Gilboa, N.</span>, and <span class="refAuthor">Y. Ishai</span>, <span class="refTitle">"Function Secret Sharing"</span>, <span class="seriesInfo">EUROCRYPT 2015 </span>, <time datetime="2015" class="refDate">2015</time>, <span>&lt;<a href="https://www.iacr.org/archive/eurocrypt2015/90560300/90560300.pdf">https://www.iacr.org/archive/eurocrypt2015/90560300/90560300.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="CP22">[CP22]</dt>
        <dd>
<span class="refAuthor">de Castro, L.</span> and <span class="refAuthor">A. Polychroniadou</span>, <span class="refTitle">"Lightweight, Maliciously Secure Verifiable Function Secret Sharing"</span>, <span class="seriesInfo">EUROCRYPT 2022 </span>, <time datetime="2022" class="refDate">2022</time>, <span>&lt;<a href="https://iacr.org/cryptodb/data/paper.php?pubkey=31935">https://iacr.org/cryptodb/data/paper.php?pubkey=31935</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="DAP">[DAP]</dt>
        <dd>
<span class="refAuthor">Geoghegan, T.</span>, <span class="refAuthor">Patton, C.</span>, <span class="refAuthor">Rescorla, E.</span>, and <span class="refAuthor">C. A. Wood</span>, <span class="refTitle">"Distributed Aggregation Protocol for Privacy Preserving Measurement"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-ppm-dap-07</span>, <time datetime="2023-09-14" class="refDate">14 September 2023</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-ppm-dap-07">https://datatracker.ietf.org/doc/html/draft-ietf-ppm-dap-07</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="MPDST25">[MPDST25]</dt>
        <dd>
<span class="refAuthor">Mouris, D.</span>, <span class="refAuthor">Patton, C.</span>, <span class="refAuthor">Davis, H.</span>, <span class="refAuthor">Sarkar, P.</span>, and <span class="refAuthor">N. G. Tsoutsos</span>, <span class="refTitle">"Mastic: Private Weighted Heavy-Hitters and Attribute-Based Metrics"</span>, <span class="seriesInfo">PETS 2025 </span>, <time datetime="2025" class="refDate">2025</time>, <span>&lt;<a href="https://ia.cr/2024/221">https://ia.cr/2024/221</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="MST24">[MST24]</dt>
        <dd>
<span class="refAuthor">Mouris, D.</span>, <span class="refAuthor">Sarkar, P.</span>, and <span class="refAuthor">N. G. Tsoutsos</span>, <span class="refTitle">"PLASMA: Private, Lightweight Aggregated Statistics against Malicious Adversaries"</span>, <span class="seriesInfo">PETS 2024 </span>, <time datetime="2024" class="refDate">2024</time>, <span>&lt;<a href="https://ia.cr/2023/080">https://ia.cr/2023/080</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9110">[RFC9110]</dt>
        <dd>
<span class="refAuthor">Fielding, R., Ed.</span>, <span class="refAuthor">Nottingham, M., Ed.</span>, and <span class="refAuthor">J. Reschke, Ed.</span>, <span class="refTitle">"HTTP Semantics"</span>, <span class="seriesInfo">STD 97</span>, <span class="seriesInfo">RFC 9110</span>, <span class="seriesInfo">DOI 10.17487/RFC9110</span>, <time datetime="2022-06" class="refDate">June 2022</time>, <span>&lt;<a href="https://www.rfc-editor.org/rfc/rfc9110">https://www.rfc-editor.org/rfc/rfc9110</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RZCGP24">[RZCGP24]</dt>
        <dd>
<span class="refAuthor">Rathee, M.</span>, <span class="refAuthor">Zhang, Y.</span>, <span class="refAuthor">Corrigan-Gibbs, H.</span>, and <span class="refAuthor">R. A. Popa</span>, <span class="refTitle">"Private Analytics via Streaming, Sketching, and Silently Verifiable Proofs"</span>, <span class="seriesInfo">IEEE S&amp;P 2024 </span>, <time datetime="2024" class="refDate">2024</time>, <span>&lt;<a href="https://eprint.iacr.org/2024/666">https://eprint.iacr.org/2024/666</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="SHS">[SHS]</dt>
        <dd>
<span class="refTitle">"Secure hash standard"</span>, <span class="refContent">National Institute of Standards and Technology (U.S.)</span>, <span class="seriesInfo">DOI 10.6028/nist.fips.180-4</span>, <time datetime="2015" class="refDate">2015</time>, <span>&lt;<a href="https://doi.org/10.6028/nist.fips.180-4">https://doi.org/10.6028/nist.fips.180-4</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="W3C23">[W3C23]</dt>
      <dd>
<span class="refAuthor">W3C Working Group</span>, <span class="refTitle">"Network Error Logging"</span>, <time datetime="2023" class="refDate">2023</time>, <span>&lt;<a href="https://www.w3.org/TR/network-error-logging">https://www.w3.org/TR/network-error-logging</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</div>
</section>
</div>
<div id="acknowledgments">
<section id="appendix-A">
      <h2 id="name-acknowledgments">
<a href="#name-acknowledgments" class="section-name selfRef">Acknowledgments</a>
      </h2>
<p id="appendix-A-1">The Network Error Logging and Attribute-Based Browser Telemetry applications
(discussed next in section <a href="#motivation" class="auto internal xref">Appendix "Motivating Applications"</a>) were first described to the authors by the
PPM working group at IETF. The authors would like to thank Suleman Ahmad and
Simon Friedberger for their help in fleshing out the details. Dimitris Mouris
and Nektarios Georgios Tsoutsos would like to acknowledge the support of the
National Science Foundation (Award 2239334).<a href="#appendix-A-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="motivation">
<section id="appendix-B">
      <h2 id="name-motivating-applications">
<a href="#name-motivating-applications" class="section-name selfRef">Motivating Applications</a>
      </h2>
<p id="appendix-B-1">The design of Mastic is informed primarily by two use cases, which we describe
here.<a href="#appendix-B-1" class="pilcrow">¶</a></p>
<div id="NEL">
<section id="appendix-B.1">
        <h3 id="name-network-error-logging">
<a href="#name-network-error-logging" class="section-name selfRef">Network Error Logging</a>
        </h3>
<p id="appendix-B.1-1">Network Error Logging (NEL) is a mechanism used by web browsers to report
errors that occur while attempting to establish a connection to a server
<span>[<a href="#W3C23" class="cite xref">W3C23</a>]</span>. Some of these errors are visible to the server, but not all:
failures in DNS, TCP, TLS, and HTTP can occur without the server having any
visibility into the issue. A small amount of connection errors is expected,
even under normal operating conditions; but a sudden, substantial increase in
errors may be an indication of an outage, or a configuration issue impacting
millions of users. Without a reporting mechanism like NEL, these events would
only manifest in the server's telemetry as a drop in overall traffic.<a href="#appendix-B.1-1" class="pilcrow">¶</a></p>
<p id="appendix-B.1-2">NEL is particularly important for content delivery networks that handle HTTP
traffic for a large number of websites (typically millions). A content delivery
network acts as a reverse proxy between clients and origin servers that
provides a layer of caching and security services, such as DDoS protection.<a href="#appendix-B.1-2" class="pilcrow">¶</a></p>
<p id="appendix-B.1-3">Reports are comprised of the URL the client attempted to navigate to (e.g.,
"https://example.com"), the type of error that occurred, and metadata related
to the attempt, such as the time that elapsed between when the connection
attempt began and the error was observed (e.g., Section 7 of <span>[<a href="#W3C23" class="cite xref">W3C23</a>]</span>).
Clients may also report successful connection attempts to give the server a
sense of the error rate. The exact client behavior is determined by the
reporting policy specified by the server (see Section 5.1 of <span>[<a href="#W3C23" class="cite xref">W3C23</a>]</span>).<a href="#appendix-B.1-3" class="pilcrow">¶</a></p>
<p id="appendix-B.1-4">NEL data is privacy-sensitive for two reasons. First, it exposes information
that the server would not otherwise have access to, which can be abused to
probe the client's network configuration as described in Section 9 of
<span>[<a href="#W3C23" class="cite xref">W3C23</a>]</span>. Second, for operational reasons, the reporting endpoint may be
organizationally separated from the server (i.e., run on different cloud
infrastructures), leading to an increased risk of the client's browsing
history being exposed (e.g., in a data breach).<a href="#appendix-B.1-4" class="pilcrow">¶</a></p>
<p id="appendix-B.1-5">MPC helps mitigate these risks by revealing to the endpoint only the
information it needs to fulfill its service level objectives. This means, of
course, we must be satisfied with limited functionality. Fortunately, Mastic
allows us to preserve the most important functionality of NEL while minimizing
privacy loss.<a href="#appendix-B.1-5" class="pilcrow">¶</a></p>
<p id="appendix-B.1-6">Mastic can be applied to a simplified version of NEL where each client reports
a tuple <code>(dom, err)</code> consisting of a domain name dom (e.g., "example.com") and
a value err that represents an error (e.g., "dns.unreachable") or an indication
that no error occurred (e.g., "ok"). Notably, this can be easily extended in
Mastic to represent more elaborate metrics. e.g., where each weight includes
the time it took each browser to report the error (and the aggregate is the
average error reporting time), user agent (browser type and version), etc.
However, our main goal is to understand 1) the distribution of errors and 2)
which domains are impacted.<a href="#appendix-B.1-6" class="pilcrow">¶</a></p>
<p id="appendix-B.1-7">We expect there to be a large number of distinct domain names (millions in the
case of content delivery networks) and only a small number of error variants
(the NEL spec <span>[<a href="#W3C23" class="cite xref">W3C23</a>]</span> defines 30 variants). The following Mastic parameters
are suitable for this application.<a href="#appendix-B.1-7" class="pilcrow">¶</a></p>
<p id="appendix-B.1-8">Each input would encode the domain <code>dom</code> encoded with a number of bits
sufficient to uniquely represent most of the domains; and each weight would
represent the error variant <code>dom</code>. To compute the distribution of errors, we
would encode each error variant as a distinct bucket of a histogram so that
<code>[1, 0, 0, ...]</code> represents "ok", <code>[0, 1, 0, ...]</code> represents
"dns.unreachable", and so on. (See ection 6 of <span>[<a href="#W3C23" class="cite xref">W3C23</a>]</span>.), This is similar to
Prio3Histogram (<span><a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-14#section-7" class="relref">Section 7</a> of [<a href="#VDAF" class="cite xref">VDAF</a>]</span>.)<a href="#appendix-B.1-8" class="pilcrow">¶</a></p>
</section>
</div>
<div id="attribute-based-telemetry">
<section id="appendix-B.2">
        <h3 id="name-attribute-based-browser-tel">
<a href="#name-attribute-based-browser-tel" class="section-name selfRef">Attribute-Based Browser Telemetry</a>
        </h3>
<p id="appendix-B.2-1">Web browsers collect telemetry generated by users as they navigate the web to
gain insights into trends that guide product decisions. In many cases, Prio3
(<span><a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-14#section-7" class="relref">Section 7</a> of [<a href="#VDAF" class="cite xref">VDAF</a>]</span>) can be used to privately aggregate this telemetry.
However, this comes at the cost of flexibility.<a href="#appendix-B.2-1" class="pilcrow">¶</a></p>
<p id="appendix-B.2-2">For example, Prio3 can be used to collect page load metrics from Browser for a
list of known popular sites (e.g., "example.com"). The purpose of these metrics
is to detect if changes to these sites cause regressions that might be
correlated with an increased average load time or error rate. A subtle, but
important requirement for this system is the ability to break down the metrics
by client attributes. Suppose for example that we want to aggregate by 1) the
software version, and 2) the information about the client's location.<a href="#appendix-B.2-2" class="pilcrow">¶</a></p>
<p id="appendix-B.2-3">Mastic provides a simple solution to this problem. For the sake of
presentation, we consider a simplified use case (the same approach can be
applied to any aggregation task for which Prio3 (<span><a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-14#section-7" class="relref">Section 7</a> of [<a href="#VDAF" class="cite xref">VDAF</a>]</span>) is
suitable). Each client reports a tuple <code>(ver, loc, site, time)</code> where: <code>ver</code>
is a string representing the client's software version (e.g.,
"Browser/122.0"); <code>loc</code> is a string encoding its country code (e.g., "GR",
"US", "IN", etc.); <code>site</code> is one of a fixed set of sites (e.g., "example.com",
"example.org", etc.); and <code>time</code> is the load time of the site in seconds. The
version and location are included in the Mastic input; the site and load time
are encoded by the corresponding weight. Notably, this is just one example of
what Mastic can do; the same idea can be applied to other types of metrics.<a href="#appendix-B.2-3" class="pilcrow">¶</a></p>
<p id="appendix-B.2-4">Compared to the private NEL application in <a href="#NEL" class="auto internal xref">Appendix "Network Error Logging"</a>, the number of possible
inputs here is relatively small: there are less than 200 country codes and a
handful of browser versions in wide use at any given time. This means the
aggregators can enumerate a set of inputs of interest and evaluate them
immediately. Consider the following parameters for Mastic, in its
attribute-based metrics mode of operation <a href="#attribute-based-metrics" class="auto internal xref">Appendix "Attribute-based Metrics"</a>:<a href="#appendix-B.2-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-B.2-5.1">
            <p id="appendix-B.2-5.1.1">Attributes: Two-letter country codes can easily be encoded in 2 bytes.
Likewise, the number of distinct browser versions is easily less than 2^16,
so 2 bytes are sufficient. Therefore, each attribute can be encoded with just
<code>32</code> bits.<a href="#appendix-B.2-5.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="appendix-B.2-5.2">
            <p id="appendix-B.2-5.2.1">Values: Similar to private NEL, each weight is a <code>0</code>-vector except for a
single <code>1</code> representing a bucket in a histogram. We represent <code>(site, time)</code>
as a histogram bucket as follows. First, we quantize time (in seconds) into
one of four buckets: <code>[0, 0.1)</code>, <code>[0.1, 1)</code>, <code>[1, 5)</code>, and <code>[5, inf)</code>. Let <code>0
&lt; t &lt;= 4</code> denote the time bucket for <code>time</code>. Next, suppose we wish to track
metrics for <code>25</code> sites. Let <code>0 &lt; s &lt;= 25</code> denote the index of <code>site</code> in this
list. Then the index of 1 is simply <code>t * s</code>.<a href="#appendix-B.2-5.2.1" class="pilcrow">¶</a></p>
</li>
        </ul>
</section>
</div>
</section>
</div>
<div id="additional-modes">
<section id="appendix-C">
      <h2 id="name-modes-of-operation">
<a href="#name-modes-of-operation" class="section-name selfRef">Modes of Operation</a>
      </h2>
<div id="weighted-heavy-hitters">
<section id="appendix-C.1">
        <h3 id="name-weighted-heavy-hitters">
<a href="#name-weighted-heavy-hitters" class="section-name selfRef">Weighted Heavy-Hitters</a>
        </h3>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="appendix-C.1-1.1">
            <p id="appendix-C.1-1.1.1">NOTE See <a href="#NEL" class="auto internal xref">Appendix "Network Error Logging"</a> for a motivating application and
<code>example_weighted_heavy_hitters_mode()</code> in the reference implementation for
an end-to-end example.<a href="#appendix-C.1-1.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="appendix-C.1-2">The primary use case for Mastic is a variant of the heavy-hitters problem, in
which the prefix counts are replaced with a notion of weight that is specific
to some application. For example, when measuring the performance of an ad
campaign, it is useful to learn not only which ads led to purchases, but how
much money was spent.<a href="#appendix-C.1-2" class="pilcrow">¶</a></p>
<p id="appendix-C.1-3">To support this use case, we view the Client's <code>alpha</code> value as its measurement
and the <code>beta</code> value as the measurement's "weight". The range of valid values
for <code>beta</code> are therefore determined by the FLP with which Mastic is
instantiated. Concretely, validity of <code>beta</code> is expressed by a validity circuit
(<span><a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-14#section-7.3.2" class="relref">Section 7.3.2</a> of [<a href="#VDAF" class="cite xref">VDAF</a>]</span>).<a href="#appendix-C.1-3" class="pilcrow">¶</a></p>
<p id="appendix-C.1-4">To compute the weighted heavy-hitters, the Collector and Aggregators proceed as
described in <span><a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-14#section-8" class="relref">Section 8</a> of [<a href="#VDAF" class="cite xref">VDAF</a>]</span>, except that the threshold represents a
minimum weight rather than a minimum count. In addition:<a href="#appendix-C.1-4" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="appendix-C.1-5">
<li id="appendix-C.1-5.1">
            <p id="appendix-C.1-5.1.1">The Aggregators <span class="bcp14">MUST</span> perform the range check (i.e., verify the FLP) at the
first round of aggregation and remove any invalid reports before proceeding.<a href="#appendix-C.1-5.1.1" class="pilcrow">¶</a></p>
</li>
          <li id="appendix-C.1-5.2">
            <p id="appendix-C.1-5.2.1">The level at which the reports are Aggregated <span class="bcp14">MUST</span> be strictly increasing.<a href="#appendix-C.1-5.2.1" class="pilcrow">¶</a></p>
</li>
        </ol>
<div id="different-thresholds">
<section id="appendix-C.1.1">
          <h4 id="name-different-thresholds">
<a href="#name-different-thresholds" class="section-name selfRef">Different Thresholds</a>
          </h4>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="appendix-C.1.1-1.1">
              <p id="appendix-C.1.1-1.1.1">NOTE For an end-to-end example, see
<code>example_weighted_heavy_hitters_mode_with_different_thresholds()</code> in the
reference implementation.<a href="#appendix-C.1.1-1.1.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="appendix-C.1.1-2">So far, we have assumed that there is a single threshold for determining which
prefixes are "heavy". However, we can easily extend this to have different
thresholds for different prefixes. There exist use-cases where prefixes
starting with "000" may be significantly more popular than prefixes starting
with "111". Setting a low threshold may result in an overwhelmingly big set of
heavy hitters starting with "000", while setting a high threshold might prune
anything starting with "111". Consider the following examples:<a href="#appendix-C.1.1-2" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="appendix-C.1.1-3">
<li id="appendix-C.1.1-3.1">
              <p id="appendix-C.1.1-3.1.1">Popular URLs: <code>a.example.com</code> receives a massive amount of traffic whereas
<code>b.example.com</code> may have lower traffic. To identify heavy-hitting search
queries on <code>a.example.com</code>, the Aggregators should set a high threshold,
while queries with different domain prefixes may require lower thresholds to
be considered popular.<a href="#appendix-C.1.1-3.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="appendix-C.1.1-3.2">
              <p id="appendix-C.1.1-3.2.1">E-commerce: Grocery items are essential and have a high volume of sales. In
contrast, electronics, though popular, usually come with a higher price
compared to groceries. Meanwhile, luxury items command significantly higher
prices but generally experience lower sales volumes. To identify
heavy-hitting grocery items on an e-commerce website, Aggregators could use
different threshold for each of these categories. These thresholds are set
to ensure that only the top-selling grocery items qualify as heavy hitters
while electronics and luxury items are also considered heavy hitters on
their own categories.<a href="#appendix-C.1.1-3.2.1" class="pilcrow">¶</a></p>
</li>
          </ol>
<p id="appendix-C.1.1-4">To tackle this, Mastic can allow different prefixes having different
thresholds. When a specific prefix does not have an associated threshold, we
first search if any of its prefixes has a specified threshold, otherwise we
use a default threshold. For example, if the Aggregators have set the
thresholds to be <code>{"000": 10, "111": 2, "default": 5}</code> and the search for
prefix "01", then threshold 5 should be used. However, if the Aggregators
search for prefix "11101", then threshold 2 should be used.<a href="#appendix-C.1.1-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="attribute-based-metrics">
<section id="appendix-C.2">
        <h3 id="name-attribute-based-metrics">
<a href="#name-attribute-based-metrics" class="section-name selfRef">Attribute-based Metrics</a>
        </h3>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="appendix-C.2-1.1">
            <p id="appendix-C.2-1.1.1">NOTE See <a href="#attribute-based-telemetry" class="auto internal xref">Appendix "Attribute-Based Browser Telemetry"</a> for a motivating application and
<code>example_attribute_based_metrics_mode()</code> in the reference implementation for
an end-to-end example.<a href="#appendix-C.2-1.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="appendix-C.2-2">In this mode of operation, we take the <code>beta</code> value to be the Client's
measurement and <code>alpha</code> to be an arbitrary "attribute". For a given sequence of
attributes, the goal of the Collector is to aggregate the measurements that
share the same attribute. This provides functionality similar to Prio3
<span>[<a href="#VDAF" class="cite xref">VDAF</a>]</span>, except that the aggregate is partitioned by Clients who share some
property. For example, the attribute might encode the Client's user agent
<span>[<a href="#RFC9110" class="cite xref">RFC9110</a>]</span>.<a href="#appendix-C.2-2" class="pilcrow">¶</a></p>
<p id="appendix-C.2-3">Mastic requires each <code>alpha</code> to have the same length (<code>Vidpf.BITS</code>). Thus, it
is necessary for each application to choose a scheme for encoding attributes as
fixed-length strings. The following scheme is <span class="bcp14">RECOMMENDED</span>. Choose a
cryptographically secure hash function, such as SHA256
<span>[<a href="#SHS" class="cite xref">SHS</a>]</span>, compute the hash of the Client's input
string, and interpret each bit of the hash as a bit of the VIDPF index.<a href="#appendix-C.2-3" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="appendix-C.2-4.1">
            <p id="appendix-C.2-4.1.1">TODO Are we comfortable recommending truncating the hash? Collisions aren't so
bad since the Client can just lie about <code>alpha</code> anyway. The main thing is to
pick a value for <code>BITS</code> that is large enough to avoid accidental collisions.<a href="#appendix-C.2-4.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="appendix-C.2-5">The Aggregators <span class="bcp14">MAY</span> aggregate a report any number times, but:<a href="#appendix-C.2-5" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="appendix-C.2-6">
<li id="appendix-C.2-6.1">
            <p id="appendix-C.2-6.1.1">They <span class="bcp14">MUST</span> perform the range check (i.e., verify the FLP) the first time the
reports are aggregated and remove any invalid reports before aggregating
again.<a href="#appendix-C.2-6.1.1" class="pilcrow">¶</a></p>
</li>
          <li id="appendix-C.2-6.2">
            <p id="appendix-C.2-6.2.1">The aggregation parameter <span class="bcp14">MUST</span> specify the last level of the VIDPF tree
(i.e., <code>level</code> <span class="bcp14">MUST</span> be <code>Vidpf.BITS-1</code>).<a href="#appendix-C.2-6.2.1" class="pilcrow">¶</a></p>
</li>
        </ol>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="appendix-C.2-7.1">
            <p id="appendix-C.2-7.1.1">TODO Figure out if these requirements are strict enough. We may need to
tighten aggregation parameter validity if we find out that aggregating at the
same level more than once is not safe.<a href="#appendix-C.2-7.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
</section>
</div>
<div id="plain-heavy-hitters-with-proof-aggregation">
<section id="appendix-C.3">
        <h3 id="name-plain-heavy-hitters-with-vi">
<a href="#name-plain-heavy-hitters-with-vi" class="section-name selfRef">Plain Heavy-Hitters with VIDPF-Proof Aggregation</a>
        </h3>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="appendix-C.3-1.1">
            <p id="appendix-C.3-1.1.1">TODO Take "silently verifiable proofs" from <span>[<a href="#RZCGP24" class="cite xref">RZCGP24</a>]</span> into account
here, which allows us to aggregate the FLPs as well.<a href="#appendix-C.3-1.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="appendix-C.3-2">The total communication cost of using Mastic (or Poplar1 <span>[<a href="#VDAF" class="cite xref">VDAF</a>]</span>) for heavy
hitters is <code>O(num_measurements * Vidpf.BITS)</code> bits exchanged between the
Aggregators, where <code>num_measurements</code> is the number of reports being
aggregated. For plain heavy-hitters, this can be reduced to <code>O(Vidpf.BITS)</code> in
the best case.<a href="#appendix-C.3-2" class="pilcrow">¶</a></p>
<p id="appendix-C.3-3">The idea is to take advantage of the feature of VIDPF evaluation whereby the
Aggregators compute identical VIDPF proofs if and only if the report is valid.
This allows the proofs themselves to be aggregated: if each report in a batch
of reports is valid, then the hash of their proofs will be equal as well; on
the other hand, if one report is invalid, then the hash of the proofs will not
be equal.<a href="#appendix-C.3-3" class="pilcrow">¶</a></p>
<p id="appendix-C.3-4">To facilitate isolation of the invalid report(s), the proof strings are
arranged into a Merkle tree. During aggregation, the Aggregators interactively
traverse the tree to detect the subtree(s) containing invalid reports and
remove them from the batch.<a href="#appendix-C.3-4" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="appendix-C.3-5.1">
            <p id="appendix-C.3-5.1.1">TODO Decide if we should spell this out in greater detail. This feature
is not compatible with <span>[<a href="#DAP" class="cite xref">DAP</a>]</span>; if we wanted to
extend DAP to support this, then we'd need to specify the wire format of the
messages exchanged between the Aggregators.<a href="#appendix-C.3-5.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="appendix-C.3-6">In the worst case, isolating invalid reports requires <code>O(num_measurements *
Vidpf.BITS)</code> bits of communication and <code>Vidpf.BITS</code> many rounds of
communication between the Aggregators. However, this behavior would only be
observed under attack conditions in which the vast majority of Clients are
malicious.<a href="#appendix-C.3-6" class="pilcrow">¶</a></p>
<p id="appendix-C.3-7">In the simple case where the <code>beta</code> value is a constant (e.g., 1) we can
replace the FLP check with a simpler check. FLPs are not compatible with proof
aggregation the way VIDPFs are. In order to perform the range check without
FLPs, we use an extension of VIDPF described by <span>[<a href="#MST24" class="cite xref">MST24</a>]</span>. The high-level idea
here is that the Aggregators can evaluate the empty string and verify that they
have shares of the constant <code>beta</code>. Next, as described in <a href="#vdaf" class="auto internal xref">Section 4</a>, we use the
"one-hot verifiability" and "path verifiability" checks to verify that each
level is non-zero at only a single point and that the same constant <code>beta</code> is
propagated down the tree correctly. Note that this trick is not suitable for
weighted heavy-hitters, since it expects that each <code>beta</code> value is constant
(e.g., 1).<a href="#appendix-C.3-7" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="appendix-C.3-8.1">
            <p id="appendix-C.3-8.1.1">TODO Proof aggregation could work with plain Mastic, but we would need
to check the FLPs at the first round of aggregation, leading to best-case
communication cost would be <code>O(num_measurements + Vidpf.BITS)</code>. This would be
OK, but we would still want to support a mode for plain heavy-hitters that is
as good as we can get.<a href="#appendix-C.3-8.1.1" class="pilcrow">¶</a></p>
<p id="appendix-C.3-8.1.2">One idea is to always do the PLASMA <code>0</code>/<code>1</code> check alongside the FLP. This
would be useful for another reason: Usually FLP decoding requires
<code>num_measurements</code> as a parameter. We currently don't support this because we
currently don't have a pure counter as part of the VIDPF output.<a href="#appendix-C.3-8.1.2" class="pilcrow">¶</a></p>
</li>
        </ul>
</section>
</div>
<div id="malicious-security-with-three-aggregators">
<section id="appendix-C.4">
        <h3 id="name-robustness-against-a-malici">
<a href="#name-robustness-against-a-malici" class="section-name selfRef">Robustness Against a Malicious Aggregator</a>
        </h3>
<p id="appendix-C.4-1">Next, we describe an enhancement that allows Mastic to achieve robustness in
the presence of a malicious Aggregator. The two-party Mastic (as well as
Poplar1) is susceptible to additive attacks by a malicious Aggregator. In more
detail, if one of the Aggregators starts acting maliciously, they can
arbitrarily add to the aggregation result (simply by adding to their own
aggregation shares) without the honest Aggregator noticing.<a href="#appendix-C.4-1" class="pilcrow">¶</a></p>
<p id="appendix-C.4-2">We can solve this problem in Mastic by using a technique from <span>[<a href="#MST24" class="cite xref">MST24</a>]</span> that
lifts the two-party semi-honest secure PLASMA to the three-party maliciously
secure setting. Rather than having two Aggregators as in the previous setting,
this flavor involves three Aggregators, where every pair of Aggregators
communicate over a different channel. In essence, each pair of Aggregators
will run one session of the VDAF with unique randomness but on the same Client
measurement. The following changes are necessary:<a href="#appendix-C.4-2" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="appendix-C.4-3">
<li id="appendix-C.4-3.1">
            <p id="appendix-C.4-3.1.1">The Client needs to generate three pairs of VIDPF keys all corresponding to
the same <code>alpha</code> and <code>beta</code> values. We represent the keys based on the
session as follows:<a href="#appendix-C.4-3.1.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="appendix-C.4-3.1.2">
<li id="appendix-C.4-3.1.2.1">
                <p id="appendix-C.4-3.1.2.1.1">Session 0 (between Aggregators 0 and 1): <code>key_01, key_10</code><a href="#appendix-C.4-3.1.2.1.1" class="pilcrow">¶</a></p>
</li>
              <li id="appendix-C.4-3.1.2.2">
                <p id="appendix-C.4-3.1.2.2.1">Session 1 (between Aggregators 1 and 2): <code>key_12, key_21</code><a href="#appendix-C.4-3.1.2.2.1" class="pilcrow">¶</a></p>
</li>
              <li id="appendix-C.4-3.1.2.3">
                <p id="appendix-C.4-3.1.2.3.1">Session 2 (between Aggregators 2 and 0): <code>key_20, key_02</code><a href="#appendix-C.4-3.1.2.3.1" class="pilcrow">¶</a></p>
</li>
            </ol>
<p id="appendix-C.4-3.1.3">
Each pair of Aggregators cannot check that the Client input is consistent
across two sessions without the involvement of the third Aggregator. To
address this, we let two Aggregators (i.e., Aggregators 0 and 1) to run all
three sessions so that they can check that the Client input is consistent
across three sessions. The third Aggregator (i.e., Aggregator 2) is involved
as an attestator in two of the sessions. The check involves field addition
and subtraction and then hash comparisons.<a href="#appendix-C.4-3.1.3" class="pilcrow">¶</a></p>
</li>
          <li id="appendix-C.4-3.2">
            <p id="appendix-C.4-3.2.1">The Client sends the following keys to the Aggregators:<a href="#appendix-C.4-3.2.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="appendix-C.4-3.2.2">
<li id="appendix-C.4-3.2.2.1">
                <p id="appendix-C.4-3.2.2.1.1">Aggregator 0 receives: <code>key_01</code>, <code>key_02</code>, and <code>key_21</code><a href="#appendix-C.4-3.2.2.1.1" class="pilcrow">¶</a></p>
</li>
              <li id="appendix-C.4-3.2.2.2">
                <p id="appendix-C.4-3.2.2.2.1">Aggregator 1 receives: <code>key_10</code>, <code>key_12</code>, and <code>key_20</code><a href="#appendix-C.4-3.2.2.2.1" class="pilcrow">¶</a></p>
</li>
              <li id="appendix-C.4-3.2.2.3">
                <p id="appendix-C.4-3.2.2.3.1">Aggregator 2 receives: <code>key_21</code> and <code>key_20</code><a href="#appendix-C.4-3.2.2.3.1" class="pilcrow">¶</a></p>
</li>
            </ol>
</li>
          <li id="appendix-C.4-3.3">
            <p id="appendix-C.4-3.3.1">The Aggregators need to verify that the Client's input is consistent across
the different sessions (i.e., that all the keys correspond to the same
<code>alpha</code> and <code>beta</code> values). Aggregators 0 and 1 check that:<a href="#appendix-C.4-3.3.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="appendix-C.4-3.3.2">
<li id="appendix-C.4-3.3.2.1">
                <p id="appendix-C.4-3.3.2.1.1">Their output shares of Session 0 minus their output shares of Session 1
 are shares of zero<a href="#appendix-C.4-3.3.2.1.1" class="pilcrow">¶</a></p>
</li>
              <li id="appendix-C.4-3.3.2.2">
                <p id="appendix-C.4-3.3.2.2.1">Their output shares of Session 1 minus their output shares of Session 2
are shares of zero.<a href="#appendix-C.4-3.3.2.2.1" class="pilcrow">¶</a></p>
</li>
            </ol>
<p id="appendix-C.4-3.3.3">
The subtraction is a local operation and verifying that two Aggregators
possess a sharing of zero requires exchanging one hash.<a href="#appendix-C.4-3.3.3" class="pilcrow">¶</a></p>
</li>
        </ol>
<p id="appendix-C.4-4">Using a third Aggregator, we can lift the security of Mastic from the
semi-honest setting to malicious security. While more complex to implement than
2-party Mastic, this mode allows achieves both privacy and robustness against a
malicious Aggregator.<a href="#appendix-C.4-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="test-vectors">
<section id="appendix-D">
      <h2 id="name-test-vectors">
<a href="#name-test-vectors" class="section-name selfRef">Test Vectors</a>
      </h2>
<p id="appendix-D-1">TODO<a href="#appendix-D-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="contributors">
<section id="appendix-E">
      <h2 id="name-contributors">
<a href="#name-contributors" class="section-name selfRef">Contributors</a>
      </h2>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Pratik Sarkar</span></div>
<div dir="auto" class="left"><span class="org">Supra Research</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:pratik93@bu.edu" class="email">pratik93@bu.edu</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">David Cook</span></div>
<div dir="auto" class="left"><span class="org">ISRG</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:dcook@divviup.org" class="email">dcook@divviup.org</a>
</div>
</address>
</section>
</div>
<div id="authors-addresses">
<section id="appendix-F">
      <h2 id="name-authors-addresses">
<a href="#name-authors-addresses" class="section-name selfRef">Authors' Addresses</a>
      </h2>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Hannah Davis</span></div>
<div dir="auto" class="left"><span class="org">Seagate</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:hannah.e.davis@seagate.com" class="email">hannah.e.davis@seagate.com</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Dimitris Mouris</span></div>
<div dir="auto" class="left"><span class="org">Nillion</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:dimitris@nillion.com" class="email">dimitris@nillion.com</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Christopher Patton</span></div>
<div dir="auto" class="left"><span class="org">Cloudflare</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:chrispatton+ietf@gmail.com" class="email">chrispatton+ietf@gmail.com</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Nektarios G. Tsoutsos</span></div>
<div dir="auto" class="left"><span class="org">University of Delaware</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:tsoutsos@udel.edu" class="email">tsoutsos@udel.edu</a>
</div>
</address>
</section>
</div>
<script>const toc = document.getElementById("toc");
toc.querySelector("h2").addEventListener("click", e => {
  toc.classList.toggle("active");
});
toc.querySelector("nav").addEventListener("click", e => {
  toc.classList.remove("active");
});
</script>
</body>
</html>
